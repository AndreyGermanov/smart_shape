{"version":3,"file":"smart_shape.umd.cjs","sources":["src/events/EventsManager.js","src/utils/geometry.js","src/utils/deepmerge.js","src/utils/index.js","src/events/functions.js","../context_menu/src/EventsManager.js","../context_menu/src/MenuStylesHelper.js","../context_menu/src/functions.js","../context_menu/src/Menu.js","../context_menu/src/Menus.js","../context_menu/src/index.js","assets/graphics.js","src/SmartPoint/SmartPointContextMenu.js","src/SmartPoint/SmartPoint.js","src/RotateBox/RotateBoxEventListener.js","src/ResizeBox/ResizeBoxEventListener.js","src/SmartShape/SmartShapeEventListener.js","src/SmartShape/SmartShapeDrawHelper.js","src/SmartShapeManager/GeoJSONImport.js","src/SmartShapeManager/SmartShapeManager.js","src/SmartShape/SmartShapeGroupHelper.js","src/RotateBox/RotateBox.js","src/SmartShape/SmartShapeContextMenu.js","src/SmartShape/SmartShape.js","src/ResizeBox/ResizeBox.js","src/index.js"],"sourcesContent":["/**\n * Used as a singleton object to emit events and subscribe to these events.\n * One object can subscribe to events of specified type, other object can emit events of this type.\n * Each time when object emits event, all subscribed event handlers triggered.\n * @constructor\n */\n\nfunction EventsManager() {\n\n    /**\n     * Hashmap of all registered event subscriptions.\n     * Keys are event names as strings. Values are arrays of functions.\n     * Several handlers can subscribe to each event by providing function that should be triggered.\n     * this.subscriptions[event_name] = [handler_func,handler_func ...]\n     * @type {object}\n     */\n    this.subscriptions = {};\n\n    /**\n     * Add subscription to event of specified type or to array of events of specified types\n     * @param events {string|array} Name of event as a string or names of events as an array of strings.\n     * @param handler {function} Handling function, which will be called each time when event of this type emitted.\n     * Each time, when handling function triggered, it receives a single argument - `event` {object} which contains\n     * the following fields: `type` - type of event (`eventType`), `target` - pointer to object, which emitted\n     * this event, and also any custom params, that emitter sent with this event by using `emit` method.\n     * @returns {function} Pointer to handling function, that will be added\n     */\n    this.subscribe = (events,handler) => {\n        if (typeof(events) === \"string\") {\n            return this.subscribeToEvent(events,handler)\n        } else if (typeof(events) === \"object\") {\n            for (let event of events) {\n                this.subscribeToEvent(event,handler)\n            }\n            return handler;\n        }\n        return null;\n    }\n\n    /**\n     * @ignore\n     * Add subscription to event of specified type\n     * @param eventName {string|array} Name of event as a string or array of names of events to subscribe to\n     * @param handler {function} Handling function, which will be called each time when event of this type emitted.\n     * Each time, when handling function triggered, it receives a single argument - `event` {object} which contains\n     * the following fields: `type` - type of event (`eventType`), `target` - pointer to object, which emitted\n     * this event, and also any custom params, that emitter sent with this event by using `emit` method.\n     * @returns {function} Pointer to handling function, that will be added\n     */\n    this.subscribeToEvent = (eventName,handler) => {\n        if (typeof(this.subscriptions[eventName]) === \"undefined\" || !this.subscriptions[eventName]) {\n            this.subscriptions[eventName] = [];\n        }\n        if (typeof(this.subscriptions[eventName].find(h => h === handler)) !== \"undefined\") {\n            return null;\n        }\n        this.subscriptions[eventName].push(handler);\n        return handler;\n    }\n\n    /**\n     * Emits event of specified name. Based on specified arguments, it constructs `event` object, that contains\n     * the following fields: `type` - eventName, `target` - object that emitted this event and any other fields\n     * that received from `params` argument. Then, all subscribers will receive this `event` object to their handling\n     * functions.\n     * @param eventName {string} Name of event to emit.\n     * @param target {object} Which object emitted this event.\n     * @param params {object} Event specific params. Can be any number of params.\n     * @returns {boolean} True if this event triggered at least of one handler, or false if it does not.\n     */\n    this.emit = (eventName,target,params=null) => {\n        if (!params || typeof(params) !== \"object\") {\n            params = {}\n        }\n        params[\"type\"] = eventName;\n        params[\"target\"] = target;\n        if (typeof(this.subscriptions[eventName]) !== \"undefined\" && this.subscriptions[eventName] &&\n        this.subscriptions[eventName].length) {\n            for (let handler of this.subscriptions[eventName]) {\n                handler(params)\n            }\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Removes specified handler from event with specified name or from array of events with specified names.\n     * @param events {string|array} Name of event as a string or names of events as an array of strings.\n     * @param handler {function} Pointer to a function to remove. (This pointer returned from `subscribe` method and\n     * can be used here to unsubscribe\n     * @returns {boolean} True if really removed the handler or false if you could not remove because it does not exist\n     */\n    this.unsubscribe = (events, handler) => {\n        let result = false;\n        if (typeof(events) === \"string\") {\n            if (this.unsubscribeFromEvent(events,handler)) {\n                result = true;\n            }\n        } else if (typeof(events) === \"object\") {\n            for (let event of events) {\n                if (this.unsubscribeFromEvent(event,handler)) {\n                    result = true;\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @ignore\n     * Removes specified handler from event with specified name.\n     * @param eventName {string} Name of event as a string\n     * @param handler {function} Pointer to a function to remove. (This pointer returned from `subscribe` method and\n     * can be used here to unsubscribe\n     * @returns {boolean} True if really removed the handler or false if you could not remove because it does not exist\n     */\n    this.unsubscribeFromEvent = (eventName,handler) => {\n        if (typeof(this.subscriptions[eventName]) === \"undefined\" || !this.subscriptions[eventName]) {\n            return false\n        }\n        const index = this.subscriptions[eventName].indexOf(handler);\n        if (index !== -1) {\n            this.subscriptions[eventName].splice(index,1);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Method removes all subscriptions to events.\n     */\n    this.clear = () => {\n        this.subscriptions = {};\n    }\n}\n\nexport default new EventsManager();\n","import {abs} from \"./index.js\";\n\n/**\n * @ignore\n * Function converts degrees to radians\n * @param degrees {number} Angle in degrees\n * @returns {number} Angle in radians\n */\nexport const degrees_to_radians = (degrees) =>  degrees * (Math.PI/180);\n\n/**\n * @ignore\n * Functions converts radians to degrees\n * @param radians {number} Angle in radians\n * @returns {number} Angle in degrees\n */\nexport const radians_to_degrees = (radians) => radians * (180/Math.PI);\n\n/**\n * @ignore\n * Function used to rotate point with specified coordinate x,y around the center with\n * coordinates centerX, centerY by specified angle in degrees.\n * @param angle {number} Rotation angle\n * @param x {number} X coordinate of point\n * @param y {number} Y coordinate of point\n * @param centerX {number} X coordinate of center\n * @param centerY {number} Y coordinate of center\n * @returns {array} New coordinates of point in array [x,y]\n */\nexport const getRotatedCoords = (angle, x, y, centerX, centerY) => {\n    if (angle === 0) {\n        return [x,y];\n    }\n    const radians = degrees_to_radians(angle);\n    const resultX = (x-centerX)*Math.cos(radians)-(y-centerY)*Math.sin(radians)+centerX;\n    const resultY = (x-centerX)*Math.sin(radians)+(y-centerY)*Math.cos(radians)+centerY;\n    return [resultX, resultY];\n}\n\n/**\n * @ignore\n * Function calculates euclidean distance between two points\n * @param x1 {number} X coordinate of point 1\n * @param y1 {number} Y coordinate of point 1\n * @param x2 {number} X coordinate of point 2\n * @param y2 {number} Y coordinate of point 2\n * @returns {number} Distance from (x1,y1) to (x2,y2)\n */\nexport const distance = (x1,y1,x2,y2) => {\n    return Math.sqrt(Math.pow(x2-x1,2)+Math.pow(y2-y1,2))\n}\n\n/**\n * @ignore\n * Function calculates distance from point (x0,y0) to line, defined by points (x1,y1) and (x2,y2)\n * https://code.germanov.dev/smart_shape/assets/distance.png\n * @param x0 X coordinate of point\n * @param y0 Y coordinate of point\n * @param x1 X coordinate of line start\n * @param y1 Y coordinate of line start\n * @param x2 X coordinate of line end\n * @param y2 Y coordinate of line end\n */\nexport const distanceFromLine = (x0,y0,x1,y1,x2,y2) => {\n    let t = (x0-x1)*(x2-x1)+(y0-y1)*(y2-y1);\n    const d = Math.pow(x2-x1,2) +Math.pow(y2-y1,2)\n    if (d === 0) {\n        return -1;\n    }\n    t /= d;\n    if (t<0) {\n        t = 0;\n    } else if (t>1) {\n        t = 1;\n    }\n    return Math.sqrt(Math.pow(x1-x0 + t*(x2-x1),2) + Math.pow(y1-y0+t*(y2-y1),2))\n}\n\n/**\n * @ignore\n * Function returns true is specified `point` lays inside or on the borders of specified `polygon`\n * @param polygon {array} Array of points of polygon [ [x,y] , [x,y] , [x,y] ... ]\n * @param point {array} Coordinates of point [x,y]\n * @returns {boolean} True if the point belongs to the polygon or false otherwise\n */\nexport const isPointInsidePolygon = (polygon,point) => {\n\n    const onSegment = (p,q,r) => {\n        return !!(q.x <= Math.max(p.x, r.x) &&\n            q.x >= Math.min(p.x, r.x) &&\n            q.y <= Math.max(p.y, r.y) &&\n            q.y >= Math.min(p.y, r.y));\n    }\n\n    const orientation = (p,q,r) => {\n        let val = (q[1] - p[1]) * (r[0] - q[0])\n            - (q[0] - p[0]) * (r[1] - q[1]);\n\n        if (val === 0) {\n            return 0;\n        }\n        return (val > 0) ? 1 : 2;\n    }\n\n    const doIntersect = (p1,q1,p2,q2) => {\n        let o1 = orientation(p1, q1, p2);\n        let o2 = orientation(p1, q1, q2);\n        let o3 = orientation(p2, q2, p1);\n        let o4 = orientation(p2, q2, q1);\n\n        if (o1 !== o2 && o3 !== o4) {\n            return true;\n        }\n\n        if (o1 === 0 && onSegment(p1, p2, q1))  {\n            return true;\n        }\n\n        if (o2 === 0 && onSegment(p1, q2, q1)) {\n            return true;\n        }\n\n        if (o3 === 0 && onSegment(p2, p1, q2))  {\n            return true;\n        }\n        return !!(o4 === 0 && onSegment(p2, q1, q2));\n    }\n    if (polygon.length < 3) {\n        return false;\n    }\n\n    let extreme = [10000,point[1]]\n\n    let count = 0, i = 0;\n    do {\n        let next = (i + 1) % polygon.length;\n        if (doIntersect(polygon[i], polygon[next], point, extreme)) {\n            if (orientation(polygon[i], point, polygon[next]) === 0) {\n                return onSegment(polygon[i], point,\n                    polygon[next]);\n            }\n            count++;\n        }\n        i = next;\n    } while (i !== 0);\n    return (count % 2 === 1)\n}\n\n/**\n * @ignore\n * Function used to calculate width or height respecting aspect ratio, calculated from `origWidth` and `origHeight`.\n * Either `width` or `height` must be null. Otherwise, just returns width and height\n * @param width {number|null} Destination width. If null, then calculates it\n * @param height {number|null} Destination height. If null, then calculates it\n * @param origWidth {number} Original width used to calculate aspect ratio\n * @param origHeight {number} Original height used to calculate aspect ration\n * @returns {array} Array in the form [width,height] after apply aspect ratio\n */\nexport const applyAspectRatio = (width,height,origWidth,origHeight) => {\n    if (!width && !height || !origWidth || !origHeight) {\n        return [origWidth, origHeight];\n    }\n    if (width && height) {\n        return [width,height]\n    }\n    if (!width) {\n        width = height * (origWidth/origHeight);\n    }\n    if (!height) {\n        height = width * (origHeight/origWidth);\n    }\n    return [width,height]\n}\n\n/**\n * @ignore\n * Returns true if two rectangles overlap each other\n * @param rect1 {object} First rectangle coordinates in format {left,top,right,bottom}\n * @param rect2 {object} Second rectangle coordinates in format {left,top,right,bottom}\n * @returns {boolean} True if rectangles overlap and false otherwise\n */\nexport const rectsOverlap = (rect1,rect2) => {\n    if (rect1.left === rect1.right || rect1.top === rect1.bottom || rect2.left === rect2.right || rect2.top === rect2.bottom)\n        return false;\n\n    if (rect1.left > rect2.right || rect2.left > rect1.left) {\n        return false;\n    }\n\n    return !(rect1.bottom > rect2.top || rect2.bottom > rect1.top);\n}\n\n/**\n * Method used to transform specified coordinates\n * using transformations, specified in `params` argument.\n * @param x {number} X coordinate\n * @param y {number} Y coordinate\n * @param type {PointMapTypes} This options specifies the transformation direction.\n * If it equals to `original_to_current` then need to apply specified transformations\n * to point, if  it equals `current_to_original`, the it assumed that all transformations\n * already applied to specified coordinates and need to un-apply them.\n * @param params Transformation parameters: `offsetX` - move by X, `offsetY` - move by Y,\n * `scaleX` - scale by X, `scaleY` - scale by Y, `flippedX` - flip by X, `flippedY` - flip by Y\n * @returns {array} New coordinates after transformation in [x,y] format\n */\nexport const mapPointCords = (x,y,type,params) => {\n    const scaleX = params.scaleFactorX || 1;\n    const scaleY = params.scaleFactorY || 1;\n    const offsetX = params.offsetX || 0;\n    const offsetY = params.offsetY || 0;\n    const flippedX = params.flippedX || false;\n    const flippedY = params.flippedY || false;\n    if (type === PointMapTypes.CURRENT_TO_ORIGINAL) {\n        [x,y] = flipPoint(x,y,flippedX,flippedY,params);\n        x -= offsetX;\n        y -= offsetY;\n        x *= (1/scaleX);\n        y *= (1/scaleY);\n    } else if (type === PointMapTypes.ORIGINAL_TO_CURRENT) {\n        x *= scaleX;\n        y *= scaleY;\n        x += offsetX;\n        y += offsetY;\n        [x,y] = flipPoint(x,y,flippedX,flippedY,params);\n    }\n    return [x,y];\n}\n\n/**\n * @ignore\n * Internal method to flip specified point over X or/and Y axis\n * according to specified dimensions of shape\n * @param x {number} X coordinate of point\n * @param y {number} Y coordinate of point\n * @param byX {boolean} Flip horizontally\n * @param byY {boolean} Flip vertically\n * @param pos {object} Shape dimensions, object with fields: `top`,`left`,`bottom`,`right`,`width`,`height`\n * @returns {array} New point coordinates in [x,y] format\n */\nexport const flipPoint = (x,y, byX, byY, pos) => {\n    if (byX) {\n        x = abs(pos.right - x) + pos.left\n    }\n    if (byY) {\n        y = abs(pos.bottom - y) + pos.top\n    }\n    return [x,y]\n}\n\n/**\n * @ignore\n * Function used to convert polar coordinates to\n * screen coordinates\n * @param lat {number} Latitude\n * @param lon {number} Longitude\n * @returns {array} X and Y coordinates as array [x,y]\n */\nexport const latLonToXY = (lat, lon) => {\n    const width = 1000000\n    const x = (width * (180 + lon) / 360) % (1.5 * width)\n    const rad = lat * Math.PI / 180\n    const merc = 0.5 * Math.log((1 + Math.sin(rad)) / (1 - Math.sin(rad)))\n    const y = (width * merc / (2 * Math.PI))\n    return [x,y]\n}\n\nexport const PointMapTypes = {\n    CURRENT_TO_ORIGINAL: \"current_to_original\",\n    ORIGINAL_TO_CURRENT: \"original_to_current\"\n}\n","// https://github.com/TehShrike/is-mergeable-object/blob/master/index.js\nfunction defaultIsMergeableObject(value) {\n    return isNonNullObject(value)\n        && !isSpecial(value)\n}\n\nfunction isNonNullObject(value) {\n    return !!value && typeof value === 'object'\n}\n\nfunction isSpecial(value) {\n    const stringValue = Object.prototype.toString.call(value)\n    return stringValue === '[object RegExp]'\n        || stringValue === '[object Date]'\n        || isReactElement(value)\n}\n\nconst canUseSymbol = typeof Symbol === 'function' && Symbol.for\nconst REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7\n\nfunction isReactElement(value) {\n    return value.$$typeof === REACT_ELEMENT_TYPE\n}\n\n// https://github.com/TehShrike/deepmerge/blob/master/index.js\nfunction emptyTarget(val) {\n    return Array.isArray(val) ? [] : {}\n}\n\nfunction cloneUnlessOtherwiseSpecified(value, options) {\n    return (options.clone !== false && options.isMergeableObject(value))\n        ? deepmerge(emptyTarget(value), value, options)\n        : value\n}\n\nfunction defaultArrayMerge(target, source, options) {\n    return target.concat(source).map(function(element) {\n        return cloneUnlessOtherwiseSpecified(element, options)\n    })\n}\n\nfunction getMergeFunction(key, options) {\n    if (!options.customMerge) {\n        return deepmerge\n    }\n    const customMerge = options.customMerge(key)\n    return typeof customMerge === 'function' ? customMerge : deepmerge\n}\n\nfunction getEnumerableOwnPropertySymbols(target) {\n    return Object.getOwnPropertySymbols\n        ? Object.getOwnPropertySymbols(target).filter(function(symbol) {\n            return target.propertyIsEnumerable(symbol)\n        })\n        : []\n}\n\nfunction getKeys(target) {\n    return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))\n}\n\nfunction propertyIsOnObject(object, property) {\n    try {\n        return property in object\n    } catch(_) {\n        return false\n    }\n}\n\n// Protects from prototype poisoning and unexpected merging up the prototype chain.\nfunction propertyIsUnsafe(target, key) {\n    return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n        && !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n            && Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.\n}\n\nfunction mergeObject(target, source, options) {\n    const destination = {}\n    if (options.isMergeableObject(target)) {\n        getKeys(target).forEach(function(key) {\n            destination[key] = cloneUnlessOtherwiseSpecified(target[key], options)\n        })\n    }\n    getKeys(source).forEach(function(key) {\n        if (propertyIsUnsafe(target, key)) {\n            return\n        }\n\n        if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\n            destination[key] = getMergeFunction(key, options)(target[key], source[key], options)\n        } else {\n            destination[key] = cloneUnlessOtherwiseSpecified(source[key], options)\n        }\n    })\n    return destination\n}\n\nexport const deepmerge = (target, source, options) => {\n    options = options || {}\n    options.arrayMerge = options.arrayMerge || defaultArrayMerge\n    options.isMergeableObject = options.isMergeableObject || defaultIsMergeableObject\n    // cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\n    // implementations can use it. The caller may not replace it.\n    options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified\n\n    const sourceIsArray = Array.isArray(source)\n    const targetIsArray = Array.isArray(target)\n    const sourceAndTargetTypesMatch = sourceIsArray === targetIsArray\n\n    if (!sourceAndTargetTypesMatch) {\n        return cloneUnlessOtherwiseSpecified(source, options)\n    } else if (sourceIsArray) {\n        return options.arrayMerge(target, source, options)\n    } else {\n        return mergeObject(target, source, options)\n    }\n}\n\ndeepmerge.all = function deepmergeAll(array, options) {\n    if (!Array.isArray(array)) {\n        throw new Error('first argument should be an array')\n    }\n\n    return array.reduce(function(prev, next) {\n        return deepmerge(prev, next, options)\n    }, {})\n}\n","import {getRotatedCoords, distance, degrees_to_radians, radians_to_degrees,isPointInsidePolygon,rectsOverlap} from \"./geometry.js\";\nimport {deepmerge} from \"./deepmerge.js\";\n\nexport const getOffset = ( elem,deep=true ) => {\n    let x = 0;\n    let y = 0;\n    if (!deep) {\n        return {top: elem.offsetTop - elem.scrollTop, left: elem.offsetLeft - elem.scrollLeft};\n    }\n    while( elem && !isNaN( elem.offsetLeft ) && !isNaN( elem.offsetTop ) ) {\n        x += elem.offsetLeft - elem.scrollLeft;\n        y += elem.offsetTop - elem.scrollTop;\n        elem = elem.offsetParent;\n    }\n    return { top: y, left: x };\n}\n\nexport const uuid = () => {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n        const r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);\n        return v.toString(16);\n    }).replace(/-/g,\"\");\n}\n\nexport const pauseEvent = (e) => {\n    try {\n        if (e.stopPropagation) e.stopPropagation();\n        if (e.preventDefault) e.preventDefault();\n        e.cancelBubble = true;\n        e.returnValue = false;\n    } catch (err) {}\n    return false;\n}\n\n\n\nexport const notNull = (value) => {\n    return typeof(value) !== \"undefined\" && value !== null;\n}\n\nexport const mergeObjects = (...objects) => {\n    if (!objects.length) {\n        return null;\n    }\n    let result = objects[0];\n    if (objects.length === 1) {\n        return result;\n    }\n    for (let index=1;index<objects.length;index++) {\n        if (notNull(objects[index]) && typeof(objects[index]) === \"object\") {\n            result = deepmerge(result, objects[index]);\n        }\n    }\n    return result;\n}\n\nexport const round = (number,precission) => {\n    return Math.round(number*precission)/precission;\n}\n\nexport const dataURLtoBlob = (dataURI) => {\n    const byteString = atob(dataURI.split(',')[1]);\n    const mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0]\n    const ab = new ArrayBuffer(byteString.length);\n    const ia = new Uint8Array(ab);\n    for (let i = 0; i < byteString.length; i++) {\n        ia[i] = byteString.charCodeAt(i);\n    }\n    return new Blob([ab], {type: mimeString});\n}\n\nexport const blobToDataURL = (blob) =>{\n    return new Promise(resolve => {\n        const reader = new FileReader();\n        reader.onload = function(e) {resolve(e.target.result);}\n        reader.readAsDataURL(blob);\n    })\n}\n\nexport const readJSON = (jsonString) => {\n    try {\n        return JSON.parse(jsonString);\n    } catch (err) {\n        return null;\n    }\n}\n\nexport const CSStoJsStyleName = (cssName) => {\n    let result = cssName;\n    let index = result.indexOf(\"-\");\n    while (index !== -1) {\n        result = result.replace(\"-\"+result[index+1],result[index+1].toString().toUpperCase())\n        index = result.indexOf(\"-\");\n    }\n    return result;\n\n}\n\nexport const recursiveDeepCopy = (o) => {\n    let newO, i;\n\n    if (typeof o !== 'object') {\n        return o;\n    }\n    if (!o) {\n        return o;\n    }\n\n    if ('[object Array]' === Object.prototype.toString.apply(o)) {\n        newO = [];\n        for (i = 0; i < o.length; i += 1) {\n            newO[i] = recursiveDeepCopy(o[i]);\n        }\n        return newO;\n    }\n\n    newO = {};\n    for (i in o) {\n        if (o.hasOwnProperty(i)) {\n            newO[i] = recursiveDeepCopy(o[i]);\n        }\n    }\n    return newO;\n}\n\nexport const abs = (value) => value < 0 ? -value : value;\n\nexport const timeout = (ms) => {\n    return new Promise(resolve => {\n        setTimeout(() => {\n            resolve()\n        },ms);\n    })\n}\nexport {radians_to_degrees,degrees_to_radians,getRotatedCoords,distance,isPointInsidePolygon,rectsOverlap};\n","/**\n * @ignore\n * Function used to create SmartShape event from raw Javascript DOM event.\n * @param origEvent {Event} Original DOM event to get as a base\n * @param params {object} Params to add to event\n */\nimport {getOffset} from \"../utils/index.js\";\n\nexport const createEvent = (origEvent,params={}) => {\n    const result = {};\n    for (let key in origEvent) {\n        if (key !== \"type\" && key !== \"target\") {\n            result[key] = origEvent[key];\n        }\n    }\n    Object.keys(params).forEach((key) => {\n        result[key] = params[key];\n    })\n    return result;\n}\n\n/**\n * @ignore\n * Method returns coordinates of mouse cursor from Mouse event\n * @param event {MouseEvent}\n * @param elem {HTMLElement}\n * @returns {array} Coordinates as an array [x,y]\n */\nexport const getMouseCursorPos = (event,elem=null) => {\n    if (!elem) {\n        elem = event.target.root || event.target;\n    }\n    return getMousePos(elem, event.pageX, event.pageY);\n}\n\nexport const getMousePos = (elem, x, y) => {\n    const offset = getOffset(elem,true);\n    return [x-offset.left,y-offset.top];\n}\n","/**\n * @ignore\n * Used as a singleton object to emit events and subscribe to these events.\n * One object can subscribe to events of specified type, other object can emit events of this type.\n * Each time when object emits event, all subscribed event handlers triggered.\n * @constructor\n */\nfunction EventsManager() {\n\n    /**\n     * Hashmap of all registered event subscriptions.\n     * Keys are event names as strings. Values are arrays of functions.\n     * Several handlers can subscribe to each event by providing function that should be triggered.\n     * this.subscriptions[event_name] = [handler_func,handler_func ...]\n     * @type {object}\n     */\n    this.subscriptions = {};\n\n    /**\n     * Add subscription to event of specified type or to array of events of specified types\n     * @param events {string|array} Name of event as a string or names of events as an array of strings.\n     * @param handler {function} Handling function, which will be called each time when event of this type emitted.\n     * Each time, when handling function triggered, it receives a single argument - `event` {object} which contains\n     * the following fields: `type` - type of event (`eventType`), `target` - pointer to object, which emitted\n     * this event, and also any custom params, that emitter sent with this event by using `emit` method.\n     * @returns {function} Pointer to handling function, that will be added\n     */\n    this.subscribe = (events,handler) => {\n        if (typeof(events) === \"string\") {\n            return this.subscribeToEvent(events,handler)\n        } else if (typeof(events) === \"object\") {\n            for (let event of events) {\n                this.subscribeToEvent(event,handler)\n            }\n            return handler;\n        }\n        return null;\n    }\n\n    /**\n     * @ignore\n     * Add subscription to event of specified type\n     * @param eventName {string|array} Name of event as a string or array of names of events to subscribe to\n     * @param handler {function} Handling function, which will be called each time when event of this type emitted.\n     * Each time, when handling function triggered, it receives a single argument - `event` {object} which contains\n     * the following fields: `type` - type of event (`eventType`), `target` - pointer to object, which emitted\n     * this event, and also any custom params, that emitter sent with this event by using `emit` method.\n     * @returns {function} Pointer to handling function, that will be added\n     */\n    this.subscribeToEvent = (eventName,handler) => {\n        if (typeof(this.subscriptions[eventName]) === \"undefined\" || !this.subscriptions[eventName]) {\n            this.subscriptions[eventName] = [];\n        }\n        if (typeof(this.subscriptions[eventName].find(h => h === handler)) !== \"undefined\") {\n            return null;\n        }\n        this.subscriptions[eventName].push(handler);\n        return handler;\n    }\n\n    /**\n     * Emits event of specified name. Based on specified arguments, it constructs `event` object, that contains\n     * the following fields: `type` - eventName, `target` - object that emitted this event and any other fields\n     * that received from `params` argument. Then, all subscribers will receive this `event` object to their handling\n     * functions.\n     * @param eventName {string} Name of event to emit.\n     * @param target {object} Which object emitted this event.\n     * @param params {object} Event specific params. Can be any number of params.\n     * @returns {boolean} True if this event triggered at least of one handler, or false if it does not.\n     */\n    this.emit = (eventName,target,params=null) => {\n        if (!params || typeof(params) !== \"object\") {\n            params = {}\n        }\n        params[\"type\"] = eventName;\n        params[\"target\"] = target;\n        if (typeof(this.subscriptions[eventName]) !== \"undefined\" && this.subscriptions[eventName] &&\n        this.subscriptions[eventName].length) {\n            for (let handler of this.subscriptions[eventName]) {\n                handler(params)\n            }\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Removes specified handler from event with specified name or from array of events with specified names.\n     * @param events {string|array} Name of event as a string or names of events as an array of strings.\n     * @param handler {function} Pointer to a function to remove. (This pointer returned from `subscribe` method and\n     * can be used here to unsubscribe\n     * @returns {boolean} True if really removed the handler or false if you could not remove because it does not exist\n     */\n    this.unsubscribe = (events, handler) => {\n        let result = false;\n        if (typeof(events) === \"string\") {\n            if (this.unsubscribeFromEvent(events,handler)) {\n                result = true;\n            }\n        } else if (typeof(events) === \"object\") {\n            for (let event of events) {\n                if (this.unsubscribeFromEvent(event,handler)) {\n                    result = true;\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @ignore\n     * Removes specified handler from event with specified name.\n     * @param eventName {string} Name of event as a string\n     * @param handler {function} Pointer to a function to remove. (This pointer returned from `subscribe` method and\n     * can be used here to unsubscribe\n     * @returns {boolean} True if really removed the handler or false if you could not remove because it does not exist\n     */\n    this.unsubscribeFromEvent = (eventName,handler) => {\n        if (typeof(this.subscriptions[eventName]) === \"undefined\" || !this.subscriptions[eventName]) {\n            return false\n        }\n        const index = this.subscriptions[eventName].indexOf(handler);\n        if (index !== -1) {\n            this.subscriptions[eventName].splice(index,1);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Method removes all subscriptions to events.\n     */\n    this.clear = () => {\n        this.subscriptions = {};\n    }\n}\n\nexport default new EventsManager();\n","/**\n * Extender class for `Menu` class, which extends it by methods\n * used to change styles of menu panel and menu items. All methods of\n * this class can be executed directly on `Menu` instance.\n * @param menu {Menu} Menu object to extend\n * @constructor\n */\nfunction MenuStylesHelper(menu) {\n    /**\n     * Menu object to extend\n     * @type {Menu}\n     */\n    this.menu = menu;\n\n    /**\n     * CSS class that used to style menu panel\n     * @type {string}\n     */\n    this.panelCssClass = \"\";\n\n    /**\n     * CSS class name or names that used to style menu items DIV elements\n     * @type {string}\n     */\n    this.itemCssClass = \"\";\n\n    /**\n     * CSS class name or names that used to style text of menu items\n     * @type {string}\n     */\n    this.itemTextCssClass = \"\";\n\n    /**\n     * CSS class name or names that used to style images of menu items\n     * @type {string}\n     */\n    this.itemImageCssClass = \"\";\n\n    /**\n     * CSS classes for concrete items by their IDs.\n     * @type {object}\n     */\n    this.itemsCssClassesById = {};\n\n    /**\n     * @ignore\n     * Method used to apply styles to menu panel and items\n     * either from provided CSS classes or using default styles\n     */\n    this.setStyles = () => {\n        if (!this.menu.panel) {\n            return\n        }\n        if (!this.panelCssClass) {\n            this.menu.panel.style.padding = \"3px\";\n            this.menu.panel.style.borderStyle = \"solid\";\n            this.menu.panel.style.borderColor = \"#dddddd\";\n            this.menu.panel.style.borderWidth = \"1px\";\n            this.menu.panel.style.backgroundColor = \"#eeeeee\";\n            this.menu.panel.className = \"\";\n        } else {\n            this.menu.panel.className = this.panelCssClass;\n        }\n        for (let item of this.menu.items) {\n            this.setItemStyles(item);\n        }\n    }\n\n    /**\n     * @ignore\n     * Method used to apply styles to menu items and their parts\n     * either from provided CSS classes or using default styles\n     * @param item {object} Menu item object\n     */\n    this.setItemStyles = (item) => {\n        this.setItemDivStyles(item);\n        this.setItemSpanStyles(item);\n        this.setItemImageStyles(item);\n    }\n\n    /**\n     * @ignore\n     * Method used to apply styles to menu items DIVs\n     * either from provided CSS classes or using default styles\n     * @param item {object} Menu item object\n     */\n    this.setItemDivStyles = (item) => {\n        const itemDiv = this.menu.panel.querySelector(\"#\"+item.id);\n        if (!itemDiv) {\n            return\n        }\n        itemDiv.style.display = 'flex';\n        itemDiv.style.flexDirection = 'row';\n        itemDiv.style.alignItems = 'center';\n        if (this.itemsCssClassesById[item.id] && typeof(this.itemsCssClassesById[item.id]) == \"object\" &&\n            this.itemsCssClassesById[item.id][ItemParts.ITEM]) {\n            itemDiv.className = this.itemsCssClassesById[item.id][ItemParts.ITEM]\n        } else if (this.itemCssClass) {\n            itemDiv.className = this.itemCssClass || \"\";\n        } else {\n            itemDiv.className = \"\";\n            itemDiv.style.paddingTop = \"2px\";\n            itemDiv.style.paddingLeft = \"3px\";\n            itemDiv.style.paddingRight = \"3px\";\n            itemDiv.addEventListener(\"mouseover\", () => {\n                itemDiv.style.backgroundColor = \"#0066CC\";\n                itemDiv.style.color = \"white\";\n            })\n            itemDiv.addEventListener(\"mouseout\", () => {\n                itemDiv.style.backgroundColor = \"transparent\";\n                itemDiv.style.color = \"black\";\n            })\n        }\n        itemDiv.style.whiteSpace = 'nowrap';\n    }\n\n    /**\n     * @ignore\n     * Method used to apply styles to text of menu items\n     * either from provided CSS classes or using default styles\n     * @param item {object} Menu item object\n     */\n    this.setItemSpanStyles = (item) => {\n        const itemDiv = this.menu.panel.querySelector(\"#\"+item.id);\n        if (!itemDiv) {\n            return\n        }\n        const span = itemDiv.querySelector(\"span\");\n        if (span) {\n            if (this.itemsCssClassesById[item.id] && typeof(this.itemsCssClassesById[item.id]) == \"object\" &&\n                this.itemsCssClassesById[item.id][ItemParts.TEXT]) {\n                span.className = this.itemsCssClassesById[item.id][ItemParts.TEXT]\n            } else if (this.itemTextCssClass) {\n                span.className = this.itemTextCssClass;\n            } else {\n                span.className = \"\";\n                span.style.color = \"black\";\n            }\n        }\n    }\n\n    /**\n     * @ignore\n     * Method used to apply styles to images of menu items\n     * either from provided CSS classes or using default styles\n     * @param item {object} Menu item object\n     */\n    this.setItemImageStyles = (item) => {\n        const itemDiv = this.menu.panel.querySelector(\"#\"+item.id);\n        if (!itemDiv) {\n            return\n        }\n        const img = itemDiv.querySelector(\"img\");\n        if (img) {\n            if (this.itemsCssClassesById[item.id] && typeof (this.itemsCssClassesById[item.id]) == \"object\" &&\n                this.itemsCssClassesById[item.id][ItemParts.IMAGE]) {\n                img.className = this.itemsCssClassesById[item.id][ItemParts.IMAGE];\n            } else if (this.itemImageCssClass) {\n                img.className = this.itemImageCssClass;\n            } else {\n                img.className = \"\";\n            }\n        }\n    }\n\n    /**\n     * Method used to override CSS class for menu panel\n     * @param className {string} CSS class to apply\n     */\n    this.setPanelClass = (className=null) => {\n        this.panelCssClass = className || \"\";\n    }\n\n    /**\n     * Method used to override CSS class for menu items\n     * or only for menu item with specified `id`\n     * @param className {string} CSS class to apply\n     * @param id {string} ID of item or null\n     */\n    this.setItemClass = (className=null,id=null) => {\n        if (id) {\n            this.setClassForItem(id,ItemParts.ITEM, className);\n            return\n        }\n        this.itemCssClass = className || \"\";\n    }\n\n    /**\n     * Method used to override CSS class for text of menu items\n     * or only for menu item with specified `id`\n     * @param className {string} CSS class to apply\n     * @param id {string} ID of item or null\n     */\n    this.setTextClass = (className=null,id=null) => {\n        if (id) {\n            this.setClassForItem(id,ItemParts.TEXT, className);\n            return\n        }\n        this.itemTextCssClass = className || \"\";\n    }\n\n    /**\n     * Method used to override CSS class for images of menu items\n     * or only for menu item with specified `id`\n     * @param className {string} CSS class to apply\n     * @param id {string} ID of item or null\n     */\n    this.setImageClass = (className=null,id=null) => {\n        if (id) {\n            this.setClassForItem(id,ItemParts.IMAGE,className);\n            return\n        }\n        this.itemImageCssClass = className || \"\";\n    }\n\n    /**\n     * @ignore\n     * Method that sets CSS classes for different parts of menu item with specified `id`\n     * @param id {string} ID of menu item\n     * @param classType {ItemParts} name of part to apply CSS class to: `item`, `text` or `image`\n     * @param className\n     */\n    this.setClassForItem = (id,classType,className) => {\n        if (!this.itemsCssClassesById[id] || typeof(this.itemsCssClassesById[id]) === \"undefined\") {\n            this.itemsCssClassesById[id] = {};\n        }\n        this.itemsCssClassesById[id][classType] = className;\n    }\n}\n\n/**\n * Enumeration of menu item parts using internally\n * to define CSS classes for different parts of menu item\n * @param div DIV element that contains menu item\n * @param text text inside menu item\n * @param image image inside menu item\n * @enum\n */\nconst ItemParts = {\n    ITEM: \"div\",\n    TEXT: \"text\",\n    IMAGE: \"image\"\n}\n\nexport default MenuStylesHelper;\n","/**\n * @ignore\n * Function used to create a custom event from raw Javascript DOM event.\n * @param origEvent {Event} Original DOM event to get as a base\n * @param params {object} Params to add to event\n */\nexport const createEvent = (origEvent,params={}) => {\n    const result = {};\n    for (let key in origEvent) {\n        if (key !== \"type\" && key !== \"target\") {\n            result[key] = origEvent[key];\n        }\n    }\n    Object.keys(params).forEach((key) => {\n        result[key] = params[key];\n    })\n    return result;\n}\n\nexport const blobToDataURL = (blob) =>{\n    return new Promise(resolve => {\n        const reader = new FileReader();\n        reader.onload = function(e) {resolve(e.target.result);}\n        reader.readAsDataURL(blob);\n    })\n}\n","import StylesHelper from \"./MenuStylesHelper.js\";\nimport EventsManager from \"./EventsManager.js\";\nimport {createEvent} from \"./functions.js\";\n\n/**\n * Context menu panel object.\n * @param items {array} Array of menu items. Each item is an object with a following fields:\n * `id` - unique ID of menu item.\n * `title` - Text of menu of item\n * `image` - URL of image, displayed on the left side of menu item (optional)\n * @param container {HTMLElement} HTML element to which this menu belongs\n * @param eventType {string} Name of event on HTML element that triggers the menu to appear\n * (by default `contextmenu`, triggers when user do right mouse click on element)\n * @constructor\n */\nfunction Menu(items,container,eventType=null, options={}) {\n    /**\n     * Menu panel element\n     * @type {HTMLDivElement}\n     */\n    this.panel = null;\n\n    /**\n     * Event on HTML element that triggers the menu to appear\n     * @type {HTMLElement}\n     */\n    this.container = container;\n\n    /**\n     * Array of menu items. Each item is an object with a following fields:\n     * `id` - unique ID of menu item.\n     * `title` - Text of menu of item\n     * `image` - URL of image, displayed on the left side of menu item (optional)\n     * @type {Array}\n     */\n    this.items = items;\n\n    /**\n     * Name of event on HTML element that triggers the menu to appear\n     * (by default `contextmenu`, triggers when user do right mouse click on element)\n     * @type {string}\n     */\n    this.event = eventType || \"contextmenu\";\n\n    /**\n     * Additional options for context menu\n     * @param customHandler {function} Custom function, that will be triggered on menu\n     * display instead of original one. Function receives two arguments: `menu` with link to menu\n     * and `event` with context menu Mouse Event object\n     */\n    this.options = options;\n\n    /**\n     * @ignore\n     * All registered listeners of mouse events on menu items HTML elements.\n     * keys of object are event types (like 'click', 'mouseover', 'mouseout')\n     * values of object are arrays of functions. Each function is one of event listeners,\n     * registered for this event\n     * @type {array}\n     */\n    this.listeners = {};\n\n    /**\n     * @ignore\n     * Original event object which triggered on `container` element when menu appeared\n     * @type {Event}\n     */\n    this.origEvent = null;\n\n    /**\n     * Mouse cursor X position in a moment when event to show menu triggered\n     * @type {number}\n     */\n    this.cursorX = 0;\n\n    /**\n     * Mouse cursor Y position in a moment when event to show menu triggered\n     * @type {number}\n     */\n    this.cursorY = 0;\n\n    /**\n     * @ignore\n     * Temporary value of body overflowY style before menu appeared.\n     * Used for internal reasons.\n     * @type {string}\n     */\n    this.overflowY = \"\";\n\n    /**\n     * @ignore\n     * The maximum height of all images of menu items. Used to\n     * calculate correct width for image of items\n     * @type {number}\n     */\n    this.maxImageHeight = 0;\n\n    /**\n     * @ignore\n     * List of subscribers, that subscribed to events, emitted by\n     * this menu. This is an object, that consists of array\n     * of event handlers of each event. Each handler is a function\n     * that called when event of specified type emitted by\n     * this shape\n     * @type {object}\n     */\n    this.subscriptions = {};\n\n    /**\n     * Method constructs and initializes menu, based on\n     * settings, provided in constructor\n     * @returns {Menu} this menu object\n     */\n    this.init = () => {\n        Object.assign(this,new StylesHelper(this));\n        this.listener = (event) => {\n            this.onEvent(event);\n            return false;\n        };\n        this.container.addEventListener(this.event, this.listener);\n        EventsManager.emit(MenuEvents.CREATE,this,{owner:this});\n        return this;\n    }\n\n    /**\n     * @ignore\n     * Method executed when event that should show menu triggers on `container` element\n     * @param event {Event} Event object\n     */\n    this.onEvent = (event) => {\n        if (this.options.customHandler && typeof(this.options.customHandler === \"function\")) {\n            this.options.customHandler(this,event);\n            return\n        }\n        this.origEvent = event;\n        event.preventDefault();\n        event.stopPropagation();\n        event.cancelBubble = true;\n        this.cursorX = event.pageX;\n        this.cursorY = event.pageY;\n        this.show();\n    }\n\n    /**\n     * @ignore\n     * Method used to construct menu HTML element with it items\n     */\n    this.drawMenu = () => {\n        try {\n            document.body.removeChild(this.panel);\n        } catch (err) {}\n        this.panel = document.createElement(\"div\");\n        document.body.appendChild(this.panel);\n        for (let item of this.items) {\n            if (this.panel.querySelector(\"#\"+item.id)) {\n                continue;\n            }\n            const div = document.createElement(\"div\");\n            div.id = item.id;\n            div.style.cursor = 'pointer';\n            const span = document.createElement(\"span\");\n            span.innerHTML = item.title;\n            div.appendChild(span);\n            this.panel.appendChild(div);\n        }\n        this.setStyles();\n        this.drawImages();\n        this.setStyles();\n        this.setItemsEventListeners();\n        this.panel.style.display = 'none'\n    }\n\n    /**\n     * @ignore\n     * Method used to inject images to menu items\n     * while constructing them\n     */\n    this.drawImages = () => {\n        if (!this.panel) {\n            return\n        }\n        const imgItems = this.items.filter(item => item.image && typeof(item.image)!== \"undefined\");\n        this.maxImageHeight = 0;\n        for (let item of imgItems) {\n            const img = new Image();\n            if (!this.panel) {\n                continue;\n            }\n            const span = this.panel.querySelector(\"#\"+item.id+\" > span\");\n            img.style.display = 'none';\n            img.src = item.image;\n            if (!this.panel) {\n                return\n            }\n            const div = document.createElement(\"div\");\n            div.style.marginRight = '5px';\n            div.style.display = 'flex';\n            div.style.flexDirection = 'row';\n            div.style.justifyContent = 'center';\n            div.style.alignItems = 'center';\n            img.height = this.panel.querySelector(\"#\" + item.id).clientHeight;\n            if (img.height > this.maxImageHeight) {\n                this.maxImageHeight = img.height;\n            }\n            img.style.verticalAlign = \"middle\";\n            img.style.display = '';\n            div.appendChild(img)\n            if (!this.panel.querySelector(\"#\"+item.id+\" div\")) {\n                this.panel.querySelector(\"#\" + item.id).insertBefore(div, span);\n            }\n        }\n        this.adjustImagesWidth();\n    }\n\n    /**\n     * @ignore\n     * Method used to set up event listening functions for all menu items.\n     * It forwards these events to all `subscribers`, connected to the menu object\n     */\n    this.setItemsEventListeners = () => {\n        for (let name of [\"click\",\"mouseover\",\"mouseout\",\"dblclick\",\"mousedown\",\"mouseup\",\"mousemove\"]) {\n            this.setListenersForMouseEvent(name)\n        }\n    }\n\n    /**\n     * Set event listeners for all menu items for specified mouse event\n     * @param eventName {string} Mouse event name (click,mousedown,mouseup ...)\n     */\n    this.setListenersForMouseEvent = (eventName) => {\n        for (let item of this.items) {\n            this.setListenerForItem(eventName,item)\n        }\n    }\n\n    /**\n     * Set mouse event listener for specified event for specified menu item\n     * @param eventName {string} Mouse event name (click,mousedown,mouseup ...)\n     * @param item {object} Menu item object\n     */\n    this.setListenerForItem = (eventName, item) => {\n        const listener = (event) => {\n            if (!this.origEvent) {\n                return\n            }\n            EventsManager.emit(eventName, this.origEvent.target, createEvent(event, {\n                container: this.container, owner:this, cursorX: this.cursorX, cursorY: this.cursorY, itemId: item.id\n            }))\n            setTimeout(() => {\n                if ([\"click\", \"mousedown\", \"mouseup\", \"dblclick\"].indexOf(eventName) !== -1) {\n                    if (event.button !== 2) {\n                        this.hide();\n                    }\n                }\n            }, 100)\n        }\n        this.listeners[eventName+\"_\"+item.id] = listener;\n        this.panel.querySelector(\"#\"+item.id).addEventListener(eventName, listener)\n    }\n\n    /**\n     * @ignore\n     * Internal method that used to adjust image size to match size of menu item text\n     * and correct width to respect aspect ratio and align all items correctly\n     */\n    this.adjustImagesWidth = () => {\n        if (!this.panel) {\n            return\n        }\n        let maxSize = 0;\n        for (let item of this.items) {\n            if (this.panel.querySelector(\"#\"+item.id).clientHeight > maxSize) {\n                maxSize = this.panel.querySelector(\"#\"+item.id).clientHeight;\n            }\n        }\n        for (let img of this.panel.querySelectorAll(\"img\")) {\n            img.parentNode.style.width = maxSize+\"px\";\n            img.parentNode.style.height = maxSize+\"px\";\n        }\n\n    }\n\n    /**\n     * Method shows menu\n     */\n    this.show = () => {\n        if (!this.container) {\n            return\n        }\n        EventsManager.emit(MenuEvents.SHOW,this,{owner:this});\n        this.drawMenu();\n        if (!this.panel) {\n            return\n        }\n        this.panel.style.display = '';\n        let left = this.cursorX;\n        let top = this.cursorY;\n        this.panel.style.left = left +\"px\";\n        this.panel.style.top = top+\"px\";\n        this.panel.style.zIndex = \"10000\";\n        this.panel.style.position = 'absolute';\n        if (left+this.panel.clientWidth > window.innerWidth) {\n            left = window.innerWidth - this.panel.clientWidth - 10;\n            this.panel.style.left = left +\"px\";\n        }\n        if (this.origEvent && this.origEvent.clientY+this.panel.clientHeight > window.innerHeight) {\n            top = top - (window.innerHeight + this.panel.clientHeight-20) + this.origEvent.clientY;\n            this.panel.style.top = top +\"px\";\n        }\n    }\n\n    /**\n     * Method hides menu\n     */\n    this.hide = () => {\n        if (this.panel) {\n            this.panel.style.display = 'none';\n        }\n    }\n\n    /**\n     * Method used to dynamically add item to menu\n     * @param id {string} Unique ID of item\n     * @param title {string} Text of menu item\n     * @param image {string} URL of menu item image (optional)\n     */\n    this.addItem = (id,title,image=null) => {\n        const item = {id,title};\n        if (image) {\n            item.image = image;\n        }\n        this.items.push(item);\n    }\n\n    /**\n     * Method used to remove menu item\n     * @param id {string} ID of item to remove\n     */\n    this.removeItem = (id) => {\n        const index = this.items.findIndex(item => item.id === id)\n        if (index !== -1) {\n            this.items.splice(index, 1);\n        }\n    }\n\n    /**\n     * Method used to return HTML node of menu item by ID\n     * @param id {string} ID of menu item\n     * @returns {HTMLDivElement} DIV html element of menu item\n     */\n    this.findItemById = (id) => Array.from(this.panel.querySelectorAll(\"div\")).find(item => item.id === id);\n\n    /**\n     * Method used to set unique ID of this menu panel.\n     * @param id {string} ID to set\n     */\n    this.setId = (id) => this.panel.id = id;\n\n    /**\n     * @ignore\n     * Uniform method that used to add event handler of specified type to this object.\n     * @param eventName {string} Name of event\n     * @param handler {function} Function that used as an event handler\n     * @returns {function} Pointer to added event handler. Should be used to remove event listener later.\n     */\n    this.addEventListener = (eventName,handler) => {\n        if (typeof(this.subscriptions[eventName]) === \"undefined\") {\n            this.subscriptions[eventName] = [];\n        }\n        const listener = EventsManager.subscribe(eventName, (event) => {\n            if (event.owner === this) {\n                handler(event)\n            }\n        });\n        this.subscriptions[eventName].push(listener);\n        return listener;\n    }\n\n    /**\n     * @ignore\n     * Uniform method that used to remove event handler, that previously added\n     * to this object.\n     * @param eventName {string} Name of event to remove listener from\n     * @param listener {function} Pointer to event listener, that added previously.\n     * It was returned from [addEventListener](#ResizeBox+addEventListener) method.\n     */\n    this.removeEventListener = (eventName,listener) => {\n        if (this.subscriptions[eventName] && typeof(this.subscriptions[eventName]) !== \"undefined\") {\n            this.subscriptions[eventName].splice(this.subscriptions[eventName].indexOf(listener), 1);\n        }\n        EventsManager.unsubscribe(eventName,listener)\n    }\n\n    /**\n     * Method used to subscribe to menu item event.\n     * @param eventName {string} Name of event to subscribe (click, mouseover, mouseout or other)\n     * @param handler {function} Handler function that will execute on event. Function receives `event` argument\n     * which is a standard MouseEvent with all properties and in addition, contains the following important fields:\n     * `itemId` - ID of menu item that triggered this event, `cursorX` - X position of mouse cursor on container in a\n     * moment the menu appeared, `cursorY` - Y position of mouse cursor on container in a moment the menu appeared.\n     * @returns {function} Returns a created listener object which can be used later to unsubscribe from this event\n     */\n    this.on = (eventName,handler) => {\n        return this.addEventListener(eventName, handler)\n    }\n\n    /**\n     * Method used to unsubscribe from menu item event\n     * @param eventName {string} name of event to unsubscribe, (click, mouseover, mouseout or other)\n     * @param handler {function} event handler to remove from subscriptions, that previously returned by `on` function\n     */\n    this.off = (eventName,handler) => {\n        this.removeEventListener(eventName, handler);\n    }\n\n    /**\n     * Method used to unsubscribe from all events, previously subscribed using `on` or `addEventListener`\n     * methods\n     */\n    this.removeAllEventListeners = () => {\n        for (let eventName in this.subscriptions) {\n            for (let handler of this.subscriptions[eventName]) {\n                EventsManager.unsubscribe(eventName,handler);\n            }\n        }\n        if (this.container) {\n            this.container.removeEventListener(this.event, this.listener);\n        }\n        this.subscriptions = {};\n        if (!this.panel) {\n            return\n        }\n        for (let listener in this.listeners) {\n            const [name,id] = listener.split(\"_\");\n            const div = this.panel.querySelector(\"#\"+id);\n            if (div) {\n                div.removeEventListener(name, this.listeners[listener]);\n            }\n        }\n    }\n\n    /**\n     * Method used to destroy menu: removes all subscriptions\n     * and menu panel element from DOM.\n     */\n    this.destroy = () => {\n        this.removeAllEventListeners();\n        this.items = [];\n        this.container = null;\n        try {\n            document.body.removeChild(this.panel);\n        } catch (err) {}\n        if (this.panel) {\n            this.panel.innerHTML = \"\";\n        }\n        this.panel = null;\n        EventsManager.emit(MenuEvents.DESTROY,this,{owner:this});\n    }\n}\n\n/**\n * Enumeration of menu events\n * @enum\n */\nexport const MenuEvents = {\n    CREATE: \"create\",\n    DESTROY: \"destroy\",\n    SHOW: \"show\"\n}\n\nexport default Menu;\n","import EventsManager from \"./EventsManager.js\";\nimport Menu, {MenuEvents} from \"./Menu.js\";\n\n/**\n * Factory class for menus. Used to construct new context menus.\n * @constructor\n */\nfunction Menus() {\n\n    /**\n     * Collection of all created menus\n     * @type {array}\n     */\n    this.menus = [];\n\n    /**\n     * Method used to create new context menu\n     * @param items {array} Items to include to menu. Each item is an object with fields:\n     * `id` - ID of menu item, `title` - text of menu item, `image` - URL of image of menu item (optional)\n     * @param container {HTMLElement} HTML element to which this menu belongs\n     * @param eventName {string} Name of event which should be triggered on `container` to display this menu. By\n     * default `contextmenu`, so, menu will appear when right mouse click on it. Could be any other mouse event\n     * like `click`, `mouseover`, `mousedown` or others.\n     * @returns {Menu} Constructed [Menu](#Menu) object.\n     */\n    this.create = (items,container,eventName=\"contextmenu\",options={}) => {\n        return new Menu(items,container,eventName,options).init();\n    }\n\n    EventsManager.subscribe(MenuEvents.CREATE, (event) => {\n        if (this.menus.indexOf(event.target) === -1) {\n            this.menus.push(event.target);\n            event.target.id = this.menus.length;\n        }\n    })\n\n    EventsManager.subscribe(MenuEvents.DESTROY, (event) => {\n        if (this.menus.indexOf(event.target) !== -1) {\n            this.menus.splice(this.menus.indexOf(event.target),1);\n        }\n    })\n\n    EventsManager.subscribe(MenuEvents.SHOW, (event) => {\n        this.menus.forEach(menu => {\n            if (menu !== event.target) {\n                menu.hide()\n            }\n        })\n    })\n\n    document.addEventListener(\"mouseup\", (event) => {\n        if (event.button!==2) {\n            this.menus.forEach(menu => menu.hide())\n        }\n    })\n}\n\nexport default new Menus();\n","import Menus from \"./Menus.js\";\ntry {\n    window.Menus = Menus;\n} catch {}\n\nexport {Menus};\n","export const rotate_tl = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA0AAAANCAYAAABy6+R8AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAB3RJTUUH5gkIECcZZuWhdAAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAABaSURBVCjPlZBBEsAgCAMT/v/n7akzWAFtTo5mQ8SAJtkGcL4LXcg211A2L+eq3jc5C/AGTUBZ7wYAHH+B4yIAv8a8dkvilLz9qXuYKseU2E7qDFODqIwTIEkPSldAAa0WlbUAAAAASUVORK5CYII=\";\nexport const rotate_tr = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA0AAAANCAYAAABy6+R8AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAB3RJTUUH5gkIECgYlnqNLQAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAABZSURBVCjPlZFBCgAxCANN/v/n2VOhiFU3N4U4GgXELUkAikbOhlhIh1QZXkR3hGc/IsaVMtHT0RXR3e5jescIqBpy05T/tInffw2AvEkr972N+a69+U8e8AGOtEABr4X+4AAAAABJRU5ErkJggg==\";\nexport const rotate_br= \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA0AAAANCAYAAABy6+R8AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAB3RJTUUH5gkIECkWaNmRawAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAABjSURBVCjPlZBRDsAgCENbsnt6/1N0P2ocijASEy08iqC1BknhASCvsSeOQXImJXHcrQL4t1UAr4fjReDmdCsc/5LEZ7NOwOlUKVy3RwC/AAAwL2TAZ3t+xFszOxVl7lbtvsYLOtlZCOj2NccAAAAASUVORK5CYII=\";\nexport const rotate_bl = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA0AAAANCAYAAABy6+R8AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAB3RJTUUH5gkIECoXNPPyPgAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAABaSURBVCjPlVFBEgAhCAL+/2f21I5jqcXFGRMSpG1EkLRtooEyIdaRlAc7orqBsg+gVKy8yTYn49vqMb0pgCUuPOBP93Sniaxb8/FdL6mt/rZe5SMKXQWRf/4AYrs6C0ViuwUAAAAASUVORK5CYII=\";\nexport const resize_cb = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA0AAAANCAYAAABy6+R8AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAB3RJTUUH5gkIEDsHep3BSgAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAAA8SURBVCjPY2DADf7jkmAkQgMjMZr+EzKckVgnIatlJFIDinqynMfEQAYgSxNV/ERy6JEdT0SlCAZy0h4AXLILDAEWNOwAAAAASUVORK5CYII=\";\nexport const resize_ct = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA0AAAANCAYAAABy6+R8AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAB3RJTUUH5gkIEDMMJZaSygAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAAA/SURBVCjPY2DADf7jkmAkQgMjMZr+EzKckVgnIatlJFIDinqynMfEQAYgSxNV/ERy6JEdT0SlCJxAWZoFp1MBY8cLTv/x72kAAAAASUVORK5CYII=\";\nexport const resize_lb = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA0AAAANCAYAAABy6+R8AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAB3RJTUUH5gkIEQARsznxFAAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAABBSURBVCjPtZAxDgAgCAOvxP9/GTfjolISOxIK7UFDOszz5gnzGADRiReNeMuUVQPAcJbdTtrhqILY/aTvyG04T00vswcW6BsN2AAAAABJRU5ErkJggg==\";\nexport const resize_lc = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA0AAAANCAYAAABy6+R8AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAB3RJTUUH5gkIEQEbSvcpSwAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAAA3SURBVCjPY2AYSPCfAJ+BiZACbOKMRGjAUM9Igga4RkYSNTCICjCTbxPJfsIWSv+JECM9nugHAG40DyW1OoLPAAAAAElFTkSuQmCC\";\nexport const resize_lt = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA0AAAANCAYAAABy6+R8AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAB3RJTUUH5gkIEDIpd4l3zAAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAAA+SURBVCjPY2AgAzBC6f9EqIEDJiINJUkTAzma/pNr0390NguRLvqPyyZGXB4nKnQIRQETiYZRP8j/M1AbAADcMAcWozKAnAAAAABJRU5ErkJggg==\";\nexport const resize_rb = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA0AAAANCAYAAABy6+R8AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAB3RJTUUH5gkIEDYr/evT5AAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAAA+SURBVCjPY2AgAzBC6f9EqIEDJiINJUkTAzma/pNr0390NguRLvqPyyZGXB4nKnQIRQETiYZRP8j/M1AbAADcMAcWozKAnAAAAABJRU5ErkJggg==\";\nexport const resize_rc = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA0AAAANCAYAAABy6+R8AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAB3RJTUUH5gkIEDUsSKIVhAAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAAA0SURBVCjPY2AYSPCfAJ+BiZACbOKMRGjAUM9Igga4RkYSNTBQZBPJfsIWSv+JECM9nugHADv6Dv2P6G4ZAAAAAElFTkSuQmCC\";\nexport const resize_rt = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA0AAAANCAYAAABy6+R8AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAB3RJTUUH5gkIEDQQftZYQgAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAABBSURBVCjPtZAxDgAgCAOvxP9/GTfjolISOxIK7UFDOszz5gnzGADRiReNeMuUVQPAcJbdTtrhqILY/aTvyG04T00vswcW6BsN2AAAAABJRU5ErkJggg==\";\nexport const add = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAQAAABKfvVzAAAAAmJLR0QA/vCI/CkAAAAJcEhZcwAADdYAAA3WAZBveZwAAAAJdnBBZwAAABgAAAAYAHhMpaYAAAEDSURBVDjLzZPNSsQwEIC/CUWtQlnZi14EYb36Jj6DT+ZT+BSevImHPYggKLpo2bW1Ze14yJjFtKEed3poMpmvzZcf2LqQfkolZFV0FFDhkMI6JR99JAbczTlP/tGZung86yN7Spn+4ABw0PH5DyCoOoSvYOg00s9C+YSpL8oLGgMmnOILF2r68qvKibvWXd9hbsCZ/ajpLniULnKQO82tubb3vY3Uw9IrvhOmCaDFJYC2DyjLt1vNQGjzI5v7+1wrBWTN0uQ3R0OFfQRwz7PjS8td8UAHKFW0rCDqt0ud1mEfKlZ+bYYdNtGQjAFgh6L+M9sRQKev5Yu1F4zfh7ELtIXxA+JiW9aVMPJ4AAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDE3LTExLTIwVDEwOjE1OjExLTAwOjAwfzVXkwAAACV0RVh0ZGF0ZTptb2RpZnkAMjAxNy0xMS0yMFQxMDoxNToxMS0wMDowMA5o7y8AAAAZdEVYdFNvZnR3YXJlAHd3dy5pbmtzY2FwZS5vcmeb7jwaAAAAAElFTkSuQmCC\";\nexport const del = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABmJLR0QA/gD+AP7rGNSCAAAACXBIWXMAAA3WAAAN1gGQb3mcAAAACXZwQWcAAAAYAAAAGAB4TKWmAAACn0lEQVRIx+2U30tTYRzGn/fsPdOmNkWDsEDnOiFCbv4KhPJCFAvDtBuRyL/A64TwQkGaCt7pVYqimHhTJAVhuYsRE5zipLuZeQKNsMQdN1vbzvbtwg2Oa5s/uvWBl3Px8P18OO/7ngNc5H9DROw8XTxCumEiygJwjYh4kp7HuqzTiJLBc8aslr5+vbiy43SWaiVExHecztJ+vbgyZrX0EVHOqSVx+ERFee8wR3hcBNky+VpcEofbMvnauAga5ghPVJT3ppKwJIKsqRrr0/3P68+KdeAMgBIFfgjc/cT+6TEATNffmbkaVa1GASAAcgRq3i3L806Xe4gxdqjl8QS4ACBPDPibpIwjOAAUAOBR1fqy8e4MAFwXVGuuZlLi4ErA3wTgBREFGGPRdG+gCytKy3JDTdfvrxv12s4bOXrm6o7PGEok++2PrhHRaJxnjEXSblFMog/7lea1xn8liTGUSPaKD64RMdv4jjEWOvEMtJKIX2lev1fTFdhKLrlkkuyW964RXQo4kOY7ABBVNj0e+eDwMudAsiUfHF5WNj0eANFUkFRbxPdWl268elA3Wyyq1nwx+fBeGJDD3P3oraMjv6r2C2NMPVFARLq91SXpTUvdrEmvWgv0SJtfIWArxN0P5x0d+VW1G2kPOXZNC6dMma+LebD6SgI8o+imHQCC3zzHzuRnCJDVjJXOrT9tAL5rr+mxM4gV+w3dPY7CbCEkciC+DGbJXjS3PFo0tzxqMEt2bVeYLYQaunscAPa18KSJ/SrMyuSgTa4WgnIlaLtVWlR93jYi0hORXvV527ZbpUW5EiRXC0FlctBGROaz/o/Mvumhgd32soU4XNPrVZ+3bbe9bME3PTRwJniCxERE97VwrSTWmc4MTxSdp7vIqfMXBoR6XMSZc1QAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTctMTEtMjBUMTA6MTU6MTEtMDA6MDB/NVeTAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE3LTExLTIwVDEwOjE1OjExLTAwOjAwDmjvLwAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAASUVORK5CYII=\";\nexport const save = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAQAAABKfvVzAAAAAmJLR0QA/vCI/CkAAAAJcEhZcwAADdYAAA3WAZBveZwAAAAJdnBBZwAAABgAAAAYAHhMpaYAAAG6SURBVDjLlZK/TxNhGMc/z117FgWbNulITGMYTMvAaHAyhMTAIoOmcdD/wMWERdO4E8If4OJASBgcGcA4QRgx4YcLA4aUYDTRCoX2fj0OvTu441rwuem+7/N5n/f7PA/8ZwholiHuYCCXdMWnxYk4KYwWSws0+JX4GqUFLaqRVmHYWFUfTZ6I4U9ynKyRAUztoNsfq6f4gWrsDI6+VMGMPTMCwIHqGt+xA9Wq3uNFuukIoIUtduiYFs51QDIcwMSKrHn4otcBebJ4QfofmnghYKcANlCQxaj505xcAL0qGM1lFEXwwsH2B/zi0/DXXbps2k0YtDBxAbxvPbtUL7/Xi8HVy90ntXdwVUUgHKGADufedrJUsGKWd2857aXMXLAy4j7nUOxuhdabvfmR86/x0gPO7AFn3lYkCJaqON31HqVCNpZvMkCDA3kVtfUD5/yVYwFQ48qaZShO1VeqbEbKwyfbK+/kx5VtDO4TLO/Rs7FPpVCZ+bm8Za5LpwcAKuTajycebBQAxn9/3st9oSPaEwAVbjcnx+/vDlZON/bza5yJ0j9UNH9Um3h9VNO7/a6OIwWd0sIN09PiH5BSrD/OwMFRAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDE3LTExLTIwVDEwOjE1OjExLTAwOjAwfzVXkwAAACV0RVh0ZGF0ZTptb2RpZnkAMjAxNy0xMS0yMFQxMDoxNToxMS0wMDowMA5o7y8AAAAZdEVYdFNvZnR3YXJlAHd3dy5pbmtzY2FwZS5vcmeb7jwaAAAAAElFTkSuQmCC\";\nexport const svg = \"data:image/png;base64,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\";\nexport const png = \"data:image/png;base64,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\";\nexport const json = \"\";\nexport const copy = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAQAAABKfvVzAAAAAmJLR0QA/vCI/CkAAAAJcEhZcwAADdYAAA3WAZBveZwAAAAJdnBBZwAAABgAAAAYAHhMpaYAAAFdSURBVDjLzZO/TsJQFMZ/t1QsmthEjQkmLoZJA7ODq/EdHBx9BcTEmMjCxsA7+Ao+gFOdCImOuoAs/qtIldL2OECxLY1EJ88Zbu6933e+c/988MtQ8akotOQaQqAklSAaS5hkEgQfmzcVTImJEjPfoMNjIjv5hpiiEgqiyJLXLiVAEpWU0oJ9HpQHoEeaWWFZPpGbiy17QlK35vaBqBAXaWajzp3sYWFJUQzRx2lIEQtLNmVMGQ0ZzPYuXQQX6OON5EGgjxstHkrp8k4A8c1xpBJgAMAwhTBMJ7jT1X5WGP5nBQ1dvve1mQq1wjGEX02rFX5S8HPOh16pVOYjiAHNnIeXTuidtc/XnOv4ERa8ky42fkpL9dXyfTnLXAzf54UmvdBCCkB01hcPHZ0djHh15QVHdHBV5BYAfOzq06npXMXhhl995TkKnxhINEqUyE49WYtW3JxRx82w/x/jC67KmykWiVPXAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDE3LTExLTIwVDEwOjE1OjExLTAwOjAwfzVXkwAAACV0RVh0ZGF0ZTptb2RpZnkAMjAxNy0xMS0yMFQxMDoxNToxMS0wMDowMA5o7y8AAAAZdEVYdFNvZnR3YXJlAHd3dy5pbmtzY2FwZS5vcmeb7jwaAAAAAElFTkSuQmCC\";\nexport const group = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABmJLR0QA/gD+AP7rGNSCAAAACXBIWXMAAA3WAAAN1gGQb3mcAAAACXZwQWcAAAAYAAAAGAB4TKWmAAACQElEQVRIx9WUz2sTURDHPzMvIb3VgyJKW/DXSXoKtSJIbaxtgi3of+BfIYKXgOAfUCh6zFFR9Ca1tomXigf7P/SQqo2giIrNpvvGw+7GStIlG/HgLI8dHvPmOzPvw4P/3SRx1hurde/9bL8g7z1mhveGWeQj0liq3CgNrLS28cKy2JNnj2yQvLnE6XQ6AHz/8Q3vPd6HhMk/3CcMw2j5fU5NnCMI2gMV3hUIggCAdrDHy9U1zDzeopF4b5g3jJCZKzN/xA8h0Ga2NAMIZoYRz91b3JmP4ttZBeIDPgzZWK8DgghEgzbMADNKc6W/6yD0nqtzJUQEVY2FonXQ2lkFkgNOlXq9gYoiqqgIiCJETM+XF7oFrTxYtjNnT6ci3NOBc45yuYxTh3MOVYeqxt0QJYjjp6cuUSwWe6p++vzxbE8HiYCosv5qI0rqFKeOxeuLqHOICHbgkr98/czH1k4qwj2XLMD8wjWcy5FzDudyICDxZ/FdBEHAm81Nms1mKsI9HRw/djL10hyuGz81fYHJyfOpCHcFDNu8c/f2RUveHTMS38xcNPookXlPYWSErXdbtHZ3UxHuCtyr3r9crd4qbCcb27+rHp848XNp8SYfdndQVUSEkUKBsbFxRo+MpiKcO7Bv1Wptr99YVh4uUywWab4/SqPxGhVFnaPV+nQowv0EDrVOp4Oqks/nqVQqAyGcSWAYhLMJDIHwUB1kQTiTQBrC0RtkRAhH+7l87m1yVgYRAOQwhPtZrVZrk7z0/9p+AWdQwNFPdOB+AAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDA5LTEyLTAxVDAyOjIyOjM1KzAxOjAwqBTIawAAACV0RVh0ZGF0ZTptb2RpZnkAMjAwOS0xMi0wMVQwMjoyMjozNSswMTowMNlJcNcAAAAZdEVYdFNvZnR3YXJlAHd3dy5pbmtzY2FwZS5vcmeb7jwaAAAAE3RFWHRUaXRsZQBPcHRpY2FsIERyaXZlPme6DAAAAABJRU5ErkJggg==\";\nexport const ungroup = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3WAAAN1gGQb3mcAAAAB3RJTUUH5goLBzIP6fiS+gAAAoFJREFUSMfVVk1rE2EQft55EyKeFU0PlcR6koIa+0FBa2NtEmyL9uLBIoHi0YvFogghIIjoTbx4MldB8BRUTJNeqh7MwT+gPaSpKdjak2bTnfGw3SVhP5p4EFxYmJf5eGbmfXZmgf/9UbZQqrwtM/OElxEzQ0TALBCxZChVmclcSe4HEGoLMjEwv+AoYvV6oOOr1y87kvkajYotxzc2lAug1Wp1BPi5swWTGcwmTHMXpmlaL+8i1n8ChtHsqkUOgGEYHYpisQgWqyXMAmGBwMT4hXFP+64AYvU66o0aFICx08OOUbj6EcICZgYzW/ZNw7ct3gBNKyM2TSyXyjjfZrRcKkMEgAiSk8m/rwAATGZcnEyi/UZSqRSU6kyw2SuA7aCJUC5XQE8eQRGBlMLoqbMdTt8AzAF4k7uH4wNxiAiKLOJFYVcFWmuk02lo0tBag0jjx+07ntmNDI0hkUgEUtgFoIhQer8MIgJpgiaNMz7lb+9s4fvmeiCFXZesAEylLkHrEEJaQ+sQGj4AH1ZXUavVAinsquDI4b6u58zQyDAGB096UtgFIJDVu/eXRsWeOyKw5VuA9gKofq5is9EIpLAD8CD/8Fw+n42s7Z1zz9/9snUvbmYxM30VG411EBGUUjgQieD6fNYJdPBL1ZPCobaEJJ8v/LYPuWjUURztiyKRSKBWP4RKZQWkCKQ14m3OK+UVTKVT/hUEPa1WC0SEcDiMTCbjUHh7ccmxmZmdtb6BIAC/2fLYMMSTws+eYvryNEhr1PqPOXGMhRu9VRBEYShAoXOM9NyiXinsC+A3coMobK1RAa7N7e0NRkipT66dvN/ubqcw1oKNC4VCE4D8k7+KP78ve+ZyfaadAAAAAElFTkSuQmCC\";\nexport const move_to_top = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAB3RJTUUH5godFRotCxUC6QAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAAPfSURBVEjHtVS/TyNHGH27Ozv+sRj/CDYuQCJSdBRp6CkjLlWkFFGUUCJLSUkBhfMPUCJEQZciihwqpEsTiQasSBQnIaUgd2ALkC4sxpzDcuZ8O+udbzaF2cXEwF2QstLTzOx+s2/mfe/7tHL5h+DCceC6LgxDh5QSvpSQkiB9CQrXJCGlBEmCvF734m7e+f5N3LtOB2+v3oAFgUKhMIpM7iPkRvKQvoQkgiQCSQWp+uakQEpCSgW6jpFEIFK9A4VzUjiuv8Afz38H0zQNhmHA5ByxWByGIWFIgkEEYgRDKRhSgRiBUY/QkApECqyPhIUkSoGRgsnj0HUDzDCM128uHTiOA/uvV70bRBKEp7+RRRJBSgJRD354Yyl7e1Uv3vn7NXzPBQPwaYAAQRBAKdVDoG7mdyAI5xSuCUrRQBwC/P+PNj8//02tVoNt2/B9H57nodvtwvM8CCHgui5SqVQskUjUbdve6d+8tLQEAFq5XA5WVlYKZ2dnn6+vr8vp6Wk+NTX1cmFh4TlLJpO/WJaFoaEhSCnBOY+IOOfgnCOdTiORSDyzbfvLfoJyuQxcC9FsNr9utVqrnueh3W6j1Wr9trW19RWbnJxELBZDPp/vWe/a277vRxgZGUEqlcLe3t6dMqytra3t7u5+v7GxAcdxsL29Dc/zPhsfHz9i+Xz+qRACuq5DKRW5IySSUqJYLPJ0Ov3qPp3r9fonjuMgHo8jFovBNE0IIfjR0dEoq1arODw8RKPRABFF+ocQQiCVSiEej9+byEaj8asQ4m0ulwPn/AvG2C6Al81mM8Ysy9pMJpOwLAtEBNM0I3DOYZomMpkMksnkMwC3cjA7OwsAWqVSWQWwOjMzM3R1ddXUdX21Wq3+DACMMQZN0wa93lcXhmGAc37fBSK3CyGSjDENQBTMiOip53lwXRdKKXS73Vsyua4L13W5aZoDOahUKreZgkAL7R8RTExMQNM0FAqFyD39CZZSIp/PI5VKYWdn5z8XGmu325uXl5e4uLgYsKfv++h2uyAidDqdgRx8EMHJyQmOj49xenp6y0VCiGjMZDKwLOtRrYIJIb4NW0JIIIS4BcZYTClVfxTB8vLy+vuCzs/PAQBPnjzRAAS1Wu3DCRYXF/P7+/uwbRtEFDW78PSu6yKbzeqWZbm1Wq390M+CYLA/M03T/tQ0Df+Gruv9Y1bX9R8BfPcQgVJqkKBYLOY7nQ4Mw4hcFNZCiGubfnxwcPCgHGNjYzqABICor7BMJrOey+XQ7XajGghJwjoYHR0dGh4e3nyf3tls9h2AnwC8eJTlSqWSViqV7vw2Nzen3bX+BxxQD5I249kcAAAAAElFTkSuQmCC\";\nexport const move_to_bottom = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAB3RJTUUH5godFRgEe5H4BwAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAARuSURBVEjHtVRNaFRXFP7u+08mkxknYyxGU6QLEQwuko2LFkRw0UXAhWipWJql4LIEdCtuulfpYlZCbBdt0YKWLixIS2mLhVStEtJGOpSYZGbMOPPm3fvuOaeLyRsnpkY3PXC479537v3e+b77PYW+qFQqO0XkwdLS0s7V1dXrV69e/QCviNnZ2VPMPBfHMdI07aW1FlprRFGEYrEIr39To9EAM6NaraJarWK7ePjwIZgZnU4HWmsYY6C17qWIwPf9zQDtdhvMjHq9jpWVlW0BBgcHPWaG4zjwfR/GGPi+jzAMobUGM8N13c0ASikopeC6LlzX3RZgamqqxcytJEliIhJrLay1YGakaQrP85DL5TYDZCEieF2cOXPmJjPvSpJEAMBxHGQjEaFYLKJQKGwGEJHe4UqpbQFOnjw5yczntNZGay1aayRJ0tMiTVMQ0X938CZdDA8PH2Tm00mSIAgChGGIMAxhjIExBkQEpdRWgOzLX9dBoVCoE1HL87w4CAIxxiCKoh6AUgqe520V+U34B4BWq3WTiHbFcSwZNZkHjDFg5q0d9GvwOqCxsbFJZj4Xx7FJ01TSNIUxpmc413URRRG8SqWiZmZmBAAmJyfje/fuyQY9tv/A8+fPq0uXLvVQa7XaQWY+nTm5X1xjDESkS9HMzIxcu3ZteHV1VW7cuLGnVCo5Gy3mLly4MCgiOcdxmhcvXtT9gNVqtZ75oP8WZRRllHkb3H+aJMnHy8vL6/fv3y9Vq1UMDAy8v7i4uDQ+Pp6Loug0gK/6Ae7evXsTwC4A23LpAcDIyMg79Xrdb7Va5cePH6PRaMjQ0FBYLBZ3TkxMoFQqlV7eeOXKlUlmPpckibHWirUWRARmBhEhiqIXRisUCl/k8/nd+/fvP7CwsIC1tTVEUYTR0VHkcrnb5XJ5/mWAR48eHch80P83zdJxnK7It27dUocPH/7szp07T8Iw/LpWq0VBEKjx8XEcPXr0geM4x0+cOJFcvnxZnT17tkfH/Py8IaIe7y+ntbYrdMbhkSNHvp2bm5s6duzYrxMTE1Gz2by9b9++49PT00l2i/s7OHTokEtEaLfbm66ntRbGGARBgHw+jy12/eGn395d+uvPsmV//qMPpxdfJd4vv9eGvvum8l6z2bRaa7E2RWpT2NTCaI1CcRh794xBzc5+cmq9sQLdWVeA5fra02dkyfrh4IDnh3lrSawlWCIQEawlMLPTieOk8az+HHBAxCBLIOJunQD1RhPWAh4gc4HHCAYsIp+xI1fubiABMYPIhSUFYgdEbnedGFQI8NboMIjlxRoxLAmYBStrz/Dk72V4Qga7d3Tw9kgbe8sEKx5EXAg8MAIwPIg4EHgQuOCNFHHB4kFUVtsdRVyI8vDjz3/g8y+/h+e6PpqdAEtPA6y3GcQKxAAxg0VAbMGswALwxjsWgFiBGWBRvWeS7ihwsLD4D7RO4SnHu95KPDSbAWpNhqUX2d86sYCJkWbz3vpGrZXenBlYq69DmxT/e/wL/opRMma51lkAAAAASUVORK5CYII=\";\nexport const horizontal = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAAYCAYAAAARfGZ1AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAB3RJTUUH5godFR8VXmBOMgAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAAItSURBVEjH7ZS9SitBFMd/M9nZddeYysYnCKQQsbTwMRQEbS1TpEsl+BIWwcLGMpXahBSCrVpY+ggJWiyus9mZc4uwMblJ7kW44TYeGM58nPnPf84XrFDUw8PDeKIUSqmvg6n1Iv03252dHfQqmf+Afw9caz0TtLlMUAqt9ffAtdZEUUSlUiEMw6XAYRiitZ7oP4KXF2q1Gi8vL7TbbVnGLggC4jim2WzKzc2NGGMwxsz9VJfG1WoVgG63K5eXl/L+/g6AMYYwDGeGMYYgCNjY2KDT6XB6eiqvr6+EYUilUvkikSQJxhienp7o9/tirSVJEoIg4P7+Hu89IjLRIjIhk6Yp1WqV4XBIs9mUvb09Wq2WSpJk7I1er8fd3Z0Mh0OcczjnKIqCoijw3lMUxWRvWk/blXtZlqG15uTkhLOzM6XLL/4LERG01qyvr4+ZPz4+EkURz8/P9Ho9sdby9vaGtZbj42MlIgAz7jHGUKvVuLi4kMFggLWWNE3Z39+n1WqptbU1Go0GQZZljEYjtre3qdfr6vb2Vvr9PlmWsbu7i/d+rimVPr+6uiJNUzY3Nzk/P1eNRgPnHHmej+0AiqIgTVOiKOLg4EBtbW1xfX0t5VnJfjrVnHMMBgMODw85OjpSIjIBXdpyy8Kw1hLHMdbameKZLrSPjw/iOMY5N0dgYcv13vP5+YnWmjzPJ5d+D1ye5xhjyPMc7/3CAC9Nk2lfL8uMRQ//9PP/C75S+QX3zx/c9r2O6AAAAABJRU5ErkJggg==\";\nexport const vertical = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAXCAYAAAARIY8tAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAB3RJTUUH5godFR8FQ9deVgAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAAJgSURBVEjHtZW9TutAEIW/2V175QSQIvESUIUiEhQ0gISAJ0C8AM/AA1AlbwANBQUtDRIFEgWiTIEoqCkoKAIyRrZ37Vs5yr0Xx7k/jORmd2fPnOOZs/DNIQDD4bDxYBiGXFxclO12m729PcmyrDGn2+1iZqlCa02SJJydnaGUYnNzkyAI8N435iqAsixrvwpgMBiURVGQ5zmDwaDUWjNLrmqqwBjD09MTd3d3RFFEq9Xi9vaWx8dHjDH/xkBEEBH6/X7ZarXQWqO1Zm5ujn6/X1b7jQzqDmituby8LF9eXrDWYozBGIO1ltfXV87Pz0ut9d9JpJSiKAqurq5YWlqi0+mMARYXF1leXubm5obPz0+Uqle6VsSKwenpqRhjuL6+5uTkpAQ4PDyUXq+H954kSZjWsqa67CuANE3x3hMEAXEcU3XO+/s7cRzjnMM592V+I0C1XlXnnBsD5HmOc45Zhs3MPPIi47acpvkfMZhkIiJjBpOt+d8YKKW+h0F12SSDSVZNTMw0zcMwRER+YyAiKKUIwxCALMsoiqLeru/v77+sXGvN0dFRORqNmJ+fZ2FhAYDRaMTHxwftdpvj42OphvLXWF1drbcK7z0iwsHBgURRRBiGP1lFFEXs7++LtRbvfa1VTP3JeZ7T6/V4fn7m4eFhvN7pdFhbW2N9fZ23t7dmN62LoihIkoTt7W2x1o7d1FrL7u6uJElSq/3MD06WZYRhyMbGhlQAW1tbYq0lTdPGB6exTcuyJEkSVlZWGA6HGGPodrvEcdxY/cyD5pwjz3N2dnYkCALSNMU5N9Og/QC/FsDpo71BjQAAAABJRU5ErkJggg==\";\nexport const to_path = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAB3RJTUUH5gsEBhoGqbjXJQAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAAH3SURBVDjLhZGxSxthGMZ/392l+b6E4IUQjENRQulWKXUwcwJZ8idk0D2IiIMdm03o0MnJ1aXQRSHF+AcEkiWEQFECwSXoZsPlcrnz9OsQsbWk12d83/f78T3PIzzPYzab0Ww2db/fx3EcTk4+cX+/hGEYSKm5vPSFlCyUcByHo6MjnclkKBaLIp1Os7xs662t72xufmB3d4Xr65lIpRYDrFarpaWUVKtVIYQAwDAEGxtvGY1+IMQKUbK63S7lcvn5MYBSmoODN/j+6/mR9W+AMR6PyWazL4bDoS+urgKxvV1nOPwplIoAJBIJJpPJi6FSYNuaVCrENP1IC0Y+n6ff7+tFS9M0CcMwOoNisShWV20dBFIDJJNwezsTlgUPDw9YUQEAhm3bBIGkVvvK4WGLIADHcQEIw/C/AOF5HkpJ3Wg4DAYD9vffU6t9ZDq9e8pD8WdDAFJK1tbWqFQqQnieRy4n9Xg8X6ZScHMzE6YJe3t7ul6vi1gs9gLgui69Xk+3220smHte9L1YLIZlWai/elRKUSqVRKPR0JEGk8kkruuSSCSeMoFcTmp3HhHx+BeMKEA+n2cwGDxX/PgIQQCnp3fs7HzD9+PRgEKhwPn5OaPR6Nm71pqLiybr6+9+txClTqejz87OmE6nmOYrjo8/4/vzUJeW4BekTMTiOlyMpQAAAABJRU5ErkJggg==\";\nexport const to_shapes = \"data:image/png;base64,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\";\nexport const base64_export = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAKzSURBVEiJtZTbbtpAEIa/9XqdcAEXEQoHoQhkBVXKde7yEH2Kvg9v0su+CFKFAnYSSDlUqQISyBh7etOlNnbP6kgje9fjmf//Z2eViPA/zc0ulFJngPePOfciEh1XIoKIMBwO322321kcx/Ivvt1uZ8Ph8J3Nq0QEpVRls9mMtdatNE2zjH4LclZmx3FIkuRTtVr1RWRnJTrzPK+13++PSZ+fn5nNZtRqNdbrNa1Wi06nA0Acx4xGIxaLBXd3d3jed1WTJMHzvBZwBuwcC9ZSsj4ej7m5uaHf72OMYTweH5EaY/B9P4f89H9AAeQKWPRKKaIowvM8FosFzWaTJElIkqSQ8FROpVRpAecUgfX5fM7l5WXpt5+5zW17oE4RiQgvLy/UarWCBD+Q5PRZlCgbYIwhDEPa7Ta2+Y7j/Ap1oQc5BlnzfZ+Hhwcmkwnr9Rrf91FKsdvtCMOQw+GAiDAajdBa0+12qVQqBQa2uc31ev0pSZLc2f+bORARtNbUarWWiMwtAydN08Kp+JN7KivRt2H9cZOVUhwOB+7v71kul9ze3nJ+fn5MtlqtmE6nVKtVNpsN7XabRqPx6znImtaaXq9XyiIMQ/r9Pr7vo7UmCIIyNvkCVqLf8f1+j+u6LJdLGo0GURTlvn+T6O8LWF+tVlxcXBT2swWOTS6Touyc2/3X11eq1WppXHaSjwxKNCy8W3Ndl+l0SrPZJI5jjDFlceWDJiJEUcTT0xNWtslkgtaaTqdDpVLh6uqKx8dHgiBgs9nQ7XbLroxcgTQIgs+9Xq8O4Hkevu8DcH19nYOVpin1ep16vV7YtxYEwWfg+zAA88Fg8CEMwy+O46C1xnVdXNfFGIMxBs/zcm73bZzWGsdxCMPwy2Aw+ADMc9IopW6At8CbTOE/tRT4CLwXkWGuwP+yr0z0vLd4EzkyAAAAAElFTkSuQmCC\";\nexport const zoom_in = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAQAAABKfvVzAAAAAmJLR0QA/vCI/CkAAAAJcEhZcwAADdYAAA3WAZBveZwAAAAJdnBBZwAAABgAAAAYAHhMpaYAAAIPSURBVDjLtZLLTxNRFMa/O52ZPsYqtCQgI6WhQCRBCwm+GqguTBOJIXHpxoV7+QOIJYgSEg0mdmliAltNSGShCza2IiEQqcuKGmamWF4akxbL9HlctKClBbvQb3Vzc37nfOcB/G+xgx/EgQEglq8CIANEWGABkEQSaZY7shiJJLvGhRAUKEKodZxkEo8MH/UKQai2oGfKM2ULQhWCo95yhO07bzBNks3/6m4UOwCOPWi630/xrds10YrGyNzhx/LYMHWF3VCghN3UNebHcts9MpdGcsX8ktoqR4YWkLCLUKHaRSSGFuWI1g4rcX8CfNGYOWVtWcE3bhp5bAPNT8HNDrZosU6YSifJ7z9SG7sArQPIArQJ1OQ2daN+0HwBIOgnVa0Z7MPrjHDOAyy9EbMdedVRr0EHlfXA8ti5pqbsFy67ZxwhpJF2hM6+7LuYsp//hETpzvcspZ4szDuXfL2ZuTmaB5Dpvb7ow1b310NPg4wfbwz0rHSLP2s14IcjLUFD1rn69vmpNaZXAAA6kbkacD2TlXqgff1WzKdPShM9vDDxcPD9b6T0+Hi0wYVaANtQ8D13ptMbaeTrHj+6E2Zl89qDODKQobAsMq3ddPoR4F8ELpGxQoUK+PGNgb6mz3V84+zIlS8sWxzr4WLxhpl30dMxbjUpVVUBAMi625+3SNOIM/p7dAERyURVpP43+gWF+ca8/eA5yQAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAxNy0xMS0yMFQxMDoxNToxMS0wMDowMH81V5MAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMTctMTEtMjBUMTA6MTU6MTEtMDA6MDAOaO8vAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAAABJRU5ErkJggg==\";\nexport const zoom_out = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAQAAABKfvVzAAAAAmJLR0QA/vCI/CkAAAAJcEhZcwAADdYAAA3WAZBveZwAAAAJdnBBZwAAABgAAAAYAHhMpaYAAAH1SURBVDjLtZLNaxNRFMXPm7yZfBGtMWhM/AjEig12UailsRhciJ9Q7MKFmy6617/AAa2VglLBbAShEBdFUFAQBMFVKhZRW3faiNJkWpNSESS16SRtclzEJqaJMQt9y/vO797DPRf4309sLlCBAEBRagGgBRoccADIIYeCKDYdRo3+4Kg6iSSS6uT+UfqpNZUPR9Q4Uu54X6wv5o4jpcaHI/WIqDj32mJ0X36qv8ciAO+10MhZZpeG2uYbGqO9Q8fMdZ0hSgoKSoZGdMy0X6W9kVyhx3HPN8FeykpNstc3Yb3PHVR+18pfxux5VzCBWZGoen0WDhqZTthqN1npKPMZE8SH6leR6VWrudlNGSDMXSljH1y8i43AFFgHAl4DJlgHiBJ/nE7d6eg5/3ocKygBUOA8PFTY3vMGy7WZb1jK3341FXh78sja1GMsA3CFz02fwlLXlz+eBq2Jgf7uj13aSpsBfN9bcMLAemDuxYPdC8JsAADcunY8Ghz3J3cCBzKD6RNmzDnWLdWxG5emq0jt8Um0I4htAL4iiW/FzkORWZ/03Lp58Z2o21c1RAst5bBoW7gQ0BGVD6NhWhtMaIBvWew/uueTR/qeXzn2WawDSnNAZL1PXs4fTCtzOWdLEwCArtUzJYfzEbKCf1eXEY02ttD637yfWKq5q2bQBKcAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTctMTEtMjBUMTA6MTU6MTEtMDA6MDB/NVeTAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE3LTExLTIwVDEwOjE1OjExLTAwOjAwDmjvLwAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAASUVORK5CYII=\";\nexport const reset_zoom = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAQAAABKfvVzAAAAAmJLR0QA/vCI/CkAAAAJcEhZcwAADdYAAA3WAZBveZwAAAAJdnBBZwAAABgAAAAYAHhMpaYAAAIBSURBVDjLtZLLaxNRFMa/O5lXZhi1aag1sRocUxSsUKjFhhpciI8uCoIupODCvf4FxketFJQKZq3QLIqg4ELQjZtO1eLC1o2L1gdNZmoqFSmkNZ1ckxwXCW3TjDULPZsDl+93z8f5DvC/i21+IAEMALFyAwD5IEODBiCPPDgrbTmMZAqbw9IE0khLE/uHKUzylvLBuGQhE7BiqVgqYCEjWYPxeoStOW9VRymQeHHVwQoY9KG2W32UW7y0w/E0Rv6DCUzfvka9HdfhwKF2OjyUwHT0Jvm95AIFtVRojHooig8YxzjtI4WOhsaUR9RCwkatUDXmLximjVks8wfg4ADKmDFtbkCt3eQaLRYWXJSwJD2vAgBlVxV3s5sKQHB3Zey9MACUqoAAw4m02HBBdQArY+VMhjd3n4cGERwcIrQj53hz9ycs12YuVnvh/tvJyLtTvcXXFk0CUGMDU6ex2Pn1j6dByuzZ/q6PnfLPJhtY2sN12ChG5l493j3PXA8AoO2/TiTNh+H0TqB94WL2pDuqj3SJ0sidK1PrSO3xiYjCRBOA70jjR6njUHwmJAbv3b38ntXtaz1EH/kqYZE6fyGSQFJ8kuwhxWOCB77tW/+xts9BMfTyxvEvrLghOO9iudZnb5wDWWEurzc0AQDIWO0ra/pT5Bj9XV1BZFKpga//Tf0Gp9/DBQB2y1wAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTctMTEtMjBUMTA6MTU6MTEtMDA6MDB/NVeTAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE3LTExLTIwVDEwOjE1OjExLTAwOjAwDmjvLwAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAASUVORK5CYII=\";\n","import {Menus} from \"../../context_menu/src/index.js\";\nimport {del,horizontal,vertical} from \"../../assets/graphics.js\";\nimport EventsManager from \"../events/EventsManager.js\";\nimport {PointEvents, PointMoveDirections} from \"./SmartPoint.js\";\n\n/**\n * Helper class that used to manage SmartPoint context menu\n * that appear on right mouse click\n * Should not be instantiated directly. SmartPoint automatically calls it\n * when needed\n * @param point {SmartPoint} The point object to manage menu for\n * @constructor\n */\nexport default function SmartPointContextMenu(point) {\n    /**\n     * The point object to manage menu for\n     * @type {SmartPoint}\n     */\n    this.point = point;\n\n    /**\n     * @ignore\n     * Context menu object instance\n     * @type {object}\n     */\n    this.contextMenu = null;\n\n    /**\n     * @ignore\n     * Method executed to check if context menu should be initialized\n     * or destroyed depending on options of the point\n     */\n    this.updateContextMenu = () => {\n        if (this.contextMenu) {\n            this.contextMenu.destroy();\n            this.contextMenu = null;\n        }\n        this.initMenu();\n        this.point.contextMenu = this.contextMenu;\n    }\n\n    /**\n     * @ignore\n     * Initializes context menu. Creates context menu and binds event\n     * listeners to it\n     */\n    this.initMenu = () => {\n        if (this.point.element) {\n            this.contextMenu = Menus.create([\n                {\n                    id: \"i\" + this.point.guid + \"_drag_horizontal\",\n                    title: this.point.dragHorizontal ? \"Disable move horizontally\" : \"Enable move horizontally\",\n                    image: horizontal\n                },\n                {\n                    id: \"i\" + this.point.guid + \"_drag_vertical\",\n                    title: this.point.dragVertical ? \"Disable move vertically\" : \"Enable move vertically\",\n                    image: vertical\n                }\n            ], this.point.element);\n            if (this.point.options.canDelete) {\n                this.contextMenu.addItem(\"i\" + this.point.guid + \"_delete\", \"Delete point\", del);\n            }\n            this._setEventListeners();\n        }\n    }\n\n    /**\n     * @ignore\n     * Method used to set up handler functions for context menu items\n     */\n    this._setEventListeners = () => {\n        this.contextMenu.on(\"click\",(event) => {\n            switch (event.itemId) {\n                case \"i\"+point.guid+\"_delete\":\n                    EventsManager.emit(PointEvents.POINT_DELETE_REQUEST,this.point);\n                    break;\n                case \"i\"+point.guid+\"_drag_horizontal\":\n                    this.onDragHorizontalClick(event)\n                    break;\n                case \"i\"+point.guid+\"_drag_vertical\":\n                    this.onDragVerticalClick(event)\n                    break;\n            }\n        })\n    }\n\n    /**\n     * @ignore\n     * Method runs when select \"Move horizontally\" from point context menu\n     * @param _event\n     */\n    this.onDragHorizontalClick = (_event) => {\n        this.point.dragHorizontal = !this.point.dragHorizontal;\n        if (this.point.dragHorizontal) {\n            this.point.dragVertical = false;\n        }\n        this.updatePointDragMode();\n    }\n\n    /**\n     * @ignore\n     * Method runs when select \"Move vertically\" from point context menu\n     * @param _event\n     */\n    this.onDragVerticalClick = (_event) => {\n        this.point.dragVertical = !this.point.dragVertical;\n        if (this.point.dragVertical) {\n            this.point.dragHorizontal = false;\n        }\n        this.updatePointDragMode();\n    }\n\n    /**\n     * @ignore\n     * Method updates point movement directions depending on context menu setup\n     */\n    this.updatePointDragMode = () => {\n        this.contextMenu.items.find(item=>item.id===\"i\"+this.point.guid+\"_drag_horizontal\").title = \"Enable move horizontally\";\n        this.contextMenu.items.find(item=>item.id===\"i\"+this.point.guid+\"_drag_vertical\").title = \"Enable move vertically\";\n        if (this.point.dragHorizontal) {\n            this.point.setOptions({moveDirections:[PointMoveDirections.LEFT,PointMoveDirections.RIGHT]})\n            this.contextMenu.items.find(item=>item.id===\"i\"+this.point.guid+\"_drag_horizontal\").title = \"Disable move horizontally\";\n        } else if (this.point.dragVertical) {\n            this.point.setOptions({moveDirections:[PointMoveDirections.TOP,PointMoveDirections.BOTTOM]})\n            this.contextMenu.items.find(item=>item.id===\"i\"+this.point.guid+\"_drag_vertical\").title = \"Disable move vertically\";\n        } else {\n            this.point.setOptions({moveDirections:\n                [PointMoveDirections.TOP,PointMoveDirections.BOTTOM,PointMoveDirections.LEFT,PointMoveDirections.RIGHT]}\n            )\n        }\n    }\n\n}\n","import SmartShapeManager,{ContainerEvents} from \"../SmartShapeManager/SmartShapeManager.js\";\nimport {\n    CSStoJsStyleName, distance,\n    getOffset,\n    getRotatedCoords,\n    mergeObjects,\n    notNull,\n    pauseEvent,\n    readJSON,\n    uuid\n} from \"../utils\";\nimport EventsManager from \"../events/EventsManager.js\";\nimport {createEvent} from \"../events/functions.js\";\nimport SmartPointContextMenu from \"./SmartPointContextMenu.js\";\n\n/**\n * Class that represents a single point on the screen.\n * Can be created directly using class constructor, but more often they added by using `addPoint`, `addPoints`\n * methods of [SmartShape](#SmartShape) class or interactively using SmartShape context menu.\n * @returns {object} SmartPoint object that should be initialized by `init` method.\n * @constructor\n */\nfunction SmartPoint() {\n    /**\n     * Point HTML element options. Defines look and behavior of point. Has the following parameters.\n     * @param id {string} Id of point HTML element. Default empty.\n     * @param width {number} Width of point in pixels. Default: `10`.\n     * @param height {number} Height of point in pixels. Default `10`.\n     * @param classes {string} CSS class or classes of point, delimited by comma. Default empty.\n     * @param style {object} CSS styles, that override classes. Must be provided as an object. Default see in code.\n     * (The same as [\"style\" HTML attribute](https://www.w3schools.com/jsref/prop_html_style.asp))\n     * @param canDrag {boolean} Is it allowed to drag this point by mouse to change it positions. Default `true`\n     * @param canDelete {boolean} Is it allowed to delete this point by right mouse click. Default `true`.\n     * @param zIndex {number} Order of element in a stack of HTML elements\n     * (https://www.w3schools.com/cssref/pr_pos_z-index.asp). Elements if higher z-index value placed on top.\n     * @param bounds {object} Bounds for point movement. If setup, then it's impossible to drag point beyond\n     * bounds. It must be an object of the following format: `{left:number,top:number,right:number,bottom:number}`.\n     * If created using `SmartShape`, then it automatically set this object to the dimensions of shape's container.\n     * @param moveDirections {array}. Defines in which directions point can move. Can contain\n     * values from [PointMoveDirections](#PointMoveDirections) enumeration. By default, all directions allowed. Default\n     * value is:\n     * `[PointMoveDirections.LEFT,PointMoveDirections.TOP,PointMoveDirections.RIGHT, PointMoveDirections.BOTTOM]`.\n     * To restrict movement in any direction, need to remove some directions from this array.\n     * @param visible {boolean} Point is visible or not. By default, `true`.\n     * @param forceDisplay {boolean} If this option enabled, than this point displayed all the time, even if shape\n     * is not in SCALE or ROTATE mode. By default, if the shape is in DEFAULT mode, then points not displayed on it.\n     * @param createDOMElement {boolean} Should HTML element for this point created by default. \"false\" by default\n     * @type {{}}\n     */\n    this.options = {\n        id:\"\",\n        width:10,\n        height:10,\n        classes: \"\",\n        style: {\n            \"border-width\":\"1px\",\n            \"border-style\":\"solid\",\n            \"border-color\":\"black\",\n            \"border-radius\": \"25px\",\n            \"cursor\":'pointer',\n            \"background-color\": \"red\",\n        },\n        canDrag: true,\n        canDelete: false,\n        zIndex:1000,\n        bounds:{},\n        moveDirections: [\n            PointMoveDirections.LEFT,\n            PointMoveDirections.TOP,\n            PointMoveDirections.RIGHT,\n            PointMoveDirections.BOTTOM\n        ],\n        visible: true,\n        hidden:false,\n        forceDisplay: false,\n        createDOMElement:false\n    };\n\n    /**\n     * X coordinate of point, relative to a corner of shape's container\n     * @type {number}\n     */\n    this.x = 0;\n\n    /**\n     * Y coordinate of point, relative to a corner of shape's container\n     * @type {number}\n     */\n    this.y = 0;\n\n    /**\n     * HTML DOM node of element, which used to display the point. This is styled DIV element.\n     * @type {HTMLElement}\n     */\n    this.element = null;\n\n    /**\n     * Internal global unique identifier of point. Generated automatically.\n     * @type {string}\n     */\n    this.guid = uuid();\n\n    /**\n     * @ignore\n     * List of subscribers, that subscribed to events, emitted by\n     * this point. This is an object, that consists of array\n     * of event handlers of each event. Each handler is a function\n     * that called when event of specified type emitted by\n     * this shape\n     * @type {object}\n     */\n    this.subscriptions = {}\n\n\n    /**\n     * @ignore\n     * Drag horizontal mode. If enabled, then point can be\n     * dragged only horizontally using UI\n     * @type {boolean}\n     */\n    this.dragHorizontal = false;\n\n    /**\n     * @ignore\n     * Drag vertical mode. If enabled, then point can be\n     * dragged only vertically using UI\n     * @type {boolean}\n     */\n    this.dragVertical = false;\n\n    /**\n     * Initializes new point and displays it on the screen.\n     * @param x {number} X coordinate of point relative to shape's container left\n     * @param y {number} Y coordinate of point relative to shape's container top\n     * @param options {object} Point options, described [above](#SmartPoint+options). If not specified,\n     * then [SmartShape.options.pointOptions](#SmartShape+options) used or global default options for point.\n     * @returns {object} constructed SmartPoint object\n     */\n    this.init = (x,y,options = null) => {\n        this.x = parseInt(x);\n        this.y = parseInt(y);\n        this.setOptions(mergeObjects({},options));\n        this.setEventListeners();\n        EventsManager.emit(PointEvents.POINT_ADDED,this);\n        return this;\n    }\n\n    /**\n     * Method used to set specified options to point.\n     * @param options {object} Point options object, described [above](#SmartPoint+options).\n     */\n    this.setOptions = (options) => {\n        if (options && typeof(options) === \"object\") {\n            if (notNull(options.moveDirections) && typeof(options.moveDirections) === \"object\") {\n                this.options.moveDirections = [];\n            }\n            this.options = mergeObjects(this.options,options);\n        }\n        Object.assign(this, new SmartPointContextMenu(this));\n        if (!this.element) {\n            if ((this.options.createDOMElement && this.options.canDrag) || this.options.forceDisplay) {\n                this.element = this.createPointUI();\n                this.setDOMEventListeners();\n                this.updateContextMenu();\n                EventsManager.emit(PointEvents.POINT_ADDED,this);\n            }\n        } else {\n            if ((!this.options.createDOMElement || !this.options.canDrag) && !this.options.forceDisplay) {\n                try {\n                    this.element.parentNode.removeChild(this.element);\n                    this.element = null;\n                } catch {}\n            }\n        }\n        if (this.options.id && this.element) {\n            this.element.id = this.options.id;\n        }\n    }\n\n    /**\n     * @ignore\n     * Internal method that constructs HTML element of point, applies current options to it\n     * @returns {object} HTML element of points\n     */\n    this.createPointUI = () => {\n        const element = document.createElement(\"div\")\n        if (!this.options.canDrag) {\n            return element;\n        }\n        return this.setPointStyles(element);\n    }\n\n    /**\n     * @ignore\n     * Internal method that applies styles from `options` to point's HTML element and returns modified element\n     * @param element {HTMLDivElement} Input HTML element\n     * @returns {HTMLDivElement} HTML element with applied styles\n     */\n    this.setPointStyles = (element=null) => {\n        if (!this.element) {\n            this.element = document.createElement(\"div\");\n            this.setDOMEventListeners();\n            Object.assign(this,new SmartPointContextMenu(this));\n        }\n        if (element == null) {\n            element = this.element;\n        }\n        if (this.options.id) {\n            this.element.id = this.options.id;\n            element.id = this.options.id\n        }\n        element.className = this.options.classes;\n\n        element.style = this.options.style;\n        if (typeof(this.options.style) === \"object\") {\n            for (let cssName in this.options.style) {\n                element.style[CSStoJsStyleName(cssName)] = this.options.style[cssName]\n            }\n        }\n        element.style.width = this.options.width+\"px\";\n        element.style.height = this.options.height+\"px\";\n        element.style.left = (this.x-parseInt(this.options.width/2))+\"px\";\n        element.style.top = (this.y-parseInt(this.options.height/2))+\"px\";\n        element.style.zIndex = this.options.zIndex;\n        if (!this.options.canDrag || !this.options.visible || this.options.hidden) {\n            element.style.display = 'none';\n        } else {\n            element.style.display = '';\n        }\n        element.style.position = 'absolute';\n        return element\n    }\n\n    /**\n     * Method used to redraw the point. Usually used after change point position on the screen.\n     */\n    this.redraw = () => {\n        if ((this.options.canDrag && this.options.createDOMElement) || this.options.forceDisplay) {\n            this.element = this.setPointStyles();\n        }\n    }\n\n    /**\n     * Method used to display point if it has hidden\n     */\n    this.show = () => {\n        this.setOptions({visible:true});\n        this.redraw();\n    }\n\n    /**\n     * Method used to hide point\n     */\n    this.hide = () => {\n        this.setOptions({visible:false});\n        this.redraw();\n    }\n\n    /**\n     * @ignore\n     * Method used to rotate this point by specified angle around specified center\n     * @param angle {number} Angle in degrees\n     * @param centerX {number} X coordinate of center\n     * @param centerY {number} Y coordinate of center\n     */\n    this.rotateBy = (angle,centerX,centerY) => {\n        const [x,y] = getRotatedCoords(angle, this.x,this.y, centerX,centerY);\n        this.x = x;\n        this.y = y;\n    }\n\n    /**\n     * @ignore\n     * Internal method used to attach HTML event listeners to point.\n     */\n    this.setEventListeners = () => {\n        EventsManager.subscribe(ContainerEvents.CONTAINER_BOUNDS_CHANGED,this.onBoundsChange);\n    }\n\n    this.setDOMEventListeners = () => {\n        if (!this.element) {\n            return\n        }\n        this.element.addEventListener(\"mouseup\",this.mouseup);\n        this.element.addEventListener(\"mousedown\", this.mousedown);\n        this.element.addEventListener(\"mouseover\", this.mouseover);\n        this.element.addEventListener(\"mouseout\", this.mouseout);\n        this.element.addEventListener(\"click\", this.click);\n        this.element.addEventListener(\"dblclick\", this.doubleclick);\n        this.element.addEventListener(\"mousemove\", this.mousemove);\n    }\n\n    /**\n     * @ignore\n     * onMouseDown event handler, triggered when user press mouse button on point's DIV element.\n     * @param event {MouseEvent} Event object\n     */\n    this.mousedown = (event) => {\n        EventsManager.emit(PointEvents.POINT_MOUSE_DOWN,this,createEvent(event));\n        if (event.buttons === 1 && this.options.canDrag) {\n            EventsManager.emit(PointEvents.POINT_DRAG_START,this,createEvent(event));\n            pauseEvent(event);\n        }\n    }\n\n    /**\n     * @ignore\n     * onMouseMove event handler, triggered when user moves mouse over point's DIV element.\n     * @param event {MouseEvent} Event object\n     */\n    this.mousemove = (event) => {\n        EventsManager.emit(PointEvents.POINT_MOUSE_MOVE,this,createEvent(event))\n        if (event.buttons !== 1 || !this.options.canDrag || !SmartShapeManager.draggedShape ||\n            SmartShapeManager.draggedShape.draggedPoint !== this) {\n            return\n        }\n        const oldX = this.x;\n        const oldY = this.y;\n        const offset = getOffset(this.element.parentNode,true);\n        if (!this.checkFitBounds(this.x + event.movementX, this.y + event.movementY)) {\n            EventsManager.emit(PointEvents.POINT_DRAG_MOVE,this,createEvent(event,{oldX,oldY}));\n            return;\n        }\n        let newX = event.clientX + window.scrollX - offset.left - this.options.width/2;\n        let newY = event.clientY + window.scrollY - offset.top - this.options.height/2;\n        [newX,newY] = this.applyMoveRestrictions(newX,newY,oldX,oldY);\n        this.x = newX;\n        this.y = newY;\n        this.element.style.left = (this.x)+\"px\";\n        this.element.style.top = (this.y)+\"px\";\n        EventsManager.emit(PointEvents.POINT_DRAG_MOVE,this, createEvent(event,{oldX,oldY}));\n    }\n\n    /**\n     * @ignore\n     * onMouseOver event handler, triggered when mouse cursor enters point's DIV element.\n     * @param event {MouseEvent} Event object\n     */\n    this.mouseover = (event) => {\n        EventsManager.emit(PointEvents.POINT_MOUSE_OVER,this,createEvent(event));\n    }\n\n    /**\n     * @ignore\n     * onMouseOut event handler, triggered when mouse cursor leaves point's DIV element.\n     * @param event {MouseEvent} Event object\n     */\n    this.mouseout = (event) => {\n        EventsManager.emit(PointEvents.POINT_MOUSE_OUT,this,createEvent(event));\n    }\n\n    /**\n     * @ignore\n     * onClick event handler, triggered when user clicks on point's DIV element.\n     * @param event {MouseEvent} Event object\n     */\n    this.click = (event) => {\n        EventsManager.emit(PointEvents.POINT_MOUSE_CLICK,this,createEvent(event));\n    }\n\n    /**\n     * @ignore\n     * onClick event handler, triggered when user double-clicks on point's DIV element.\n     * @param event {MouseEvent} Event object\n     */\n    this.doubleclick = (event) => {\n        EventsManager.emit(PointEvents.POINT_MOUSE_DOUBLE_CLICK,this,createEvent(event));\n    }\n\n    /**\n     * @ignore\n     * Method checks if specified coordinate does not go beyond bounds\n     * @param x {number} X coordinate\n     * @param y {number} Y coordinate\n     * @returns {boolean} True if x,y fit bounds and false if not\n     */\n    this.checkFitBounds = (x,y) => {\n        return !(this.options.bounds.left !== -1 && x < this.options.bounds.left ||\n            this.options.bounds.right !== -1 && x > this.options.bounds.right ||\n            this.options.bounds.top !== -1 && y < this.options.bounds.top ||\n            this.options.bounds.bottom !== -1 && y > this.options.bounds.bottom);\n    }\n\n    /**\n     * @ignore\n     * Method that check movement restrictions based on directions, to which point moved\n     * from old position to new. Returns new coordinates, after apply movement restrictions\n     * @param newX - X after move\n     * @param newY - Y after move\n     * @param oldX - X before move\n     * @param oldY - Y before move\n     * @returns {array} [x,y] array of coordinates after check movement restrictions\n     */\n    this.applyMoveRestrictions = (newX,newY,oldX,oldY) => {\n        if (newY>oldY && this.options.moveDirections.indexOf(PointMoveDirections.BOTTOM) === -1) {\n            newY = oldY;\n        }\n        if (newY<oldY && this.options.moveDirections.indexOf(PointMoveDirections.TOP) === -1) {\n            newY = oldY;\n        }\n        if (newX>oldX && this.options.moveDirections.indexOf(PointMoveDirections.RIGHT) === -1) {\n            newX = oldX;\n        }\n        if (newX<oldX && this.options.moveDirections.indexOf(PointMoveDirections.LEFT) === -1) {\n            newX = oldX;\n        }\n        if (newX>this.options.bounds.right && this.options.bounds.right !== -1) {\n            newX = this.options.bounds.right;\n        }\n        if (newY>this.options.bounds.bottom && this.options.bounds.bottom !== -1) {\n            newY = this.options.bounds.bottom;\n        }\n        if (newX<this.options.bounds.left && this.options.bounds.left !== -1) {\n            newX = this.options.bounds.left;\n        }\n        if (newY<this.options.bounds.top && this.options.bounds.top !== -1) {\n            newY = this.options.bounds.top;\n        }\n        return [newX,newY];\n    }\n\n    /**\n     * @ignore\n     * onMouseUp event handler, triggered when user releases mouse button on point DIV element.\n     * @param event {MouseEvent} Event object\n     */\n    this.mouseup = (event) => {\n        EventsManager.emit(PointEvents.POINT_MOUSE_UP, this, createEvent(event));\n        if (event.button !==2) {\n            EventsManager.emit(PointEvents.POINT_DRAG_END,this, createEvent(event));\n        }\n    }\n\n    /**\n     * @ignore\n     * The handler, that reacts on container dimensions change event.\n     * @param event - custom event object, which contains new bounds in `event.bounds` field\n     * and array of points, which this change could affect in `event.points` field.\n     */\n    this.onBoundsChange = (event) => {\n        if (event.points.find(item => item === this)) {\n            this.options.bounds = event.bounds;\n        }\n    }\n\n    /**\n     * Method used to serialize point to JSON string\n     * @returns {string} JSON string with serialized point object\n     */\n    this.toJSON = () => {\n        return JSON.stringify(this.getJSON());\n    }\n\n    /**\n     * @ignore\n     * Internal method returns point as a JSON object\n     * @returns {object} JSON object with point parameters\n     */\n    this.getJSON = () => {\n        return {\n            x: this.x,\n            y: this.y,\n            options: mergeObjects({},this.options),\n        }\n    }\n\n    /**\n     * Method used to construct point object from JSON string representation,\n     * received by using `toJSON()` method.\n     * @param json {string} JSON-serialized point object as an object or as a string\n     * @returns {SmartPoint} constructed point or null in case of error\n     */\n    this.fromJSON = (json) => {\n        let jsonObj = json;\n        if (typeof(jsonObj) === \"string\") {\n            jsonObj = readJSON(json);\n        }\n        if (!jsonObj) {\n            return null;\n        }\n        this.x = jsonObj.x;\n        this.y = jsonObj.y;\n        let isNew = false;\n        if (!this.element) {\n            isNew = true;\n            this.element = document.createElement(\"div\");\n        }\n        this.setOptions(jsonObj.options);\n        if (isNew) {\n            EventsManager.emit(PointEvents.POINT_ADDED,this);\n        }\n        return this;\n    }\n\n    /**\n     * Method used to destroy the point. Removes event listeners from point element and\n     * raises the `point_destroyed` event. This event then intercepted by owner shape. Then owner shape\n     * removes this point from shape's points array.\n     */\n    this.destroy = () => {\n        if (this.element) {\n            this.element.removeEventListener(\"mouseup\", this.mouseup);\n            this.element.removeEventListener(\"mousedown\", this.mousedown);\n            this.element.removeEventListener(\"mouseover\", this.mouseover);\n            this.element.removeEventListener(\"mouseout\", this.mouseout);\n            this.element.removeEventListener(\"click\", this.click);\n            this.element.removeEventListener(\"dblclick\", this.doubleclick);\n            this.element.removeEventListener(\"mousemove\", this.mousemove);\n        }\n        EventsManager.unsubscribe(ContainerEvents.CONTAINER_BOUNDS_CHANGED,this.onBoundsChange);\n        EventsManager.emit(PointEvents.POINT_DESTROYED,this);\n        for (let eventName in this.subscriptions) {\n            const handlers = this.subscriptions[eventName];\n            handlers.forEach(handler => EventsManager.unsubscribe(eventName,handler));\n            this.subscriptions[eventName] = [];\n        }\n    }\n\n    /**\n     * Uniform method that used to add event handler of specified type to this object.\n     * SmartPoint can emit events, defined in [PointEvents](#PointEvents) enumeration. So, you can\n     * listen any of these events.\n     * @param eventName {string} - Name of event. Use one of names, defined in [PointEvents](#PointEvents)\n     * @param handler {function} - Function that used as an event handler\n     * @returns {function} - Pointer to added event handler. Should be used to remove event listener later.\n     */\n    this.addEventListener = (eventName,handler) => {\n        if (typeof(this.subscriptions[eventName]) === \"undefined\") {\n            this.subscriptions[eventName] = [];\n        }\n        const listener = EventsManager.subscribe(eventName, (event) => {\n            if (event.target && event.target.guid === this.guid) {\n                handler(event)\n            }\n        });\n        this.subscriptions[eventName].push(listener);\n        return listener;\n    }\n\n    /**\n     * Uniform method that used to remove event handler, that previously added\n     * to this object.\n     * @param eventName {string} Name of event to remove listener from\n     * @param listener {function} Pointer to event listener, that added previously.\n     * It was returned from [addEventListener](#ResizeBox+addEventListener) method.\n     */\n    this.removeEventListener = (eventName,listener) => {\n        if (this.subscriptions[eventName] && typeof(this.subscriptions[eventName]) !== \"undefined\") {\n            this.subscriptions[eventName].splice(this.subscriptions[eventName].indexOf(listener), 1);\n        }\n        EventsManager.unsubscribe(eventName,listener)\n    }\n\n    /**\n     * Method returns a distance from this point to other specified point\n     * @param point {SmartPoint} Distant point\n     * @returns {number} Distance from this point to specified point\n     */\n    this.distance = (point) => {\n        return distance(this.x,this.y,point.x,point.y)\n    }\n\n    return this;\n}\n\n/**\n * Enumeration of event names, that can be emitted by [SmartPoint](#SmartPoint) object.\n * @param create {PointEvents.POINT_ADDED} Emitted when point created. Event contains SmartPoint object in `target` field\n * @param drag_start {MouseEvent} Emitted when user press mouse button on point before start dragging it.\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) mousedown object\n * @param drag {MouseEvent} Emitted when user drags point by a mouse.\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) mousemove object\n * and two additional fields: `oldX` and `oldY` coordinates, which was before event start.\n * @param drag_end {MouseEvent} Emitted when user releases mouse button after pressing it on point\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) mouseup object\n * @param mousedown {MouseEvent} Emitted when user presses mouse button on point\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) mousedown object\n * @param mouseup {MouseEvent} Emitted when user releases mouse button on point\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) mouseup object\n * @param mouseover {MouseEvent} Emitted when mouse cursor goes inside point\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) mouseover object\n * @param mousemove {MouseEvent} Emitted when mouse cursor moves on top of point\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) mouseover object\n * @param mouseout {MouseEvent} Emitted when mouse cursor goes away from point\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) mouseout object\n * @param click {MouseEvent} Emitted when click on point\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) click object\n * @param dblclick {MouseEvent} Emitted when double-click on point\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) dblclick object\n * @param destroy {PointEvents.POINT_DESTROYED} Emitted when point destroyed (by pressing right mouse button on it or\n * programmatically using `destroy` method)\n * @enum {string}\n */\nexport const PointEvents = {\n    POINT_ADDED: \"create\",\n    POINT_DESTROYED: \"destroy\",\n    POINT_DRAG_START: \"move_start\",\n    POINT_DRAG_MOVE: \"move\",\n    POINT_DRAG_END: \"move_end\",\n    POINT_MOUSE_DOWN: \"mousedown\",\n    POINT_MOUSE_MOVE: \"mousemove\",\n    POINT_MOUSE_UP: \"mouseup\",\n    POINT_MOUSE_OVER: \"mouseover\",\n    POINT_MOUSE_OUT: \"mouseout\",\n    POINT_MOUSE_CLICK: \"click\",\n    POINT_MOUSE_DOUBLE_CLICK: \"dblclick\",\n    POINT_DELETE_REQUEST: \"point_delete_request\"\n};\n\n/**\n * Enumeration that defines point move directions. Values from this enumeration should be used\n * in point option `moveDirections` to specify in which directions point can be moved.\n * Members of enumeration: `LEFT`, `TOP`, `RIGHT`, `BOTTOM`\n * @enum {int}\n */\nexport const PointMoveDirections = {\n    TOP: 0,\n    LEFT: 1,\n    RIGHT: 2,\n    BOTTOM: 3\n}\n\nexport default SmartPoint;\n","import EventsManager from \"../events/EventsManager.js\";\nimport {ShapeEvents} from \"../SmartShape/SmartShapeEventListener.js\";\nimport {PointEvents} from \"../SmartPoint/SmartPoint.js\";\nimport {distance, radians_to_degrees} from \"../utils\";\nimport {createEvent, getMouseCursorPos} from \"../events/functions.js\";\n\n/**\n * Internal helper class, that contains all event listening logic for the RotateBox.\n * This class should not be used directly. Each RotateBox creates an instance of\n * this class automatically during init process\n * @param rotateBox {RotateBox} Link to owner Shape instance\n * @constructor\n */\nfunction RotateBoxEventListener(rotateBox) {\n\n    /**\n     * @ignore\n     * Underlying rotateBox that managed by this event listener\n     * @type {RotateBox}\n     */\n    this.rotateBox = rotateBox;\n\n    /**\n     * @ignore\n     * List of subscribers, that subscribed to events, emitted by\n     * this RotateBox. This is an object, that consists of array\n     * of event handlers of each event. Each handler is a function\n     * that called when event of specified type emitted by\n     * this RotateBox\n     * @type {object}\n     */\n    this.subscriptions = {\n        \"rotate\": []\n    }\n\n    /**\n     * @ignore\n     * Initial rotation angle when user presses one of rotation buttons\n     * @type {number}\n     */\n    this.initialAngle = 0;\n\n    /**\n     * @ignore\n     * Rotation angle from previous rotate event. Used to measure difference\n     * between previous rotate event and current rotation event.\n     * @type {number}\n     */\n    this.previousAngle = 0;\n\n    this.shapeEventListeners = {};\n\n    /**\n     * @ignore\n     * Initializes and starts this event listener\n     * @returns {RotateBoxEventListener}\n     */\n    this.run = () => {\n        this.setEventListeners();\n        return this;\n    }\n\n    /**\n     * @ignore\n     * Setup event handlers for different events, to which rotate box should react.\n     */\n    this.setEventListeners = () => {\n        this.interceptEventsFromShape();\n        this.rotateBox.shape.points.forEach(point => {\n            point.mousemove = this.mousemove;\n            point.mouseDownListener = point.addEventListener(PointEvents.POINT_DRAG_START, (event) => {\n                this.onPointMouseDown(event);\n                    EventsManager.emit(ShapeEvents.POINT_DRAG_START,this.rotateBox,{point:point})\n\n            });\n            point.mouseUpListener = point.addEventListener(PointEvents.POINT_DRAG_END, (event) => {\n                this.onPointMouseUp(event);\n                    EventsManager.emit(ShapeEvents.POINT_DRAG_END,this.rotateBox,{point:point})\n            });\n        });\n    }\n\n    /**\n     * @ignore\n     * Method intercepts all mouse events from underlying shape\n     * and re-emits them like they come from RotateBox\n     */\n    this.interceptEventsFromShape = () => {\n        ShapeEvents.getShapeMouseEvents().forEach(item => {\n            this.shapeEventListeners[item.name] = this.rotateBox.shape.addEventListener(item.name,(event) => {\n                if (item.key === \"SHAPE_MOVE_END\") {\n                    this.previousAngle = 0;\n                }\n                EventsManager.emit(item.name,this.rotateBox,event);\n            });\n        })\n    }\n\n    /**\n     * @ignore\n     * onMouseMove event handler, triggered when user moves mouse over the shape or container element.\n     * @param event {MouseEvent} Event object\n     */\n    this.mousemove = (event) => {\n        if (event.buttons !== 1) {\n            EventsManager.emit(ShapeEvents.SHAPE_MOUSE_MOVE,this.rotateBox.shape,\n                createEvent(event,{clientX:event.clientX,clientY:event.clientY})\n            );\n            return\n        }\n        const [clientX,clientY] = getMouseCursorPos(event,this.rotateBox.shape.root);\n        const [centerX,centerY] = this.rotateBox.shape.getCenter();\n        let angle = this.calcAngle(clientX,clientY,centerX,centerY);\n        if (angle === null) {\n            return;\n        }\n        let angleDiff = angle;\n        if (this.previousAngle) {\n            angleDiff -= this.previousAngle;\n        }\n        this.previousAngle = angle;\n        EventsManager.emit(RotateBoxEvents.ROTATE_BOX_ROTATE,this.rotateBox,{angle:angleDiff});\n    }\n\n    /**\n     * @ignore\n     * Method used to calculate rotation angle based on coordinates of point to which\n     * user dragged the mouse cursor and center to rotate the point around\n     * @param clientX {number} X coordinate of current mouse cursor position\n     * @param clientY {number} Y coordinate of current mouse cursor position\n     * @param centerX {number} X coordinate of center (shape center)\n     * @param centerY {number} Y coordinate of center (shape center)\n     * @returns {null|number} Rotation angle in degrees or null if impossible to calculate it\n     */\n    this.calcAngle = (clientX,clientY,centerX,centerY) => {\n        const hypotenuse = this.calcHypotenuse(clientX,clientY,centerX,centerY);\n        if (hypotenuse <= 0) {\n            return null;\n        }\n        const cathetus = this.calcCathetus(clientX,clientY,centerX,centerY);\n        const startAngle = this.calcStartAngle(clientX,clientY,centerX,centerY);\n        return Math.round(radians_to_degrees(Math.asin(cathetus/hypotenuse)) + startAngle + this.initialAngle);\n    }\n\n    /**\n     * @ignore\n     * Method used to calculate distance from point of mouse cursor to center of a shape,\n     * which is a hypotenuse of triangle, used to calculate sine of rotation angle\n     * https://code.germanov.dev/smart_shape/assets/sin-cos-tan.svg\n     * @param clientX {number} X coordinate of current mouse cursor position\n     * @param clientY {number} Y coordinate of current mouse cursor position\n     * @param centerX {number} X coordinate of center (shape center)\n     * @param centerY {number} Y coordinate of center (shape center)\n     * @returns {number} Length of hypotenuse\n     */\n    this.calcHypotenuse = (clientX,clientY,centerX,centerY) => {\n        return distance(clientX,clientY,centerX,centerY);\n    }\n\n    /**\n     * @ignore\n     * Method used to determine the size of opposite cathetus of triangle,\n     * that can be created from (clientX,clientY) mouse cursor point\n     * to (centerX,centerY) point of shape center. The distance, that need\n     * to calculate depends on quarter of coordinate plane with center in (centerX,centerY)\n     * in which the point (clientX,clientY) located.\n     * https://code.germanov.dev/smart_shape/assets/quarters.jpeg\n     * Cathetus used to calculate sine of rotation angle by formula, specified here:\n     * https://code.germanov.dev/smart_shape/assets/sin-cos-tan.svg\n     * @param clientX {number} X coordinate of current mouse cursor position\n     * @param clientY {number} Y coordinate of current mouse cursor position\n     * @param centerX {number} X coordinate of center (shape center)\n     * @param centerY {number} Y coordinate of center (shape center)\n     * @returns {number}\n     */\n    this.calcCathetus = (clientX,clientY,centerX,centerY) => {\n        if (clientX <= centerX && clientY <= centerY) {\n            return distance(clientX,clientY,clientX,centerY)\n        }\n        if (clientX >= centerX && clientY <= centerY) {\n            return distance(clientX,clientY,centerX,clientY);\n        }\n        if (clientX >= centerX && clientY >= centerY) {\n            return distance(clientX,clientY,clientX,centerY);\n        }\n        if (clientX <= centerX && clientY >= centerY) {\n            return distance(clientX,clientY,centerX,clientY);\n        }\n    }\n\n    /**\n     * @ignore\n     * Method used to determine the angle which need to subtract,\n     * depending on quarter of coordinate plane  with center in\n     * (centerX,centerY) point of shape center, when move the point\n     * (clientX,clientY) clockwise:\n     * https://code.germanov.dev/smart_shape/assets/sin-cos-tan.svg\n     * @param clientX {number} X coordinate of current mouse cursor position\n     * @param clientY {number} Y coordinate of current mouse cursor position\n     * @param centerX {number} X coordinate of center (shape center)\n     * @param centerY {number} Y coordinate of center (shape center)\n     * @returns {number} Angle in degrees\n     */\n    this.calcStartAngle = (clientX,clientY,centerX,centerY) => {\n        if (clientX <= centerX && clientY <= centerY) { // II\n            return 0;\n        }\n        if (clientX >= centerX && clientY <= centerY) { // I\n            return 90;\n        }\n        if (clientX >= centerX && clientY >= centerY) { // IV\n            return 180;\n        }\n        if (clientX <= centerX && clientY >= centerY) { /// III\n            return 270\n        }\n    }\n\n    /**\n     * @ignore\n     * onMouseDown event for marker points\n     * @param event {MouseEvent} Standard Mouse event object\n     */\n    this.onPointMouseDown = (event) => {\n        switch (event.target) {\n            case this.rotateBox.left_top:\n                this.initialAngle = -45;\n                break;\n            case this.rotateBox.right_top:\n                this.initialAngle = -135;\n                break;\n            case this.rotateBox.right_bottom:\n                this.initialAngle = -225;\n                break;\n            case this.rotateBox.left_bottom:\n                this.initialAngle = -315;\n                break;\n        }\n        this.rotateBox.shape.points.forEach(point => point.setOptions({visible:false}));\n    }\n\n    /**\n     * @ignore\n     * onMouseUp event for marker points\n     * @param _event {MouseEvent} Standard Mouse event object\n     */\n    this.onPointMouseUp = (event) => {\n        this.rotateBox.shape.points.forEach(point => {\n            point.setOptions({visible:true});\n            point.redraw();\n        });\n    }\n\n    /**\n     * @ignore\n     * Uniform method that used to add event handler of specified type to this object.\n     * RotateBox can emit events, defined in [RotateBoxEvents](#RotabeBoxEvents) enumeration. So, you can\n     * listen any of these events.\n     * @param eventName {string} - Name of event. Use one of name, defined in [RotateBoxEvents](#RotateBoxEvents)\n     * @param handler {function} - Function that used as an event handler\n     * @returns {function} - Pointer to added event handler. Should be used to remove event listener later.\n     */\n    this.addEventListener = (eventName,handler) => {\n        if (typeof(this.subscriptions[eventName]) === \"undefined\") {\n            this.subscriptions[eventName] = [];\n        }\n        const listener = EventsManager.subscribe(eventName, (event) => {\n            if (event.target && event.target.shape && event.target.shape.guid === this.rotateBox.shape.guid) {\n                handler(event)\n            }\n        });\n        this.subscriptions[eventName].push(listener);\n        return listener;\n    }\n\n    /**\n     * @ignore\n     * Uniform method that used to remove event handler, that previously added\n     * to this object.\n     * @param eventName {RotateBoxEvents|string} Name of event to remove listener from\n     * @param listener {function} Pointer to event listener, that added previously.\n     * It was returned from [addEventListener](#RotateBox+addEventListener) method.\n     */\n    this.removeEventListener = (eventName,listener) => {\n        if (this.subscriptions[eventName] && typeof(this.subscriptions[eventName]) !== \"undefined\") {\n            this.subscriptions[eventName].splice(this.subscriptions[eventName].indexOf(listener), 1);\n        }\n        EventsManager.unsubscribe(eventName,listener)\n    }\n\n    /**\n     * @ignore\n     * Method used to destroy the object. Removes all event subscriptions.\n     */\n    this.destroy = () => {\n        for (let eventName in this.subscriptions) {\n            const handlers = this.subscriptions[eventName];\n            handlers.forEach(handler => EventsManager.unsubscribe(eventName,handler));\n            this.subscriptions[eventName] = [];\n        }\n        Object.keys(this.shapeEventListeners).forEach(\n            key => {\n                this.rotateBox.removeEventListener(key, this.shapeEventListeners[key])\n            }\n        )\n        this.rotateBox.shape.points.forEach(point => {\n            point.removeEventListener(PointEvents.POINT_DRAG_START, point.mouseDownListener);\n            point.removeEventListener(PointEvents.POINT_DRAG_END, point.mouseUpListener);\n        });\n    }\n}\n\n/**\n * Enumeration that defines events, that RotateBox can emit.\n * @param rotate {RotateBoxEvents.ROTATE_BOX_ROTATE} Emitted when user rotate the shape by dragging one of marker points.\n * The event object of this type contains `angle` option, which is an angle of rotation in degrees.\n * @param create {ShapeEvents.SHAPE_CREATE} Emitted right after shape is created and initialized.\n * Event object contains created shape [SmartShape](#SmartShape) object in a `target` field\n * @param move_start {MouseEvent} Emitted when user presses left mouse button on shape to start dragging.\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) mousedown object with additional\n * field `pos`, which is a position of shape when movement started.\n * Position is an object with following fields \"left,top,right,bottom,width,height\"\n * @param move {MouseEvent} Emitted when user drags shape.\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) mousemove object, but also\n * includes additional properties `oldPos` - shape position before previous movement. `newPos` - shape position after\n * previous movement. Position is an object with following fields \"left,top,right,bottom,width,height\"\n * @param move_end {MouseEvent} Emitted when user releases mouse button to stop drag the shape.\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) mouseup object with additional\n * field `pos`, which is a position of shape when movement started.\n * Position is an object with following fields \"left,top,right,bottom,width,height\"\n * @param mousemove {MouseEvent} Emitted when user moves mouse over shape\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) mousemove object\n * @param mouseover {MouseEvent} Emitted when mouse cursor goes inside shape\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) mouseover object\n * @param mouseout {MouseEvent} Emitted when mouse cursor goes away from shape\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) mouseout object\n * @param click {MouseEvent} Emitted when click on shape\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) click object\n * @param dblclick {MouseEvent} Emitted when double-click on shape\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) dblclick object\n * @param point_drag_start {MouseEvent} Emitted when user starts dragging one of shape's point. Event Includes `point` field.\n * It is a [SmartPoint](#SmartPoint) object.\n * @param point_drag_move {MouseEvent} Emitted when user dragging one of shape's point. Event Includes `point` field.\n * It is a [SmartPoint](#SmartPoint) object.\n * @param point_drag_end {MouseEvent} Emitted when user finishes dragging one of shape's point. Event Includes `point` field.\n * It is a [SmartPoint](#SmartPoint) object.\n * @param destroy {ShapeEvents.SHAPE_DESTROY} Emitted right before shape is destroyed\n * Event object contains created shape [SmartShape](#SmartShape) object in a `target` field\n * @enum {string}\n */\nexport const RotateBoxEvents = {\n    ROTATE_BOX_ROTATE: \"rotate\"\n};\n\nexport default RotateBoxEventListener;\n","import EventsManager from \"../events/EventsManager.js\";\nimport {PointEvents} from \"../SmartPoint/SmartPoint.js\";\nimport {ShapeEvents} from \"../SmartShape/SmartShapeEventListener.js\";\nimport {uuid} from \"../utils\";\nimport {createEvent} from \"../events/functions.js\";\n\n/**\n * Internal helper class, that contains all event listening logic for the ResizeBox.\n * This class should not be used directly. Each ResizeBox creates an instance of\n * this class automatically during init process\n * @param resizeBox {ResizeBox} Link to owner Shape instance\n * @constructor\n */\nfunction ResizeBoxEventListener(resizeBox) {\n\n    /**\n     * @ignore\n     * Underlying resizeBox that managed by this event listener\n     * @type {ResizeBox}\n     */\n    this.resizeBox = resizeBox;\n\n    /**\n     * @ignore\n     * List of subscribers, that subscribed to events, emitted by\n     * this ResizeBox. This is an object, that consists of array\n     * of event handlers of each event. Each handler is a function\n     * that called when event of specified type emitted by\n     * this ResizeBox\n     * @type {object}\n     */\n    this.subscriptions = {\n        \"resize\": []\n    }\n\n    this.guid = uuid();\n\n    this.shapeEventListeners = {};\n\n    /**\n     * @ignore\n     * Initializes and starts this event listener\n     * @returns {ResizeBoxEventListener}\n     */\n    this.run = () => {\n        this.setEventListeners();\n        return this;\n    }\n\n    /**\n     * @ignore\n     * Setup event handlers for different events, to this resize box\n     * should react.\n     */\n    this.setEventListeners = () => {\n        EventsManager.subscribe(PointEvents.POINT_DRAG_MOVE, this.onPointDragMove);\n        EventsManager.subscribe(PointEvents.POINT_DRAG_END, this.onPointDragMove);\n        ShapeEvents.getShapeMouseEvents().forEach(item => {\n            this.shapeEventListeners[item.name] = this.resizeBox.shape.addEventListener(item.name,(event) => {\n                EventsManager.emit(item.name,this.resizeBox,event);\n            });\n        })\n    }\n\n    /**\n     * @ignore\n     * Event handler, that used to react to events, when user drag marker points of\n     * ResizeBox.\n     * This handler used to automatically adjusts coordinates of other marker points,\n     * based on changes from current point, that generated this event.\n     * Also, this method emits \"resize\" event, that can be intercepted by other\n     * objects, subscribed to ResizeBox events. For example, [SmartShape](#SmartShape)\n     * reacts on it to scale itself when dimensions of ResizeBox changed.\n     * @param event {object} Event object, that contains pointer to [SmartPoint](#SmartPoint) that\n     * emitted it.\n     */\n    this.onPointDragMove = (event) => {\n        if (!this.resizeBox.shape.isShapePoint(event.target)) {\n            return\n        }\n        switch (event.target) {\n            case this.resizeBox.left_top:\n                this.onLeftTopDragMove(event);\n                break;\n            case this.resizeBox.center_top:\n                this.onCenterTopDragMove(event);\n                break;\n            case this.resizeBox.right_top:\n                this.onRightTopDragMove(event);\n                break;\n            case this.resizeBox.right_center:\n                this.onRightCenterDragMove(event);\n                break;\n            case this.resizeBox.right_bottom:\n                this.onRightBottomDragMove(event);\n                break;\n            case this.resizeBox.center_bottom:\n                this.onCenterBottomDragMove(event);\n                break;\n            case this.resizeBox.left_bottom:\n                this.onLeftBottomDragMove(event);\n                break;\n            case this.resizeBox.left_center:\n                this.onLeftCenterDragMove(event);\n                break;\n        }\n        this.resizeBox.adjustCenters();\n        this.resizeBox.setPointsMoveBounds();\n        const oldPos = this.resizeBox.getPosition();\n        this.resizeBox.calcPosition();\n        const newPos = this.resizeBox.getPosition();\n        this.resizeBox.redraw();\n        EventsManager.emit(ShapeEvents.POINT_DRAG_END,this.resizeBox,createEvent(event,{point:event.target}));\n        EventsManager.emit(ResizeBoxEvents.RESIZE_BOX_RESIZE,this.resizeBox,createEvent(event,{oldPos,newPos}));\n    }\n\n    /**\n     * @ignore\n     * Event handler that triggered when change position of left top marker point.\n     * @param event {object} Event object, that contains pointer to [SmartPoint](#SmartPoint) that\n     * emitted it.\n     */\n    this.onLeftTopDragMove = (event) => {\n        this.resizeBox.left_center.x = event.target.x;\n        this.resizeBox.left_bottom.x = event.target.x;\n        this.resizeBox.center_top.y = event.target.y;\n        this.resizeBox.right_top.y = event.target.y;\n    }\n\n    /**\n     * @ignore\n     * Event handler that triggered when change position of center top marker point.\n     * @param event {object} Event object, that contains pointer to [SmartPoint](#SmartPoint) that\n     * emitted it.\n     */\n    this.onCenterTopDragMove = (event) => {\n        this.resizeBox.left_top.y = event.target.y;\n        this.resizeBox.right_top.y = event.target.y;\n    }\n\n    /**\n     * @ignore\n     * Event handler that triggered when change position of right top marker point.\n     * @param event {object} Event object, that contains pointer to [SmartPoint](#SmartPoint) that\n     * emitted it.\n     */\n    this.onRightTopDragMove = (event) => {\n        this.resizeBox.left_top.y = event.target.y;\n        this.resizeBox.center_top.y = event.target.y;\n        this.resizeBox.right_center.x = event.target.x;\n        this.resizeBox.right_bottom.x = event.target.x;\n    }\n\n    /**\n     * @ignore\n     * Event handler that triggered when change position of right center marker point.\n     * @param event {object} Event object, that contains pointer to [SmartPoint](#SmartPoint) that\n     * emitted it.\n     */\n    this.onRightCenterDragMove = (event) => {\n        this.resizeBox.right_top.x = event.target.x;\n        this.resizeBox.right_bottom.x = event.target.x;\n    }\n\n    /**\n     * @ignore\n     * Event handler that triggered when change position of right bottom marker point.\n     * @param event {object} Event object, that contains pointer to [SmartPoint](#SmartPoint) that\n     * emitted it.\n     */\n    this.onRightBottomDragMove = (event) => {\n        this.resizeBox.right_top.x = event.target.x;\n        this.resizeBox.right_center.x = event.target.x;\n        this.resizeBox.left_bottom.y = event.target.y;\n        this.resizeBox.center_bottom.y = event.target.y;\n    }\n\n    /**\n     * @ignore\n     * Event handler that triggered when change position of center bottom marker point.\n     * @param event {object} Event object, that contains pointer to [SmartPoint](#SmartPoint) that\n     * emitted it.\n     */\n    this.onCenterBottomDragMove = (event) => {\n        this.resizeBox.left_bottom.y = event.target.y;\n        this.resizeBox.right_bottom.y = event.target.y;\n    }\n\n    /**\n     * @ignore\n     * Event handler that triggered when change position of left bottom marker point.\n     * @param event {object} Event object, that contains pointer to [SmartPoint](#SmartPoint) that\n     * emitted it.\n     */\n    this.onLeftBottomDragMove = (event) => {\n        this.resizeBox.center_bottom.y = event.target.y;\n        this.resizeBox.right_bottom.y = event.target.y;\n        this.resizeBox.left_center.x = event.target.x;\n        this.resizeBox.left_top.x = event.target.x;\n    }\n\n    /**\n     * @ignore\n     * Event handler that triggered when change position of left center marker point.\n     * @param event {object} Event object, that contains pointer to [SmartPoint](#SmartPoint) that\n     * emitted it.\n     */\n    this.onLeftCenterDragMove = (event) => {\n        this.resizeBox.left_bottom.x = event.target.x;\n        this.resizeBox.left_top.x = event.target.x;\n    }\n\n    /**\n     * @ignore\n     * Uniform method that used to add event handler of specified type to this object.\n     * ResizeBox can emit events, defined in [ResizeBoxEvents](#ResizeBoxEvents) enumeration. So, you can\n     * listen any of these events.\n     * @param eventName {string} - Name of event. Use one of names, defined in [ResizeBoxEvents](#ResizeBoxEvents)\n     * @param handler {function} - Function that used as an event handler\n     * @returns {function} - Pointer to added event handler. Should be used to remove event listener later.\n     */\n    this.addEventListener = (eventName,handler) => {\n        if (typeof(this.subscriptions[eventName]) === \"undefined\") {\n            this.subscriptions[eventName] = [];\n        }\n        const listener = EventsManager.subscribe(eventName, (event) => {\n            if (event.target && event.target.guid && event.target.guid === this.resizeBox.guid) {\n                handler(event)\n            }\n        });\n        this.subscriptions[eventName].push(listener);\n        return listener;\n    }\n\n    /**\n     * @ignore\n     * Uniform method that used to remove event handler, that previously added\n     * to this object.\n     * @param eventName {ResizeBoxEvents|string} Name of event to remove listener from\n     * @param listener {function} Pointer to event listener, that added previously.\n     * It was returned from [addEventListener](#ResizeBox+addEventListener) method.\n     */\n    this.removeEventListener = (eventName,listener) => {\n        if (this.subscriptions[eventName] && typeof(this.subscriptions[eventName]) !== \"undefined\") {\n            this.subscriptions[eventName].splice(this.subscriptions[eventName].indexOf(listener), 1);\n        }\n        EventsManager.unsubscribe(eventName,listener)\n    }\n\n    /**\n     * @ignore\n     * Method used to destroy the object. Removes all event subscriptions.\n     */\n    this.destroy = () => {\n        for (let eventName in this.subscriptions) {\n            const handlers = this.subscriptions[eventName];\n            handlers.forEach(handler => EventsManager.unsubscribe(eventName,handler));\n            this.subscriptions[eventName] = [];\n        }\n        Object.keys(this.shapeEventListeners).forEach(\n            key => {\n                this.resizeBox.removeEventListener(key, this.shapeEventListeners[key])\n            }\n        )\n        EventsManager.unsubscribe(PointEvents.POINT_DRAG_MOVE,this.onPointDragMove);\n        EventsManager.unsubscribe(PointEvents.POINT_DRAG_END,this.onPointDragMove);\n    }\n}\n\nexport default ResizeBoxEventListener;\n\n/**\n * Enumeration that defines events, that ResizeBox can emit.\n * @param resize {ResizeBoxEvents.RESIZE_BOX_RESIZE} Emitted when user resized the shape by dragging one of marker points.\n * Event object includes fields `oldPos` and\n * `newPos` which are positions of shape before and after resizing.\n * Position is an object with following fields \"left,top,right,bottom,width,height\"\n * @param create {ShapeEvents.SHAPE_CREATE} Emitted right after shape is created and initialized.\n * Event object contains created shape [SmartShape](#SmartShape) object in a `target` field\n * @param move_start {MouseEvent} Emitted when user presses left mouse button on shape to start dragging.\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) mousedown object with additional\n * field `pos`, which is a position of shape when movement started.\n * Position is an object with following fields \"left,top,right,bottom,width,height\"\n * @param move {MouseEvent} Emitted when user drags shape.\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) mousemove object, but also\n * includes additional properties `oldPos` - shape position before previous movement. `newPos` - shape position after\n * previous movement. Position is an object with following fields \"left,top,right,bottom,width,height\"\n * @param move_end {MouseEvent}  Emitted when user releases mouse button to stop drag the shape.\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) mouseup object with additional\n * field `pos`, which is a position of shape when movement started.\n * Position is an object with following fields \"left,top,right,bottom,width,height\"\n * @param mousemove {MouseEvent} Emitted when user moves mouse over shape\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) mousemove object\n * @param mouseover {MouseEvent} Emitted when mouse cursor goes inside shape\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) mouseover object\n * @param mouseout {MouseEvent} Emitted when mouse cursor goes away from shape\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) mouseout object\n * @param click {MouseEvent} Emitted when click on shape\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) click object\n * @param dblclick {MouseEvent} Emitted when double-click on shape\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) dblclick object\n * @param point_drag_start {MouseEvent} Emitted when user starts dragging one of shape's point. Event Includes `point` field.\n * It is a [SmartPoint](#SmartPoint) object.\n * @param point_drag_move {MouseEvent} Emitted when user dragging one of shape's point. Event Includes `point` field.\n * It is a [SmartPoint](#SmartPoint) object.\n * @param point_drag_end {MouseEvent} Emitted when user finishes dragging one of shape's point. Event Includes `point` field.\n * It is a [SmartPoint](#SmartPoint) object.\n * @param destroy {ShapeEvents.SHAPE_DESTROY} Emitted right before shape is destroyed\n * Event object contains created shape [SmartShape](#SmartShape) object in a `target` field\n * @enum {string}\n */\nexport const ResizeBoxEvents = {\n    RESIZE_BOX_RESIZE: \"resize\"\n};\n","import SmartShapeManager from \"../SmartShapeManager/SmartShapeManager.js\";\nimport EventsManager from \"../events/EventsManager.js\";\nimport {getOffset, pauseEvent} from \"../utils\";\nimport {PointEvents} from \"../SmartPoint/SmartPoint.js\";\nimport {RotateBoxEvents} from \"../RotateBox/RotateBoxEventListener.js\";\nimport {ResizeBoxEvents} from \"../ResizeBox/ResizeBoxEventListener.js\";\nimport {createEvent} from \"../events/functions.js\";\n\n/**\n * Internal helper class, that contains all event listening logic for the shape.\n * This class should not be used directly. Each shape creates an instance of\n * this class automatically during init process\n * @param shape {SmartShape} Link to owner Shape instance\n * @constructor\n */\nfunction SmartShapeEventListener(shape) {\n\n    /**\n     * @ignore\n     * Link to owner shape instance\n     * @type {SmartShape}\n     */\n    this.shape = shape;\n\n    /**\n     * @ignore\n     * List of subscribers, that subscribed to events, emitted by\n     * this shape. This is an object, that consists of array\n     * of event handlers of each event. Each handler is a function\n     * that called when event of specified type emitted by\n     * this shape\n     * @type {object}\n     */\n    this.subscriptions = {\n        \"CONTAINER_BOUNDS_CHANGED\": []\n    }\n\n    /**\n     * @ignore\n     * Method binds events to the shape and returns itself\n     * @returns {SmartShapeEventListener}\n     */\n    this.run = () => {\n        this.shape = shape;\n        this.setEventListeners();\n        return this;\n    }\n\n    /**\n     * @ignore\n     * Internal method that installs HTML DOM event listeners to the shape, and it's container\n     */\n    this.setEventListeners = () => {\n        EventsManager.subscribe(PointEvents.POINT_DESTROYED, this.onPointDestroyed);\n        EventsManager.subscribe(PointEvents.POINT_ADDED, this.onPointAdded);\n        EventsManager.subscribe(PointEvents.POINT_DRAG_MOVE, this.onPointDragMove);\n        EventsManager.subscribe(PointEvents.POINT_DELETE_REQUEST, this.onPointDeleteRequest);\n        EventsManager.subscribe(ShapeEvents.SHAPE_ADD_CHILD,() => {\n            this.shape.redraw();\n        })\n    }\n\n    this.setSvgEventListeners = () => {\n        this.svg_mouseover = this.shape.svg.addEventListener(\"mouseover\", (event) => {\n            SmartShapeManager.mouseover(createEvent(event,{target:this.shape}));\n        });\n        this.svg_mouseout = this.shape.svg.addEventListener(\"mouseout\", (event) => {\n            SmartShapeManager.mouseout(createEvent(event,{target:this.shape}));\n        });\n        this.svg_mouseenter = this.shape.svg.addEventListener(\"mouseenter\", (event) => {\n            SmartShapeManager.mouseenter(createEvent(event,{target:this.shape}));\n        });\n        this.svg_mousedown = this.shape.svg.addEventListener(\"mousedown\", (event) => {\n            SmartShapeManager.mousedown(createEvent(event,{target:this.shape}));\n        });\n        this.svg_click = this.shape.svg.addEventListener(\"click\", (event) => {\n           SmartShapeManager.click(createEvent(event,{target:this.shape}));\n        });\n        this.svg_dblclick = this.shape.svg.addEventListener(\"dblclick\", (event) => {\n            SmartShapeManager.doubleclick(createEvent(event,{target:this.shape}))\n        });\n        this.svg_wheel = this.shape.svg.addEventListener(\"wheel\", (event) => {\n            this.wheel(event);\n        })\n    }\n\n    this.removeSvgEventListeners = () => {\n        this.shape.svg.removeEventListener(\"mouseover\", this.svg_mouseover);\n        this.shape.svg.removeEventListener(\"mouseout\", this.svg_mouseout);\n        this.shape.svg.removeEventListener(\"mouseenter\", this.svg_mouseenter);\n        this.shape.svg.removeEventListener(\"mousedown\",this.svg_mousedown);\n        this.shape.svg.removeEventListener(\"click\",this.svg_click);\n        this.shape.svg.removeEventListener(\"dblclick\",this.svg_dblclick);\n        this.shape.svg.removeEventListener(\"wheel\",this.svg_wheel);\n    }\n    /**\n     * @ignore\n     * Method adds event listeners to ResizeBox, connected to it to react on them. So, the shape can change itself\n     * when some event comes from ResizeBox: when user resizes ResizeBox, it emits \"resize\" event. Then the shape\n     * receives this event in this method and scales the shape according to new coordinates\n     * of the resize box\n     * Also, shape intercepts other events of ResizeBox, connected to it like \"mouseover\",\n     * \"mousemove\" or \"click\".\n     */\n    this.addResizeEventListener = () => {\n        if (!this.shape.resizeBox) {\n            return;\n        }\n        this.resizeBoxListener = this.shape.resizeBox.addEventListener(ResizeBoxEvents.RESIZE_BOX_RESIZE, this.onResize);\n        this.resizeMouseDownEventListener = this.shape.resizeBox.addEventListener(ShapeEvents.SHAPE_MOVE_START, this.mousedown);\n        this.resizeMouseMoveEventListener = this.shape.resizeBox.addEventListener(ShapeEvents.SHAPE_MOUSE_MOVE, this.mousemove);\n        this.resizeClickEventListener = this.shape.resizeBox.addEventListener(ShapeEvents.SHAPE_MOUSE_CLICK, this.click);\n        this.resizeDblClickEventListener = this.shape.resizeBox.addEventListener(ShapeEvents.SHAPE_MOUSE_DOUBLE_CLICK, this.svg_dblclick);\n        this.resizeMouseDownEventListener = this.shape.resizeBox.addEventListener(ShapeEvents.SHAPE_MOUSE_DOWN, this.svg_mousedown);\n        this.resizeMouseOverEventListener = this.shape.resizeBox.addEventListener(ShapeEvents.SHAPE_MOUSE_OVER, this.svg_mouseover);\n        this.resizeMouseOutEventListener = this.shape.resizeBox.addEventListener(ShapeEvents.SHAPE_MOUSE_OUT, this.svg_mouseout);\n        this.resizeMouseUpEventListener = this.shape.resizeBox.addEventListener(ShapeEvents.SHAPE_MOUSE_UP, (event) => {\n            EventsManager.emit(ShapeEvents.SHAPE_MOUSE_UP,this.shape,createEvent(event))\n        });\n        this.resizeBoxContextMenuEventListener = this.shape.resizeBox.shape.svg.addEventListener(\"contextmenu\", (event) => {\n            if (this.shape.contextMenu) {\n                this.shape.contextMenu.onEvent(event);\n            }\n        })\n        this.resizeBoxWheelEventListener = this.shape.resizeBox.shape.svg.addEventListener(\"wheel\", (event) => {\n            this.wheel(event);\n        })\n    }\n\n    /**\n     * @ignore\n     * Method adds event listeners to RotateBox, connected to it to react on them. So, the shape can change itself\n     * when some event comes from RotateBox: when user rotates RotateBox, it emits \"rotate\" event and the shape\n     * intercepts this event in this method. The `event` object, that RotateBox emits contains `angle` parameter\n     * that can be used. As a reaction to the event, listening function rotates the shape according to the angle,\n     * received from the event of rotate box.\n     * Also, shape intercepts other events of RotateBox, connected to it, like \"mouseover\",\n     * \"mousemove\" or \"click\".\n     */\n    this.addRotateEventListener = () => {\n        if (!this.shape.rotateBox) {\n            return;\n        }\n        this.rotateBoxListener = this.shape.rotateBox.addEventListener(RotateBoxEvents.ROTATE_BOX_ROTATE, this.onRotate);\n        this.rotateMouseDownEventListener = this.shape.rotateBox.addEventListener(ShapeEvents.SHAPE_MOVE_START, this.mousedown);\n        this.rotateMouseMoveEventListener = this.shape.rotateBox.addEventListener(ShapeEvents.SHAPE_MOUSE_MOVE, this.mousemove);\n        this.rotateClickEventListener = this.shape.rotateBox.addEventListener(ShapeEvents.SHAPE_MOUSE_CLICK, this.click)\n        this.rotateDblClickEventListener = this.shape.rotateBox.addEventListener(ShapeEvents.SHAPE_MOUSE_DOUBLE_CLICK, this.svg_dblclick);\n        this.rotateMouseDownEventListener = this.shape.rotateBox.addEventListener(ShapeEvents.SHAPE_MOUSE_DOWN, this.svg_mousedown);\n        this.rotateMouseUpEventListener = this.shape.rotateBox.addEventListener(ShapeEvents.SHAPE_MOUSE_UP, (event) => {\n            EventsManager.emit(ShapeEvents.SHAPE_MOUSE_UP,this.shape,createEvent(event))\n        });\n        this.rotateMouseOverEventListener = this.shape.rotateBox.addEventListener(ShapeEvents.SHAPE_MOUSE_OVER, this.svg_mouseover);\n        this.rotateMouseOutEventListener = this.shape.rotateBox.addEventListener(ShapeEvents.SHAPE_MOUSE_OUT, this.svg_mouseout);\n        this.rotatePointDragStartEventListener = this.shape.rotateBox.addEventListener(ShapeEvents.POINT_DRAG_START, (_event) => {\n            this.shape.initCenter = this.shape.getCenter(this.shape.options.groupChildShapes);\n        })\n        this.rotatePointDragEndEventListener = this.shape.rotateBox.addEventListener(ShapeEvents.POINT_DRAG_END, (_event) => {\n            this.shape.initCenter = null;\n            this.shape.points.filter(point=>point.options).forEach(point=> {\n                if (!point.options.hidden && point.element) {\n                    point.element.style.display = '';\n                }\n            })\n        })\n        this.rotateBoxContextMenuEventListener = this.shape.rotateBox.shape.svg.addEventListener(\"contextmenu\", (event) => {\n            if (this.shape.contextMenu) {\n                this.shape.contextMenu.onEvent(event);\n            }\n        })\n        this.rotateBoxWheelEventListener = this.shape.rotateBox.shape.svg.addEventListener(\"wheel\", (event) => {\n            this.wheel(event);\n        })\n    }\n\n    this.onResize = (event) => {\n        const parent = this.shape.getRootParent(true);\n        if (parent) {\n            EventsManager.emit(ResizeBoxEvents.RESIZE_BOX_RESIZE,parent.resizeBox,createEvent(event,\n                {newPos:event.newPos,oldPos:event.oldPos})\n            );\n            return\n        }\n        if (event.buttons && this.shape.options.simpleMode) {\n            return\n        }\n        const diffX = event.newPos.left - event.oldPos.left;\n        const diffY = event.newPos.top - event.oldPos.top;\n        this.shape.moveBy(diffX,diffY,false);\n        const [pointWidth,pointHeight] = this.shape.getMaxPointSize();\n        this.shape.scaleTo(event.newPos.width-(pointWidth)*2,event.newPos.height-(pointHeight)*2);\n        this.shape.redraw();\n        EventsManager.emit(ResizeBoxEvents.RESIZE_BOX_RESIZE,this.shape,event);\n    }\n\n    this.onRotate = (event) => {\n        const parent = this.shape.getRootParent(true);\n        if (parent) {\n            EventsManager.emit(RotateBoxEvents.ROTATE_BOX_ROTATE,parent.rotateBox,{angle:event.angle});\n            return\n        }\n        this.shape.rotateBy(event.angle);\n        this.shape.redraw()\n        EventsManager.emit(RotateBoxEvents.ROTATE_BOX_ROTATE,this.shape,event);\n    }\n\n    /**\n     * @ignore\n     * onMouseDown event handler, triggered when user presses mouse button on the shape or on container element.\n     * @param event {MouseEvent} Event object\n     */\n    this.mousedown = (event) => {\n        pauseEvent(event);\n        EventsManager.emit(ShapeEvents.SHAPE_MOUSE_DOWN,this.shape,createEvent(event));\n        setTimeout(() => {\n            EventsManager.emit(ShapeEvents.SHAPE_MOVE_START,\n                this.shape, createEvent(event,{pos:this.shape.getPosition(this.shape.options.groupChildShapes)}))\n        },100);\n    }\n\n    /**\n     * @ignore\n     * onMouseMove event handler, triggered when user moves mouse over the shape or container element.\n     * @param event {MouseEvent} Event object\n     */\n    this.mousemove = (event) => {\n        if (!this.shape.draggedPoint) {\n            EventsManager.emit(ShapeEvents.SHAPE_MOUSE_MOVE, this.shape, createEvent(event));\n        }\n        if (event.buttons !== 1) {\n            return\n        }\n        if (this.shape.draggedPoint) {\n            EventsManager.emit(ShapeEvents.POINT_DRAG_MOVE,this.shape,{point:this.shape.draggedPoint});\n            this.shape.draggedPoint.mousemove(event);\n            return\n        }\n        if (!this.shape.options.canDragShape) {\n            return\n        }\n        const [stepX, stepY] = this.calcMovementOffset(event);\n        if (stepX === null || stepY === null) {\n            return\n        }\n        const oldPos = this.shape.getPosition(this.shape.options.groupChildShapes);\n        this.shape.moveBy(stepX,stepY,true,this.shape.options.simpleMode);\n        if (!this.shape.options.simpleMode) {\n            this.shape.redraw();\n        }\n        const newPos = this.shape.getPosition(this.shape.options.groupChildShapes);\n        EventsManager.emit(ShapeEvents.SHAPE_MOVE,this.shape,createEvent(event,{oldPos,newPos}));\n    }\n\n    /**\n     * @ignore\n     * onMouseEnter event handler, triggered when mouse cursor enters shape's container element\n     * @param event {MouseEvent} Event object\n     */\n    this.mouseenter = (event) => {\n        EventsManager.emit(ShapeEvents.SHAPE_MOUSE_ENTER, this.shape, createEvent(event));\n    }\n\n    /**\n     * @ignore\n     * onMouseOver event handler, triggered when user moves mouse over the shape.\n     * @param event {MouseEvent} Event object\n     */\n    this.mouseover = (event) => {\n        if (SmartShapeManager.draggedShape === this.shape) {\n            return\n        }\n        EventsManager.emit(ShapeEvents.SHAPE_MOUSE_OVER,this.shape,createEvent(event));\n    }\n\n    /**\n     * @ignore\n     * onMouseOut event handler, triggered when user moves mouse away from shape.\n     * @param event {MouseEvent} Event object\n     */\n    this.mouseout = (event) => {\n        EventsManager.emit(ShapeEvents.SHAPE_MOUSE_OUT,this.shape,createEvent(event));\n    }\n\n    /**\n     * @ignore\n     * onClick event handler, triggered when user clicks on shape\n     * @param event {MouseEvent} Event object\n     */\n    this.click = (event) => {\n        EventsManager.emit(ShapeEvents.SHAPE_MOUSE_CLICK, this.shape, createEvent(event));\n    }\n\n    /**\n     * @ignore\n     * onDblClick event handler, triggered when user double-clicks on shape\n     * @param event {MouseEvent} Event object\n     */\n    this.doubleclick = (event) => {\n        EventsManager.emit(ShapeEvents.SHAPE_MOUSE_DOUBLE_CLICK, this.shape, createEvent(event));\n    }\n\n    /**\n     * @ignore\n     * Mouse wheel event handler. Zooms in or out the shape if it zoomable\n     * @param event {MouseEvent} Event object\n     */\n    this.wheel = (event) => {\n        if (this.shape.options.zoomable && this.shape.options.id.search(\"_resizebox\") === -1 &&\n            this.shape.options.id.search(\"_rotatebox\") === -1) {\n            if (event.deltaY < 0) {\n                this.shape.zoomBy(1+this.shape.options.zoomStep);\n            } else {\n                this.shape.zoomBy(1-this.shape.options.zoomStep);\n            }\n            this.shape.redraw();\n        }\n    }\n\n    /**\n     * @ignore\n     * Internal method that used to calculate to which amount of pixels the shape should be moved when dragging it,\n     * depending on position of mouse cursor and bounds of container element.\n     * @param event {MouseEvent} event object\n     * @returns {array} Returns object with [x,y] coordinates or [null,null]\n     * if impossible to move (out of container bounds)\n     */\n    this.calcMovementOffset = (event) => {\n        this.shape.calcPosition();\n        const pos = this.shape.getPosition(this.shape.options.groupChildShapes);\n        let stepX = event.movementX;\n        let stepY = event.movementY;\n        let clientX = event.clientX+window.scrollX;\n        let clientY = event.clientY+window.scrollY;\n        const newX = pos.left + stepX;\n        const newY = pos.top + stepY;\n        const offset = getOffset(this.shape.root, true);\n        const bounds = this.shape.getBounds();\n        if (newX < bounds.left || newX+pos.width > bounds.right) {\n            stepX = 0;\n        }\n        if (newY < bounds.top || newY+pos.height > bounds.bottom) {\n            stepY = 0;\n        }\n        if (clientX<newX+offset.left) {\n            stepX = clientX - (newX+offset.left);\n        }\n        if (clientY<newY+offset.top) {\n            stepY = clientY - (newY+offset.top);\n        }\n        if (clientX>newX+pos.width+offset.left) {\n            stepX = clientX -  (pos.width+offset.left+pos.left);\n        }\n        if (clientY>newY+pos.height+offset.right) {\n            stepY = clientY -  (pos.height+offset.top+pos.top);\n        }\n        return [stepX, stepY];\n    }\n\n    /**\n     * @ignore\n     * Internal method, that triggered when new point added\n     * @param event Custom event object\n     */\n    this.onPointAdded = (event) => {\n        if (!this.shape.isShapePoint(event.target)) {\n            return\n        }\n        if (event.target.element) {\n            try {\n                this.shape.root.appendChild(event.target.element)\n            } catch (err) {}\n        }\n        EventsManager.emit(ShapeEvents.POINT_ADDED,this.shape,{point:event.target});\n    }\n\n\n    /**\n     * @ignore\n     * Internal method, that triggered when user drags the point\n     * @param event Custom event object. Contains SmartPoint object as an `event.target`,\n     * `event.oldX` and `event.oldY` as a previous point coordinates before previous drag event.\n     */\n    this.onPointDragMove = (event) => {\n        if (this.shape.isShapePoint(event.target)) {\n            this.shape.updatePosition(event.target.x,event.target.y);\n            this.shape.redraw();\n        }\n    }\n\n    /**\n     * @ignore\n     * Internal method, that triggered when point is destroyed\n     * @param event Custom event object. Contains SmartPoint object as an event.target\n     **/\n    this.onPointDestroyed = (event) => {\n        if (!this.shape.isShapePoint(event.target)) {\n            return\n        }\n        this.shape.points.splice(this.shape.points.indexOf(event.target), 1);\n        try {\n            this.shape.root.removeChild(event.target.element);\n            this.shape.redraw()\n        } catch (err) {}\n        EventsManager.emit(ShapeEvents.POINT_DESTROYED,this.shape,{point:event.target});\n    }\n\n    /**\n     * @ignore\n     * Internal method that triggered when request to delete point of shape arroved\n     * @param event Custom event object. Contains SmartPoint object as an event.target\n     */\n    this.onPointDeleteRequest = (event) => {\n        if (!this.shape.isShapePoint(event.target)) {\n            return\n        }\n        this.shape.deletePoint(event.target.x,event.target.y);\n    }\n\n    /**\n     * @ignore\n     * Uniform method that used to add event handler of specified type to this object.\n     * @param eventName {string} Name of event\n     * @param handler {function} Function that used as an event handler\n     * @returns {function} Pointer to added event handler. Should be used to remove event listener later.\n     */\n    this.addEventListener = (eventName,handler) => {\n        if (typeof(this.subscriptions[eventName]) === \"undefined\") {\n            this.subscriptions[eventName] = [];\n        }\n        const listener = EventsManager.subscribe(eventName, (event) => {\n            if (event.target && event.target.guid === this.shape.guid) {\n                handler(event)\n            }\n        });\n        this.subscriptions[eventName].push(listener);\n        return listener;\n    }\n\n    /**\n     * @ignore\n     * Uniform method that used to remove event handler, that previously added\n     * to this object.\n     * @param eventName {string} Name of event to remove listener from\n     * @param listener {function} Pointer to event listener, that added previously.\n     * It was returned from [addEventListener](#ResizeBox+addEventListener) method.\n     */\n    this.removeEventListener = (eventName,listener) => {\n        if (this.subscriptions[eventName] && typeof(this.subscriptions[eventName]) !== \"undefined\") {\n            this.subscriptions[eventName].splice(this.subscriptions[eventName].indexOf(listener), 1);\n        }\n        EventsManager.unsubscribe(eventName,listener)\n    }\n\n    /**\n     * @ignore\n     * Used to remove all event listeners when destroy the object\n     */\n    this.destroy = () => {\n        EventsManager.unsubscribe(PointEvents.POINT_ADDED, this.onPointAdded);\n        EventsManager.unsubscribe(PointEvents.POINT_DRAG_MOVE, this.onPointDragMove);\n        EventsManager.unsubscribe(PointEvents.POINT_DESTROYED, this.onPointDestroyed);\n        EventsManager.unsubscribe(PointEvents.POINT_DELETE_REQUEST, this.onPointDeleteRequest);\n        if (this.shape.resizeBox) {\n            this.shape.resizeBox.removeEventListener(ResizeBoxEvents.RESIZE_BOX_RESIZE,this.resizeBoxListener);\n            this.shape.resizeBox.removeEventListener(ShapeEvents.SHAPE_MOUSE_CLICK,this.resizeClickEventListener);\n            this.shape.resizeBox.removeEventListener(ShapeEvents.SHAPE_MOUSE_MOVE,this.resizeMouseMoveEventListener);\n            this.shape.resizeBox.removeEventListener(ShapeEvents.SHAPE_MOVE_START,this.resizeMouseDownEventListener);\n            this.shape.resizeBox.removeEventListener(ShapeEvents.SHAPE_MOUSE_UP,this.resizeMouseUpEventListener);\n            this.shape.resizeBox.removeEventListener(ShapeEvents.SHAPE_MOUSE_DOUBLE_CLICK,this.resizeDblClickEventListener);\n            this.shape.resizeBox.removeEventListener(ShapeEvents.SHAPE_MOUSE_OVER,this.resizeMouseOverEventListener);\n            this.shape.resizeBox.removeEventListener(ShapeEvents.SHAPE_MOUSE_OUT,this.resizeMouseOutEventListener);\n            this.shape.resizeBox.removeEventListener(\"contextmenu\",this.resizeBoxContextMenuEventListener);\n            this.shape.resizeBox.removeEventListener(\"wheel\", this.resizeBoxWheelEventListener);\n        }\n        if (this.shape.rotateBox) {\n            this.shape.rotateBox.removeEventListener(RotateBoxEvents.ROTATE_BOX_ROTATE,this.rotateBoxListener);\n            this.shape.rotateBox.removeEventListener(ShapeEvents.SHAPE_MOUSE_CLICK,this.rotateClickEventListener);\n            this.shape.rotateBox.removeEventListener(ShapeEvents.SHAPE_MOUSE_MOVE,this.rotateMouseMoveEventListener);\n            this.shape.rotateBox.removeEventListener(ShapeEvents.SHAPE_MOVE_START,this.rotateMouseDownEventListener);\n            this.shape.rotateBox.removeEventListener(ShapeEvents.SHAPE_MOVE_START,this.rotatePointDragStartEventListener);\n            this.shape.rotateBox.removeEventListener(ShapeEvents.SHAPE_MOVE_START,this.rotatePointDragEndEventListener);\n            this.shape.rotateBox.removeEventListener(ShapeEvents.SHAPE_MOUSE_UP,this.rotateMouseUpEventListener);\n            this.shape.rotateBox.removeEventListener(ShapeEvents.SHAPE_MOUSE_DOUBLE_CLICK,this.rotateDblClickEventListener);\n            this.shape.rotateBox.removeEventListener(ShapeEvents.SHAPE_MOUSE_OVER,this.rotateMouseOverEventListener);\n            this.shape.rotateBox.removeEventListener(ShapeEvents.SHAPE_MOUSE_OUT,this.rotateMouseOutEventListener);\n            this.shape.rotateBox.removeEventListener(\"contextmenu\",this.rotateBoxContextMenuEventListener);\n            this.shape.rotateBox.removeEventListener(\"wheel\", this.rotateBoxWheelEventListener);\n        }\n        for (let eventName in this.subscriptions) {\n            const handlers = this.subscriptions[eventName];\n            handlers.forEach(handler => EventsManager.unsubscribe(eventName,handler));\n            this.subscriptions[eventName] = [];\n        }\n    }\n}\n\n/**\n * Enumeration of event names, that can be emitted by [SmartShape](#SmartShape) object.\n * @param create {ShapeEvents.SHAPE_CREATE} Emitted right after shape is created and initialized.\n * Event object contains created shape [SmartShape](#SmartShape) object in a `target` field\n * @param move_start {MouseEvent} Emitted when user presses left mouse button on shape to start dragging.\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) mousedown object with additional\n * field `pos`, which is a position of shape when movement started.\n * Position is an object with following fields \"left,top,right,bottom,width,height\"\n * @param move {MouseEvent} Emitted when user drags shape.\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) mousemove object, but also\n * includes additional properties `oldPos` - shape position before previous movement. `newPos` - shape position after\n * previous movement. Position is an object with following fields \"left,top,right,bottom,width,height\"\n * @param move_end {MouseEvent} Emitted when user releases mouse button to stop drag the shape.\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) mouseup object with additional\n * field `pos`, which is a position of shape when movement started.\n * Position is an object with following fields \"left,top,right,bottom,width,height\"\n * @param mousemove {MouseEvent} Emitted when user moves mouse over shape\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) mousemove object\n * @param mouseover {MouseEvent} Emitted when mouse cursor goes inside shape\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) mouseover object\n * @param mouseout {MouseEvent} Emitted when mouse cursor goes away from shape\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) mouseout object\n * @param click {MouseEvent} Emitted when click on shape\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) click object\n * @param dblclick {MouseEvent} Emitted when double-click on shape\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) dblclick object\n * @param resize {ResizeBoxEvents.RESIZE_BOX_RESIZE} Emitted when user resized the shape using resize box. Event object includes fields `oldPos` and\n * `newPos` which are positions of shape before and after resizing.\n * Position is an object with following fields \"left,top,right,bottom,width,height\"\n * @param rotate {RotateBoxEvents.ROTATE_BOX_ROTATE} Emitted when user rotated the shape using rotate box Event object includes the `angle` field,\n * which is a rotation angle.\n * Position is an object with following fields \"left,top,right,bottom,width,height\"\n * @param point_drag_start {MouseEvent} Emitted when user starts dragging one of shape's point. Event Includes `point` field.\n * It is a [SmartPoint](#SmartPoint) object.\n * @param point_drag_move {MouseEvent} Emitted when user dragging one of shape's point. Event Includes `point` field.\n * It is a [SmartPoint](#SmartPoint) object.\n * @param point_drag_end {MouseEvent} Emitted when user finishes dragging one of shape's point. Event Includes `point` field.\n * It is a [SmartPoint](#SmartPoint) object.\n * @param point_added {MouseEvent} Emitted when new point added to the shape\n * @param point_removed {MouseEvent} Emitted when point removed from the shape\n * @param destroy {ShapeEvents.SHAPE_DESTROY} Emitted right before shape is destroyed\n * @param add_child {ShapeEvents.SHAPE_ADD_CHILD} New child shape added to this shape. Event object contains a\n * `child` field which is a SmartShape object of added child.\n * @param remove_child {ShapeEvents.SHAPE_REMOVE_CHILD} Child shape removed from this shape. Event object contains a\n * `child` field which is a SmartShape object of removed child.\n * @param shape_activated {ShapeEvents.SHAPE_ACTIVATED} Shape activated\n * @enum {string}\n */\nexport const ShapeEvents = {\n    SHAPE_CREATE: \"create\",\n    SHAPE_MOVE_START: \"move_start\",\n    SHAPE_MOVE: \"move\",\n    SHAPE_MOVE_END: \"move_end\",\n    SHAPE_MOUSE_MOVE: \"mousemove\",\n    SHAPE_MOUSE_ENTER: \"mouseenter\",\n    SHAPE_MOUSE_OVER: \"mouseover\",\n    SHAPE_MOUSE_OUT: \"mouseout\",\n    SHAPE_MOUSE_DOWN: \"mousedown\",\n    SHAPE_MOUSE_UP: \"mouseup\",\n    SHAPE_MOUSE_CLICK: \"click\",\n    SHAPE_MOUSE_DOUBLE_CLICK: \"dblclick\",\n    SHAPE_DESTROY: \"destroy\",\n    SHAPE_SHOW: \"show\",\n    SHAPE_HIDE: \"hide\",\n    POINT_ADDED: \"point_added\",\n    POINT_DESTROYED: \"point_destroyed\",\n    POINT_DRAG_START: \"point_drag_start\",\n    POINT_DRAG_MOVE: \"point_drag_move\",\n    POINT_DRAG_END: \"point_drag_end\",\n    SHAPE_RESIZE: \"resize\",\n    SHAPE_ROTATE: \"rotate\",\n    SHAPE_ADD_CHILD: \"add_child\",\n    SHAPE_REMOVE_CHILD: \"remove_child\",\n    SHAPE_ACTIVATED: \"shape_activated\",\n    /**\n     * Method returns an object of all ShapeEvents that\n     * related to mouse.*\n     * @returns {array} Array of objects in a format \"key:,name:\"\n     */\n    getShapeMouseEvents: () => {\n        return Object.keys(ShapeEvents)\n            .filter(key=> {\n                return [\"SHAPE_CREATE\",\"SHAPE_DESTROY\",\"SHAPE_RESIZE\",\"SHAPE_ROTATE\"].indexOf(key) === -1 &&\n                    typeof(ShapeEvents[key])!== \"function\"\n            }).map(key => {return {key:key,name:ShapeEvents[key]} })\n    }\n}\n\nexport default SmartShapeEventListener;\n","import {EventsManager, ShapeEvents,SmartShapeManager,SmartShapeDisplayMode} from \"../index.js\";\nimport {blobToDataURL, dataURLtoBlob, notNull, timeout} from \"../utils\";\nimport {applyAspectRatio} from \"../utils/geometry.js\";\n\n/**\n * Internal helper class that used to draw shape.\n * Should not be used directly. SmartShape objects execute methods\n * of this object when need to draw shapes.\n * @constructor\n */\nfunction SmartShapeDrawHelper() {\n\n    /**\n     * @ignore\n     * Method that implements drawing for provided shape.\n     * @param shape {SmartShape} Shape object to draw\n     */\n    this.draw = (shape) => {\n        const parent = shape.getParent();\n        if (!parent || parent.guid === shape.guid) {\n            if (shape.svg) {\n                try {\n                    shape.eventListener.removeSvgEventListeners();\n                    shape.svg.innerHTML = \"\";\n                } catch (err) {\n                }\n            } else if (shape.points.length) {\n                shape.svg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n                shape.svg.ondragstart = function () {\n                    return false;\n                }\n                if (shape.options.visible) {\n                    EventsManager.emit(ShapeEvents.SHAPE_SHOW, shape);\n                }\n                shape.eventListener.setSvgEventListeners();\n                shape.svg.id = shape.options.id;\n                shape.svg.setAttribute(\"guid\", shape.guid);\n                shape.root.appendChild(shape.svg);\n            }\n            if (shape.svg && typeof(shape.svg.appendChild) === \"function\") {\n                const defs = document.createElementNS(shape.svg.namespaceURI, \"defs\");\n                shape.svg.appendChild(defs);\n            }\n        } else {\n            shape.svg = null;\n            const svg = document.querySelector(\"svg[guid='\"+shape.guid+\"']\");\n            if (svg) {\n                svg.parentNode.removeChild(svg);\n            }\n            shape.resizeBox && shape.resizeBox.hide();\n            shape.rotateBox && shape.rotateBox.hide();\n        }\n        if (shape.points.length < 1) {\n            return\n        }\n        if (shape.options.hasContextMenu && shape.shapeMenu && !shape.shapeMenu.contextMenu) {\n            shape.shapeMenu.updateContextMenu();\n        }\n        this.updateOptions(shape);\n        if (!parent || !parent.options.displayAsPath) {\n            this.drawPolygon(shape);\n            if (shape.svg && shape.options.id.search(\"_resizebox\") === -1 && shape.options.id.search(\"_rotatebox\") === -1) {\n                setTimeout(() => {\n                    this.setupZIndex(shape);\n                },0);\n            }\n        } else if (parent && parent.options.displayAsPath && parent.guid !== shape.guid) {\n            this.draw(parent);\n        }\n        EventsManager.emit(\"show_finish\",shape);\n    }\n\n    /**\n     * @ignore\n     * Method updates options of shape and it points\n     * (including child or other associated shapes)\n     * on drawing phase\n     * @param shape {SmartShape} Shape object\n     */\n    this.updateOptions = (shape) => {\n        shape.calcPosition();\n        const parent = shape.getRootParent();\n        if (shape.svg && !parent && typeof(shape.svg.appendChild) === \"function\") {\n            if (typeof (shape.options.visible) !== \"undefined\") {\n                if (shape.svg.style.display !== shape.options.visible) {\n                    if (shape.options.visible) {\n                        EventsManager.emit(ShapeEvents.SHAPE_SHOW, shape);\n                        shape.getChildren(true).forEach(child => EventsManager.emit(ShapeEvents.SHAPE_SHOW,child))\n                    } else {\n                        EventsManager.emit(ShapeEvents.SHAPE_HIDE, shape);\n                        shape.getChildren(true).forEach(child => EventsManager.emit(ShapeEvents.SHAPE_HIDE,child));\n                    }\n                }\n                shape.svg.style.display = shape.options.visible ? '' : 'none';\n            }\n            shape.svg.id = shape.options.id;\n            shape.svg.setAttribute(\"guid\", shape.guid);\n            let pos\n            if (shape.options.groupChildShapes) {\n                pos = shape.getPosition(true);\n            } else {\n                pos = shape.getPosition();\n            }\n            shape.svg.style.position = 'absolute';\n            shape.svg.style.cursor = 'default';\n            shape.svg.style.left = pos.left + \"px\";\n            shape.svg.style.top = pos.top + \"px\";\n            shape.svg.setAttribute(\"width\", pos.width);\n            shape.svg.setAttribute(\"height\", pos.height);\n            shape.svg.style.zIndex = shape.options.zIndex;\n        } else if (parent && parent.svg) {\n            const polygon = parent.svg.querySelector(\"#p\"+shape.guid+\"_polygon\");\n            if (polygon) {\n                polygon.style.zIndex = shape.options.zIndex;\n            }\n        }\n        if (!parent || !parent.options.displayAsPath) {\n            this.setupShapeFill(shape);\n            this.createSVGFilters(shape);\n            shape.options.canScale && this.redrawResizeBox(parent || shape);\n            shape.options.canRotate && this.redrawRotateBox(parent || shape);\n        }\n        if (shape.options.pointOptions.canDrag) {\n            this.updatePoints(shape, parent);\n        }\n    }\n\n    /**\n     * @ignore\n     * Method updates points after redraw shape\n     * @param shape {SmartShape} Shape that need to update\n     * @param parent {SmartShape} Root parent of this shape or null\n     */\n    this.updatePoints = async(shape,parent) => {\n        if (shape.points[0] && !shape.points[0].element) {\n            await timeout(1);\n        }\n        shape.points.filter(point => point.element).forEach(point => {\n            if (point.element.parentNode !== shape.root) {\n                shape.root.appendChild(point.element);\n            }\n            point.options.zIndex = shape.options.zIndex + 2;\n            if (!shape.options.visible) {\n                point.options.visible = false;\n            }\n            point.redraw();\n            if (shape.options.displayMode === SmartShapeDisplayMode.DEFAULT && !point.options.forceDisplay) {\n                if (!parent || parent.options.displayMode === SmartShapeDisplayMode.DEFAULT) {\n                    point.element.style.display = 'none';\n                }\n            }\n        });\n    }\n\n    /**\n     * @ignore\n     * Method that used to construct actual shape SVG polygon during shape redraw process\n     * @param shape {SmartShape} Shape object to which polygon should be appended\n     * @returns {object} SVG <polygon> object\n     */\n    this.drawPolygon = (shape,svg=null) => {\n        if (!svg) {\n            svg = this.getShapeSvg(shape);\n        }\n        if (!svg || typeof(svg.appendChild) !== \"function\") {\n            return\n        }\n        let polygon = svg.querySelector(\"#p\"+shape.guid+\"_polygon\");\n        if (!polygon) {\n            polygon = document.createElementNS(\"http://www.w3.org/2000/svg\",\"path\");\n            if (svg) {\n                svg.appendChild(polygon)\n            }\n        }\n        polygon.setAttribute(\"d\",this.getPolygonPath(shape));\n        polygon.setAttribute(\"fill-rule\",\"evenodd\");\n        polygon.setAttribute(\"shape_id\", shape.options.id);\n        polygon.setAttribute(\"shape_guid\",shape.guid);\n        polygon.id = \"p\"+shape.guid+\"_polygon\";\n        this.setupPolygonFill(shape,polygon);\n        this.setupPolygonStyles(shape,polygon);\n        if (svg.querySelector(\"#f\"+shape.guid+\"_filter\")) {\n            polygon.style.filter ='url(\"#f'+shape.guid+'_filter\")';\n        }\n        polygon.style.zIndex = shape.options.zIndex;\n        shape.polygon = polygon;\n    }\n\n    /**\n     * @ignore\n     * Returns a path string for \"d\" attribute of <path> tag for specified shape\n     * @param shape {SmartShape} Shape to return path to\n     * @returns {string}\n     */\n    this.getPolygonPath = (shape) => {\n        const parent = shape.getParent();\n        if (parent) {\n            const pos = parent.getPosition(parent.options.groupChildShapes);\n            let path = this.getPolygonPathForShape(shape,pos,this.getMaxStrokeWidth(parent));\n            if (shape.options.displayAsPath && shape.options.groupChildShapes) {\n                shape.getChildren().forEach(child => {\n                    child.calcPosition();\n                    path += this.getPolygonPathForShape(child, pos, this.getMaxStrokeWidth(child));\n                })\n            }\n            return path;\n        } else {\n            const pos = shape.getPosition(shape.options.groupChildShapes);\n            let path = this.getPolygonPathForShape(shape,pos,this.getMaxStrokeWidth(shape));\n            if (shape.options.displayAsPath && shape.options.groupChildShapes) {\n                shape.getChildren().forEach(child => {\n                    child.calcPosition();\n                    path += this.getPolygonPathForShape(child,pos,this.getMaxStrokeWidth(child));\n                })\n                const svg = this.getShapeSvg(shape);\n                svg.setAttribute(\"width\",pos.width);\n                svg.setAttribute(\"height\",pos.height);\n                this.createSVGFilters(shape);\n            }\n            return path\n        }\n    }\n\n    /**\n     * @ignore\n     * Returns path string for specified shape, taking to account the 'stroke-width' SVG argument\n     * @param shape {SmartShape} Shape to get polygon for\n     * @param pos {object} Dimensions of shape. Object with fields `left`,`top`,`bottom`,`right`\n     * @param size {number} The size of stroke, used to draw this shape\n     * @returns {string} Path of points for polygon\n     */\n    this.getPolygonPathForShape = (shape,pos,size) => {\n        return \"M \"+shape.points\n            .map(point => {\n                let x = point.x - pos.left;\n                let y = point.y - pos.top;\n                if (x<=0) {\n                    x += size\n                } else if (point.x>=pos.right) {\n                    x -= size;\n                }\n                if (y<=0) {\n                    y += size\n                } else if (point.y>=pos.bottom) {\n                    y -= size;\n                }\n                return \"\"+x+\",\"+y\n            })\n            .join(\" \")+\" Z\";\n    }\n    /**\n     * @ignore\n     * If shape scaling feature is enabled, this method\n     * redraws [ResizeBox](#ResizeBox) around it after redrawing the shape\n     * @param shape {SmartShape} Shape object\n     */\n    this.redrawResizeBox = (shape) => {\n        if (shape.options.displayMode !== SmartShapeDisplayMode.SCALE || !shape.options.canScale) {\n            if (shape.resizeBox) {\n                shape.resizeBox.hide();\n            }\n            return\n        }\n        if (!shape.resizeBox) {\n            shape.setupResizeBox();\n            if (shape.resizeBox) {\n                shape.resizeBox.shape.points.forEach(point => {\n                    point.options.zIndex = shape.options.zIndex + 2;\n                    point.element.style.zIndex = shape.options.zIndex + 2;\n                })\n            }\n            return\n        }\n        const bounds = shape.getResizeBoxBounds();\n        if (shape.options.displayMode === SmartShapeDisplayMode.SCALE) {\n            shape.resizeBox.options.shapeOptions.visible = shape.options.visible;\n        }\n        shape.resizeBox.left = bounds.left;\n        shape.resizeBox.top = bounds.top;\n        shape.resizeBox.width = bounds.width;\n        shape.resizeBox.height = bounds.height;\n        shape.resizeBox.options.zIndex = shape.options.zIndex+1;\n        shape.resizeBox.redraw();\n        shape.resizeBox.shape.points.forEach(point => {\n            point.options.zIndex = shape.options.zIndex+2;\n            point.element.style.zIndex = shape.options.zIndex+2;\n        })\n    }\n\n    /**\n     * @ignore\n     * If shape rotation feature is enabled, this method\n     * redraws [RotateBox](#RotateBox) around it after redrawing the shape\n     * @param shape {SmartShape} Shape object\n     */\n    this.redrawRotateBox = (shape) => {\n        if (shape.options.displayMode !== SmartShapeDisplayMode.ROTATE || !shape.options.canRotate) {\n            if (shape.rotateBox) {\n                shape.rotateBox.hide();\n            }\n            return\n        }\n        if (!shape.rotateBox) {\n            shape.setupRotateBox();\n            if (shape.rotateBox) {\n                shape.rotateBox.shape.points.forEach(point => {\n                    point.options.zIndex = shape.options.zIndex + 2;\n                    point.element.style.zIndex = shape.options.zIndex + 2;\n                })\n            }\n            return\n        }\n        const bounds = shape.getResizeBoxBounds();\n        if (shape.options.displayMode === SmartShapeDisplayMode.ROTATE) {\n            shape.rotateBox.options.shapeOptions.visible = shape.options.visible;\n        } else {\n            shape.rotateBox.options.shapeOptions.visible = false;\n        }\n        shape.rotateBox.left = bounds.left;\n        shape.rotateBox.top = bounds.top;\n        shape.rotateBox.width = bounds.width;\n        shape.rotateBox.height = bounds.height;\n        shape.rotateBox.options.zIndex = shape.options.zIndex+1;\n        shape.rotateBox.redraw();\n        shape.rotateBox.shape.points.forEach(point => {\n            point.options.zIndex = shape.options.zIndex+2;\n            point.element.style.zIndex = shape.options.zIndex+2;\n        })\n    }\n\n    /**\n     * @ignore\n     * Used to setup fill of shape depending on provided options: color fill, gradient fill or image fill\n     * @param shape {SmartShape} Shape for which gradient should be created\n     */\n    this.setupShapeFill = (shape) => {\n        const fill = shape.options.style.fill || 'none';\n        if (fill === \"#image\" && shape.options.fillImage && typeof(shape.options.fillImage) === \"object\") {\n            this.createImageFill(shape);\n        } else if (fill === \"#gradient\" && shape.options.fillGradient && typeof(shape.options.fillGradient) === \"object\" &&\n            [\"linear\",\"radial\"].indexOf(shape.options.fillGradient.type) !== -1) {\n            this.createGradient(shape);\n        }\n    }\n\n    /**\n     * @ignore\n     * Method, used to create gradient fill for shape, if `options.fillGradient` specified.\n     * Triggered automatically when redraw the shape. Should not be called directly.\n     * @param shape {SmartShape} Shape for which gradient should be created\n     * equal to `linear` or `radial`. Accepts all options, that SVG linear gradient or SVG radial gradient accept.\n     * @returns {HTMLOrSVGElement} SVG element that defines gradient: either `linearGradient` or\n     * `radialGradient`. See: https://developer.mozilla.org/en-US/docs/Web/SVG/Element/linearGradient\n     */\n    this.createGradient = (shape) => {\n        const gradientOptions = shape.options.fillGradient;\n        const svg = this.getShapeSvg(shape);\n        let gradient = svg.querySelector(\"#g\"+shape.guid+\"_gradient\");\n        let gradientTag = gradientOptions.type === \"linear\" ? \"linearGradient\" : \"radialGradient\";\n        if (gradient) {\n            if (gradient.tagName.toLowerCase() !== gradientTag.toLowerCase()) {\n                gradient.parentNode.removeChild(gradient);\n            }\n        } else {\n            gradient = document.createElementNS(svg.namespaceURI,gradientTag);\n            if (svg) {\n                svg.querySelector('defs').appendChild(gradient);\n            }\n        }\n        gradient.innerHTML = \"\";\n        gradient.id = \"g\"+shape.guid+\"_gradient\";\n        let foundSteps = false;\n        for (let index in gradientOptions) {\n            if (index === \"type\") { continue }\n            if (index === \"steps\") {\n                foundSteps = true;\n                continue;\n            }\n            gradient.setAttribute(index,gradientOptions[index])\n        }\n        if (!foundSteps) {\n            return gradient;\n        }\n        for (let step of gradientOptions.steps) {\n            const stepNode = document.createElementNS(svg.namespaceURI,\"stop\");\n            if (notNull(step.stopColor)) {\n                stepNode.setAttribute(\"offset\", step.offset);\n            }\n            if (notNull(step.stopColor)) {\n                stepNode.setAttribute(\"stop-color\", step.stopColor);\n            }\n            if (notNull(step.stopOpacity)) {\n                stepNode.setAttribute(\"stop-opacity\", step.stopOpacity);\n            }\n            gradient.appendChild(stepNode);\n        }\n        return gradient;\n    }\n\n    /**\n     * @ignore\n     * Method used to construct SVG pattern to fill the shape with an image. Consists of\n     * `pattern` SVG node:\n     * https://developer.mozilla.org/en-US/docs/Web/SVG/Element/pattern.\n     * and `image` SVG node inside it.\n     * https://developer.mozilla.org/en-US/docs/Web/SVG/Element/image\n     * Triggered automatically when redraw the shape, if `options.fillImage` specified.\n     * Should not be called directly.\n     * @param shape {object} Shape for which image fill should be created\n     * @returns {HTMLOrSVGElement} Constructed `pattern` SVG tag or null, in case of errors\n     */\n    this.createImageFill = (shape) => {\n        const imageFillOptions = shape.options.fillImage;\n        if (!imageFillOptions.href || !imageFillOptions.width || !imageFillOptions.height) {\n            console.error(\"Image HREF, width and height must be specified for Image Fill\");\n            return null;\n        }\n        const svg = this.getShapeSvg(shape);\n        let pattern = svg.querySelector(\"p\"+shape.guid+\"_pattern\");\n        if (!pattern) {\n            pattern = document.createElementNS(svg.namespaceURI, \"pattern\");\n            pattern.setAttribute(\"id\",\"p\"+shape.guid+\"_pattern\");\n            pattern.setAttribute(\"patternUnits\",\"userSpaceOnUse\");\n            if (svg) {\n                svg.querySelector(\"defs\").appendChild(pattern);\n            }\n        }\n        for (let index in imageFillOptions) {\n            if (index === \"href\") {\n                continue;\n            }\n            pattern.setAttribute(index,imageFillOptions[index])\n        }\n        let image = pattern.querySelector(\"image\");\n        if (!image) {\n            image = document.createElementNS(svg.namespaceURI, \"image\");\n            pattern.appendChild(image);\n        }\n        if (imageFillOptions.href) {\n            image.setAttribute(\"href\", imageFillOptions.href);\n        }\n        image.setAttribute(\"width\",imageFillOptions.width);\n        image.setAttribute(\"height\",imageFillOptions.height);\n        return pattern;\n    }\n\n    /**\n     * @ignore\n     * Method used to apply SVG filter to the shape, if `filters` options specified in\n     * options of SmartShape.\n     * @param shape {SmartShape} shape object to apply filter to\n     * @returns {SVGFilterElement} Constructed filter element with set of filters\n     */\n    this.createSVGFilters = (shape) => {\n        if (!shape.options.filters || typeof(shape.options.filters) !== \"object\" || !Object.keys(shape.options.filters).length) {\n            return\n        }\n        const svg = this.getShapeSvg(shape);\n        let filters = svg.querySelector(\"#f\"+shape.guid+\"_filter\");\n        if (!filters) {\n            filters = document.createElementNS(svg.namespaceURI,\"filter\");\n            if (svg) {\n               svg.querySelector(\"defs\").append(filters);\n            }\n        }\n        filters.setAttribute(\"id\",\"f\"+shape.guid+\"_filter\");\n        filters.innerHTML = \"\";\n        for (let filterName in shape.options.filters) {\n            const filter = this.createSVGFilter(shape,filterName,shape.options.filters[filterName]);\n            if (filter) {\n                filters.appendChild(filter);\n            }\n        }\n    }\n\n    /**\n     * @ignore\n     * Method constructs individual SVG filter tag with specified name and options\n     * that will be added to the <filter> tag of shape's SVG.\n     * @param shape {SmartShape} shape object to apply filter ot\n     * @param filterName {string} name of SVG filter (feDropShadow, feGaussianBlur etc.)\n     * @param filterOptions {object} attributes of filter (any attributes that appropriate SVG filter tag accepts)\n     * @returns {SVGElement} Constructed filter element\n     */\n    this.createSVGFilter = (shape,filterName,filterOptions) => {\n        if (!shape.svg) {\n            return null;\n        }\n        const filter = document.createElementNS(shape.svg.namespaceURI,filterName);\n        const svg = this.getShapeSvg(shape);\n        const pos = shape.getPosition(shape.options.groupChildShapes);\n        for (let attribute in filterOptions) {\n            filter.setAttribute(attribute,filterOptions[attribute].toString());\n            if (attribute === \"dx\") {\n                svg.setAttribute(\"width\",(pos.width + parseInt(filterOptions[\"dx\"])*2).toString());\n            }\n            if (attribute === \"dy\") {\n                svg.setAttribute(\"height\",(pos.height + parseInt(filterOptions[\"dy\"])*2).toString());\n            }\n        }\n        return filter;\n    }\n\n    /**\n     * @ignore\n     * Method used to set up fill params of shape polygon\n     * @param shape {SmartShape} Shape object\n     * @param polygon {SVGPolygonElement} Polygon element to setup\n     */\n    this.setupPolygonFill = (shape, polygon) => {\n        const fill = shape.options.style.fill || \"none\";\n        if (fill === \"#image\" && shape.options.fillImage && typeof(shape.options.fillImage) === \"object\") {\n            polygon.setAttribute(\"fill\",'url(\"#p'+shape.guid+'_pattern'+'\")');\n        }  else if (fill === \"#gradient\" && shape.options.fillGradient && typeof(shape.options.fillGradient) === \"object\" &&\n            [\"linear\",\"radial\"].indexOf(shape.options.fillGradient.type) !== -1) {\n            polygon.setAttribute(\"fill\",'url(\"#g'+shape.guid+'_gradient'+'\")');\n        }\n    }\n\n    /**\n     * @ignore\n     * Method used to apply provided CSS classes and styles to SVG polygon\n     * @param shape {SmartShape} Shape object\n     * @param polygon {SVGPolygonElement} Polygon element to se tup\n     */\n    this.setupPolygonStyles = (shape, polygon) => {\n        if (shape.options.classes) {\n            polygon.setAttribute(\"class\",shape.options.classes);\n        }\n        if (!notNull(shape.options.style) || typeof(shape.options.style) !== \"object\") {\n            return;\n        }\n        for (let cssName in shape.options.style) {\n            polygon.style[cssName] = shape.options.style[cssName]\n        }\n    }\n\n    /**\n     * @ignore\n     * Method used to return shape as an SVG string.\n     * @param shape {SmartShape} Shape object\n     * @param includeChildren {boolean|null} Should include children of this shape to output.\n     * 'null' by default. In this case value of shape.options.groupChildShapes will be used\n     * @returns {string} String body of SVG document\n     */\n    this.toSvg = (shape,includeChildren=null) => {\n        const div = document.createElement(\"div\");\n        const svg = this.getSvg(shape,includeChildren);\n        div.appendChild(svg);\n        return '<?xml version=\"1.0\" encoding=\"UTF-8\"?>'+div.innerHTML.replace(/&quot;/g,\"'\");\n    }\n\n    /**\n     * @ignore\n     * Method used to return shape as an SVG document.\n     * @param shape {SmartShape} Shape object\n     * @param includeChildren {boolean|null} Should include children of this shape to output.\n     * 'null' by default. In this case value of shape.options.groupChildShapes will be used\n     * @returns {string} String body of SVG document\n     */\n    this.getSvg = (shape,includeChildren) => {\n        let groupChanged = false;\n        let pathChanged = false;\n        let svg = shape.svg;\n        if (!svg) {\n            const parent = shape.getParent();\n            if (parent) {\n                svg = parent.svg;\n            }\n        }\n        if (!svg) {\n            return\n        }\n        svg = svg.cloneNode(true);\n        if (includeChildren) {\n            shape = shape.getParent() || shape;\n            if (!shape.options.groupChildShapes) {\n                shape.options.groupChildShapes = true;\n                groupChanged = true;\n            }\n            if (!shape.options.displayAsPath) {\n                shape.getChildren(true).forEach(child => {\n                    this.drawPolygon(child, svg);\n                })\n            }\n            this.drawPolygon(shape,svg);\n            let paths = Array.from(svg.querySelectorAll(\"path\"));\n            paths.sort((p1,p2) => parseInt(p1.style.zIndex)-parseInt(p2.style.zIndex));\n            const defs = svg.querySelector(\"defs\");\n            svg.innerHTML = \"\";\n            svg.appendChild(defs);\n            paths.forEach(path=>svg.appendChild(path));\n        }\n        svg.removeAttribute(\"style\");\n        svg.removeAttribute(\"width\");\n        svg.removeAttribute(\"height\");\n        svg.removeAttribute(\"id\");\n        svg.removeAttribute(\"guid\");\n        const pos = shape.getPosition(includeChildren === null ? shape.options.groupChildShapes : includeChildren);\n        svg.setAttribute(\"xmlns\",\"http://www.w3.org/2000/svg\")\n        const zoom = shape.options.zoomLevel || 1;\n        const viewBox = \"0 0 \" + pos.width/zoom + \" \" + pos.height/zoom;\n        svg.setAttribute(\"viewBox\",viewBox);\n        if (groupChanged) {\n            shape.options.groupChildShapes = false;\n        }\n        if (pathChanged) {\n            shape.options.displayAsPath = false;\n        }\n        if (shape.options.zoomLevel !== 1) {\n            svg.querySelectorAll(\"path\").forEach(path => {\n                let result = \"\";\n                const d = path.getAttribute(\"d\").split(\" \")\n                for (let item of d) {\n                    if (item.search(\",\") === -1) {\n                        result += item + \" \"\n                    } else {\n                        const parts = item.split(\",\");\n                        result += (parseFloat(parts[0])/zoom)+\",\"+(parseFloat(parts[1])/zoom)+\" \"\n                    }\n                }\n                path.setAttribute(\"d\",result);\n            })\n        }\n        return svg;\n    }\n\n    /**\n     * @ignore\n     * Method returns maximal stroke width of this shape or its children\n     * @param shape {SmartShape} Shape to return stroke width for\n     * @returns {number|*}\n     */\n    this.getMaxStrokeWidth = (shape) => {\n        const svg = this.getShapeSvg(shape);\n        if (!svg) {\n            return 0;\n        }\n        let width = parseInt(shape.options.style[\"stroke-width\"]);\n        if (isNaN(width)) {\n            width = 0;\n        }\n        if (!shape.options.groupChildShapes) {\n            return width;\n        }\n        return shape.getChildren(true)\n                .map(child => isNaN(parseInt(child.options.style[\"stroke-width\"])) ? 0 : parseInt(child.options.style[\"stroke-width\"]))\n                .reduce((w1,w2) => w1 > w2 ? w1 : w2,width)\n    }\n\n    /**\n     * @ignore\n     * Method exports shape and all its children as a PNG image\n     * @param {SmartShape} shape Shape object to export\n     * @param {PngExportTypes} type Format of returned result - `dataurl` or `blob`. By default `dataurl`\n     * @param {number|null} width Width of image. If not specified, then calculate based on height or current\n     * width of shape\n     * @param {number|null} height Height of image. If not specified, then calculate based on width or current\n     * height of shape\n     * @param includeChildren {boolean} Should include children of this shape to output.\n     * 'null' by default. In this case value of shape.options.groupChildShapes will be used*\n     * @return {Promise} Promise that resolves either to DataURL string or to BLOB object, depending on value of\n     * `type` argument\n     */\n    this.toPng = (shape,type= PngExportTypes.DATAURL,width=null,height=null, includeChildren=null) => {\n        return new Promise(async(resolve) => {\n            shape.calcPosition();\n            const zoom = shape.options.zoomLevel || 1;\n            const pos = shape.getPosition(includeChildren || shape.options.groupChildShapes);\n            [width, height] = applyAspectRatio(width, height, pos.width/zoom, pos.height/zoom);\n            const svgObj = this.getSvg(shape,includeChildren);\n            svgObj.setAttribute(\"width\", pos.width/zoom);\n            svgObj.setAttribute(\"height\", pos.height/zoom);\n            for (let item of svgObj.querySelectorAll(\"image\")) {\n                if (item.getAttribute(\"href\") && item.getAttribute(\"href\").length) {\n                    const href = await blobToDataURL(await (await fetch(item.getAttribute(\"href\"))).blob());\n                    item.setAttribute(\"href\",href);\n                }\n            }\n            const div = document.createElement(\"div\");\n            div.appendChild(svgObj);\n            const svgString = div.innerHTML;\n            const img = new Image();\n            const svg = new Blob([svgString],{type:\"image/svg+xml\"});\n            const DOMURL = window.URL || window.webkitURL || window;\n            const url = await blobToDataURL(svg);\n            img.addEventListener(\"load\", () => {\n                const canvas = document.createElement(\"canvas\");\n                img.width = pos.width/zoom;\n                img.height = pos.height/zoom;\n                canvas.width = img.width;\n                canvas.height = img.height;\n                const ctx = canvas.getContext(\"2d\");\n                ctx.drawImage(img,0,0)\n                ctx.scale(width,height);\n                DOMURL.revokeObjectURL(url);\n                const result = canvas.toDataURL(\"image/png\");\n                if (type === PngExportTypes.BLOB) {\n                    resolve(dataURLtoBlob(result));\n                    return\n                }\n                resolve(result)\n            })\n            img.src = url;\n        })\n    }\n\n    /**\n     * @ignore\n     * Method used to change shape zIndex to topmost\n     * @param shape {SmartShape} shape object\n     */\n    this.moveShapeToTop = (shape) => {\n        const zIndex = SmartShapeManager.getMaxZIndex(shape.root);\n        if (shape.options.zIndex === zIndex && SmartShapeManager.findShapesByOptionValue(\"zIndex\",zIndex).length === 1) {\n            return\n        }\n        this.changeShapeZIndex(shape,zIndex+1);\n    }\n\n    /**\n     * @ignore\n     * Method used to change shape zIndex to topmost\n     * @param shape {SmartShape} shape object\n     */\n    this.moveShapeToBottom = (shape) => {\n        const zIndex = SmartShapeManager.getMinZIndex(shape.root);\n        if (shape.options.zIndex === zIndex && SmartShapeManager.findShapesByOptionValue(\"zIndex\",zIndex).length === 1) {\n            return\n        }\n        this.changeShapeZIndex(shape,zIndex-1);\n    }\n\n    /**\n     * @ignore\n     * Method used to change shape zIndex to specified\n     * @param shape {SmartShape} shape object\n     * @param zIndex {number} zIndex value\n     */\n    this.changeShapeZIndex = (shape,zIndex) => {\n        if (zIndex === shape.options.zIndex) {\n            return\n        }\n        const diff = zIndex - shape.options.zIndex;\n        shape.options.prevZIndex = shape.options.zIndex;\n        shape.options.zIndex += diff;\n        this.updateOptions(shape);\n        if (shape.options.groupChildShapes) {\n            shape.getChildren(true).forEach(child => {\n                child.options.prevZIndex = child.options.zIndex;\n                child.options.zIndex += diff;\n                this.updateOptions(child);\n            });\n        }\n    }\n\n    /**\n     * @ignore\n     * Internal method that used to return SVG element to which this shape belongs\n     * If this is a root shape, then just returns svg of current shape object,\n     * if it's a child, then SVG element of the parent\n     * @param shape {SmartShape} Shape to return SVG element for\n     * @returns {HTMLOrSVGElement|null|*}\n     */\n    this.getShapeSvg = (shape) => {\n        const parent = shape.getRootParent()\n        if (parent && parent.svg) {\n            return parent.svg\n        }\n        return shape.svg;\n    }\n\n    /**\n     * @ignore\n     * Method used to correct order of items of SVG shape according to Z-Index CSS style\n     * @param shape {SmartShape} Shape to correct\n     */\n    this.setupZIndex = (shape) => {\n        if (!shape.svg) {\n            return\n        }\n        let paths = Array.from(shape.svg.querySelectorAll(\"path\"));\n        paths.sort((p1,p2) => parseInt(p1.style.zIndex)-parseInt(p2.style.zIndex));\n        const defs = shape.svg.querySelector(\"defs\");\n        shape.svg.innerHTML = \"\";\n        shape.svg.appendChild(defs);\n        paths.forEach(path=>shape.svg.appendChild(path));\n    }\n}\n\n/**\n * Enumeration of PNG export types for SmartShape.toPng() function\n * @param dataurl Return PNG as a DataURL string\n * @param blob Return PNG as a BLOB object\n * @enum {string}\n */\nexport const PngExportTypes = {\n    DATAURL: \"dataurl\",\n    BLOB: \"blob\"\n}\n\nexport default new SmartShapeDrawHelper();\n","import {mergeObjects, notNull} from \"../utils/index.js\";\nimport SmartShapeManager from \"./SmartShapeManager.js\";\n\n/**\n * @ignore\n * Method used to import collection of shapes from JSON array in GeoJSON format: https://geojson.org/\n * @param container {HTMLElement} The HTML element to connect loaded shapes\n * @param geoJSON {object} Javascript object in geoJSON format\n * @param options {object} Options to tune the import process:\n * `idField`: the field from \"properties collection of GeoJSON object that used as a shape ID,\n * `nameField`: the field from \"properties\" collection of GeoJSON object that used as a shape name,\n * `width`: the width to which loaded shapes should be scaled (if not specified then calc automatically based on height),\n * `height`: the height to which loaded shapes should be scaled (if not specified then calc automatically based on width),\n * `scale`: scaling factor to which loaded shapes should be scaled (if not specified, width and height used,\n * if nothing specified, then scales to 200px width if natural width is less than this)\n * `options`: shape options [SmartShape.options](#SmartShape+options) to set to each shape after import\n * `fields`: which other fields to import from GeoJSON, in addition to `idField` and `nameField`\n * @param progressCallback {function} Function that executes after loading each shape from file. If specified, it will\n * be executed with three arguments: `currentShapeIndex` - index of current processed shape, `totalShapesLength` - total\n * number of shapes in the collection, shape - SmartShape object of currently processed shape.\n * @returns {array} Array of SmartShape objects\n */\nexport const fromGeoJSON = (container,geoJSON, options={}, progressCallback=null) => {\n    if (!notNull(geoJSON) || typeof(geoJSON) !== \"object\") {\n        return null;\n    }\n    if (!notNull(geoJSON.features)) {\n        geoJSON = {features:[geoJSON]}\n    }\n    if (!geoJSON.features.length) {\n        return null\n    }\n    const result = [];\n    for (let index in geoJSON.features) {\n        const obj = geoJSON.features[index];\n        const shape = createShapeFromGeoJson(obj,index,options,container);\n        if (progressCallback && typeof(progressCallback) === \"function\") {\n            progressCallback(index,geoJSON.features.length,shape);\n        }\n        if (shape) {\n            result.push(shape);\n        }\n    }\n    return result.length === 1 ? result[0] : result;\n}\n\nconst createShapeFromGeoJson = (obj, index, importOptions, container) => {\n    if (!isCorrectJSON(obj)) {\n        return;\n    }\n    let options = loadOptions(obj,index,importOptions);\n    options.visible = false;\n    const polygons = loadPolygons(obj);\n    if (!polygons || !polygons.length) {\n        return\n    }\n    polygons.sort((p1,p2) => p2.dims.width*p2.dims.height - p1.dims.width * p1.dims.height)\n    let shape = null;\n    for (let idx in polygons) {\n        const shapeOpts = mergeObjects({},options);\n        if (idx==0) {\n            if (importOptions.onlyData) {\n                shape = {\n                    points:   polygons[idx].cords,\n                    options:  shapeOpts,\n                    children: [],\n                    ...polygons[idx].dims\n                }\n            } else {\n                shape = SmartShapeManager.createShape(container,shapeOpts,polygons[idx].cords,false)\n                shape.left = polygons[idx].dims.left;\n                shape.top = polygons[idx].dims.top;\n                shape.right = polygons[idx].dims.right;\n                shape.bottom = polygons[idx].dims.bottom;\n                shape.width = polygons[idx].dims.width;\n                shape.height = polygons[idx].dims.height;\n            }\n        } else {\n            shapeOpts.id += \"_\" + idx;\n            shapeOpts.name += \" \" + idx;\n            if (importOptions.onlyData) {\n                shape.children.push({\n                    points: polygons[idx].cords,\n                    options:shapeOpts,\n                    ...polygons[idx].dims\n                })\n            } else {\n                const child = SmartShapeManager.createShape(container,shapeOpts,polygons[idx].cords);\n                child.left = polygons[idx].dims.left;\n                child.top = polygons[idx].dims.top;\n                child.right = polygons[idx].dims.right;\n                child.bottom = polygons[idx].dims.bottom;\n                child.width = polygons[idx].dims.width;\n                child.height = polygons[idx].dims.height;\n                shape.addChild(child, false)\n            }\n        }\n    }\n    if (importOptions.onlyData) {\n        return shape;\n    }\n    if (notNull(importOptions.scale)) {\n        shape.scaleBy(importOptions.scale,importOptions.scale,true);\n    } else if (notNull(importOptions.width) || notNull(importOptions.height)) {\n        shape.scaleTo(importOptions.width,importOptions.height)\n    }\n    return shape;\n}\n\nconst isCorrectJSON = (obj) => {\n    if (!notNull(obj.properties) || typeof(obj.properties) !== \"object\") {\n        return false\n    }\n    const geometry = obj.geometry;\n    if (!notNull(geometry) || typeof(geometry) !== \"object\") {\n        return false;\n    }\n    if ([\"Polygon\",\"MultiPolygon\"].indexOf(geometry.type) === -1) {\n        return false;\n    }\n    if (!notNull(geometry.coordinates) ||\n        typeof(geometry.coordinates) !== \"object\" ||\n        !geometry.coordinates.length) {\n        return false;\n    }\n    return true;\n}\n\nconst loadOptions = (obj,index,importOptions) => {\n    const result = {};\n    result.name = obj.properties[importOptions.nameField] || \"Shape \"+ index;\n    result.id = obj.properties[importOptions.idField] || \"shape_\" + index;\n    if (notNull(importOptions.fields) && typeof(importOptions.fields) === \"object\") {\n        importOptions.fields\n            .filter(fieldName => notNull(obj.properties[fieldName]))\n            .forEach(fieldName => result[fieldName] = obj.properties[fieldName])\n    }\n    if (notNull(importOptions.options) && typeof(importOptions.options) === \"object\") {\n        for (let id in importOptions.options) {\n            result[id] = importOptions.options[id];\n        }\n    }\n    return result;\n}\n\nconst loadPolygons = (obj) => {\n    let polygons = obj.geometry.coordinates;\n    if (obj.geometry.type === \"Polygon\") {\n        polygons = [polygons];\n    }\n    const result = [];\n    for (let _polygon of polygons) {\n        const polygon = _polygon[0];\n        const cords = [];\n        let left=Infinity,right=-Infinity,top=Infinity,bottom=-Infinity;\n        for (let point of polygon) {\n            const [x,y] = [point[0],-point[1]];\n            if (x<left) {\n                left = x;\n            }\n            if (x>right) {\n                right = x;\n            }\n            if (y<top) {\n                top = y;\n            }\n            if (y>bottom) {\n                bottom = y;\n            }\n            cords.push({x,y})\n        }\n        result.push({cords,dims:{left,top,bottom,right,width:right-left,height:bottom-top}});\n    }\n    return result;\n}\n\nconst getDecimalLength = (number) => {\n    let parts = number.toString().split(\".\");\n    if (parts[1]) {\n        return parts[1].length\n    }\n    return 0\n}\n","import EventsManager from \"../events/EventsManager.js\";\nimport {ShapeEvents} from \"../SmartShape/SmartShapeEventListener.js\";\nimport {notNull, readJSON} from \"../utils/index.js\";\nimport SmartShape,{SmartShapeDisplayMode} from \"../SmartShape/SmartShape.js\";\nimport {PointEvents} from \"../SmartPoint/SmartPoint.js\";\nimport SmartShapeDrawHelper from \"../SmartShape/SmartShapeDrawHelper.js\";\nimport {createEvent, getMouseCursorPos} from \"../events/functions.js\";\nimport {fromGeoJSON} from \"./GeoJSONImport.js\";\nimport {ResizeBoxEvents} from \"../ResizeBox/ResizeBoxEventListener.js\";\n\n/**\n * Object that keeps collection of shapes and keep track of\n * their activity. This object is instantiated automatically by\n * when first shape created. Then it listens lifecycle events of shapes\n * to keep their collection, correctly switch activity status and\n * handle other global events related to shapes and their containers\n * @constructor\n */\nfunction SmartShapeManager() {\n\n    /**\n     * Collection of [SmartShape's](#SmartShape) objects.\n     * Each object indexed by GUID\n     * @type {object}\n     */\n    this.shapes = {};\n\n    /** Collection of [SmartShape's](#smartShape) objects\n     * that are visible now. Each object indexed by GUID\n     * @type {object}\n     */\n    this.visibleShapes = {};\n\n    /**\n     * Which shape is currently selected\n     * @type {SmartShape}\n     */\n    this.activeShape = null;\n\n    /**\n     * Which shape user is currently dragging\n     * @type {SmartShape}\n     */\n    this.draggedShape = null;\n\n    /**\n     * The shape under mouse cursor\n     * @type {SmartShape}\n     */\n    this.shapeOnCursor = null;\n\n    /**\n     * List of event listeners, attached to containers of shapes in format\n     * {container: DOM-link to container, name: name of event, listener: handler function}\n     * @type {array}\n     */\n    this.containerEventListeners = [];\n\n    /**\n     * @ignore\n     * Initializes the object.\n     * @returns {SmartShapeManager}\n     */\n    this.init = () => {\n        this.setEventListeners();\n        return this;\n    }\n\n    /**\n     * @ignore\n     * Add listeners to key shapes events, that required to intercept\n     * to correctly maintain the list of shapes and their activities\n     */\n    this.setEventListeners = () => {\n        EventsManager.subscribe(ShapeEvents.SHAPE_CREATE,this.onShapeCreated);\n        EventsManager.subscribe(ShapeEvents.SHAPE_DESTROY,this.onShapeDestroy);\n        EventsManager.subscribe(ShapeEvents.SHAPE_SHOW, this.onShapeShow);\n        EventsManager.subscribe(ShapeEvents.SHAPE_HIDE, this.onShapeHide);\n        EventsManager.subscribe(ShapeEvents.SHAPE_MOVE_START, this.onShapeMoveStart);\n        EventsManager.subscribe(ShapeEvents.SHAPE_MOUSE_ENTER, this.onShapeMouseEnter);\n        EventsManager.subscribe(PointEvents.POINT_DRAG_START, this.onPointDragStart);\n        EventsManager.subscribe(PointEvents.POINT_DRAG_END, this.onPointDragEnd);\n        window.addEventListener(\"resize\", this.onWindowResize);\n    }\n\n    /**\n     * @ignore\n     * Internal method, triggered when browser window resized.\n     * @param _event Window resize event - [UIEvent](https://developer.mozilla.org/en-US/docs/Web/API/UIEvent).\n     */\n    this.onWindowResize = (_event) => {\n        for (let index in this.shapes) {\n            const shape = this.shapes[index];\n            EventsManager.emit(ContainerEvents.CONTAINER_BOUNDS_CHANGED,shape,\n                {bounds:shape.getBounds(),points:shape.points}\n            )\n        }\n    }\n\n    /**\n     * Method used to construct SmartShape object with specified `points` and\n     * with specified `options`.\n     * Then it binds this object to specified `root` HTML node and displays it\n     * @param root {HTMLElement} HTML DOM node af a container element\n     * @param options {object} Options object to construct this shape (See [SmartShape options](#SmartShape+options))\n     * @param points {array} 2D Array of points for shape polygon.\n     * Each element is [x,y] coordinate array\n     * @param show {boolean} Should display the shape by default. Default: true\n     * @returns {object} constructed SmartShape object\n     */\n    this.createShape = (root,options,points,show= true) => {\n        return new SmartShape().init(root, options, points, show)\n    }\n\n\n    /**\n     * @ignore\n     * Executed when new shape is created. Used to add the shape to the list\n     * and setup event listeners for container, to which this shape connected\n     * @param event {ShapeEvents.SHAPE_CREATE} Event object\n     */\n    this.onShapeCreated = (event) => {\n        const shape = event.target;\n        if (notNull(shape.root) && !this.getShape(shape) && typeof(shape.belongsToShape) === \"function\") {\n            this.addShape(shape);\n            if (!this.activeShape) {\n                this.activeShape = shape;\n            }\n        }\n    }\n\n    /**\n     * @ignore\n     * Internal method used to push shape to collection and connect\n     * event listeners to it container\n     * @param shape {SmartShape} Shape object to add\n     */\n    this.addShape = (shape) => {\n        this.shapes[shape.guid] = shape;\n        if (shape.options.visible && this.isNormalShape(shape)) {\n            this.visibleShapes[shape.guid] = shape;\n        }\n        if (this.getShapesByContainer(shape.root).length === 1) {\n            this.addContainerEvents(shape)\n        }\n    }\n\n    /**\n     * @ignore\n     * Executed when shape destroyed. Used to remove the shape from the list\n     * and remove all listeners, attached to the container of this shape\n     * if no other shapes attached to the same container\n     * @param event {ShapeEvents.SHAPE_DESTROY} Event object\n     */\n    this.onShapeDestroy = (event) => {\n        const shape = event.target;\n        delete this.shapes[shape.guid];\n        const root = shape.root;\n        if (!notNull(shape.root)) {\n            return\n        }\n        if (this.getShapesByContainer(root).length === 0) {\n            this.containerEventListeners\n                .filter(item => item.container === root)\n                .forEach(item => {\n                    item.container.removeEventListener(item.name,item.listener);\n                    this.containerEventListeners.splice(this.containerEventListeners.indexOf(item),1);\n                })\n        }\n    }\n\n    /**\n     * @ignore\n     * Shape show event handler\n     * @param event {ShapeEvents.SHAPE_SHOW} Event object with shape in event.target\n     */\n    this.onShapeShow = (event) => {\n        if (this.isNormalShape(event.target)) {\n            this.visibleShapes[event.target.guid] = event.target;\n        }\n    }\n\n    /**\n     * @ignore\n     * Shape show event handler\n     * @param event {ShapeEvents.SHAPE_HIDE} Event object with shape in event.target\n     */\n    this.onShapeHide = (event) => {\n        delete this.visibleShapes[event.target.guid]\n    }\n\n    /**\n     * @ignore\n     * Executed when user starts dragging the shape. Switches active shape to this one\n     * and also set this shape as a shape \"in a process of dragging\"\n     * @param event {ShapeEvents.SHAPE_MOVE_START} Event object\n     */\n    this.onShapeMoveStart = (event) => {\n        if (!this.getShapeByGuid(event.target.guid) || !event.target.options.managed) {\n            return\n        }\n        const parent = event.target.getRootParent(true);\n        if (parent && parent.options.groupChildShapes) {\n            this.activateShape(parent);\n            this.draggedShape = parent;\n        } else {\n            this.activateShape(event.target);\n            this.draggedShape = event.target;\n        }\n    }\n\n    /**\n     * @ignore\n     * Executed when mouse cursor enters the shape\n     * @param event {ShapeEvents.SHAPE_MOUSE_ENTER} Event object\n     */\n    this.onShapeMouseEnter = (event) => {\n        if (!this.draggedShape) {\n            return;\n        }\n        if (event.buttons !== 1) {\n            this.draggedShape.draggedPoint = null;\n        }\n    }\n\n    /**\n     * @ignore\n     * Executed when user starts dragging point of the shape.\n     * Sets the status of this point as a point that is being dragged\n     * @param event {PointEvents.POINT_DRAG_START} Event object\n     */\n    this.onPointDragStart = (event) => {\n        const shape = this.findShapeByPoint(event.target);\n        if (shape) {\n            this.draggedShape = shape;\n            const parent = shape.getRootParent(true);\n            if (parent && parent.options.groupChildShapes) {\n                this.draggedShape = parent;\n            }\n            this.draggedShape.draggedPoint = event.target;\n            EventsManager.emit(ShapeEvents.POINT_DRAG_START,shape,{point:event.target})\n        }\n    }\n\n    /**\n     * @ignore\n     * Executed when user ends dragging point in the shape.\n     * Clears \"dragging\" status of this point\n     * @param _event {PointEvents.POINT_DRAG_END} Event object\n     */\n    this.onPointDragEnd = (_event) => {\n        if (this.draggedShape) {\n            this.draggedShape.draggedPoint = null;\n        }\n        this.draggedShape = null;\n    }\n\n    /**\n     * @ignore\n     * Checks and returns the shape if it exists in the array of shapes\n     * or null.\n     * @param shape {SmartShape} The shape to check\n     * @returns {null|SmartShape}\n     */\n    this.getShape = (shape) => this.getShapeByGuid(shape.guid);\n\n    /**\n     * Method returns a shape to which specified point object belongs\n     * or null\n     * @param point {SmartPoint}\n     * @returns {null|SmartShape}\n     */\n    this.findShapeByPoint = (point) => {\n        for (let index in this.shapes) {\n            const shape = this.shapes[index];\n            if (shape.isShapePoint(point)) {\n                return shape\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Returns shape by GUID\n     * @param guid {string} GUID of shape\n     * @returns {null|SmartShape} The shape object\n     */\n    this.getShapeByGuid = (guid) => {\n        if (notNull(this.shapes[guid])) {\n            return this.shapes[guid]\n        } else {\n            return null\n        }\n    }\n\n    /**\n     * Returns an array of shapes that connected to specified DOM container\n     * @param container {HTMLElement} Link to container\n     * @returns {array} Array of [SmartShape](#SmartShape) objects\n     */\n    this.getShapesByContainer = (container) => {\n        const result = [];\n        for (let index in this.shapes) {\n            const shape = this.shapes[index];\n            if (this.isNormalShape(shape) && shape.root === container) {\n                result.push(shape);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Method returns zIndex of the topmost shape either in specified container or globally\n     * @param container {HTMLElement|null} Container to search in or null if search through all shapes\n     * @returns {number} zIndex of the topmost shape\n     */\n    this.getMaxZIndex = (container=null) => {\n        let shapes;\n        if (container) {\n            shapes = this.getShapesByContainer(container);\n        } else {\n            shapes = this.getShapes();\n        }\n        if (!shapes.length) {\n            return 0;\n        }\n        return parseInt(\n            shapes.map(shape=>shape.options.zIndex || 0).reduce((max,zIndex) => zIndex>max ? zIndex : max,0 )\n        );\n    }\n\n    /**\n     * Method returns zIndex of the bottommost shape either in specified container or globally\n     * @param container {HTMLElement|null} Container to search in or null if search through all shapes\n     * @returns {number} zIndex of the bottommost shape\n     */\n    this.getMinZIndex = (container=null) => {\n        let shapes;\n        if (container) {\n            shapes = this.getShapesByContainer(container);\n        } else {\n            shapes = this.getShapes();\n        }\n        if (!shapes.length) {\n            return 0;\n        }\n        return parseInt(\n            shapes.map(shape=>shape.options.zIndex || 0).reduce((min,zIndex) => zIndex<min ? zIndex : min ,999999)\n        );\n    }\n\n    /**\n     * Method returns an array of all registered shapes (excluding rotate and resize boxes around them)\n     * @returns {array} Array of [SmartShape)(#SmartShape) objects\n     */\n    this.getShapes = () => {\n        const result = [];\n        for (let index in this.shapes) {\n            const shape = this.shapes[index];\n            if (this.isNormalShape(shape)) {\n                result.push(shape)\n            }\n        }\n        return result\n    }\n\n    this.isNormalShape = (shape) => {\n        return shape.options.id.search(\"_resizebox\") === -1 &&\n            shape.options.id.search(\"_rotatebox\") === -1 &&\n            typeof(shape.belongsToShape) === \"function\";\n    }\n\n    /**\n     * Method used to make specified shape active and move it on top according to zIndex\n     * @param shape {SmartShape} Shape to activate\n     * @param displayMode {SmartShapeDisplayMode} In which mode to activate the shape (by default select next mode)\n     */\n    this.activateShape = (shape,displayMode=null) => {\n        if (this.activeShape === shape) {\n            this.activeShape.switchDisplayMode(displayMode);\n            if (shape.options.moveToTop) {\n                shape.moveToTop();\n            }\n            return;\n        }\n        if (typeof(shape.id) !== \"undefined\" &&\n            (shape.id.search(\"_resizebox\") !== -1 || shape.id.search(\"_rotatebox\") !== -1)) {\n            return\n        }\n        if (this.activeShape) {\n            this.deactivateShape(this.activeShape);\n        }\n        if (shape.options.moveToTop) {\n            shape.moveToTop();\n        }\n        this.activeShape = shape;\n        EventsManager.emit(ShapeEvents.SHAPE_ACTIVATED,this.activeShape);\n        this.activeShape.switchDisplayMode(displayMode);\n    }\n\n    /**\n     * @ignore\n     * Method used to deactivate specified shape and return it\n     * to the zIndex position, which it had before activation\n     * @param shape\n     */\n    this.deactivateShape = (shape) => {\n        if (typeof(shape.options.prevZIndex) !== \"undefined\") {\n            SmartShapeDrawHelper.updateOptions(shape);\n        }\n        if (shape.options.displayMode !== SmartShapeDisplayMode.DEFAULT) {\n            shape.switchDisplayMode(SmartShapeDisplayMode.DEFAULT);\n        }\n        if (!shape.options.groupChildShapes) {\n            return\n        }\n        shape.getChildren(true).forEach(child => {\n            if (typeof(child.options.prevZIndex) !== \"undefined\") {\n                SmartShapeDrawHelper.updateOptions(child);\n                if (child.options.displayMode !== SmartShapeDisplayMode.DEFAULT) {\n                    child.switchDisplayMode(SmartShapeDisplayMode.DEFAULT);\n                }\n            }\n        })\n    }\n\n    /**\n     * @ignore\n     * Method used to attach required event listeners to HTML container of specified shape\n     * Should run once for each container.\n     * @param shape {SmartShape} Smart shape object\n     */\n    this.addContainerEvents = (shape) => {\n        this.addContainerEvent(shape.root,\"mousemove\",this.mousemove);\n        this.addContainerEvent(shape.root,\"mouseup\",this.mouseup,shape.options.id)\n        this.addContainerEvent(shape.root,\"dblclick\",this.doubleclick);\n        this.addContainerEvent(shape.root,\"contextmenu\", this.contextmenu);\n        this.addContainerEvent(shape.root,\"mouseleave\", this.mouseleave);\n        EventsManager.emit(SmartShapeManagerEvents.MANAGER_ADD_CONTAINER_EVENT_LISTENERS,shape.root)\n    }\n\n    /**\n     * Method adds event handler of specified event of specified HTML container.\n     * @param container {object} Container\n     * @param eventName {string} Name of event\n     * @param handler {function} Event handling function\n     */\n    this.addContainerEvent = (container,eventName,handler) => {\n        if (this.containerEventListeners.find(event=>event.container === container && event.name === eventName)) {\n            return\n        }\n        container.addEventListener(eventName,handler);\n        this.containerEventListeners.push({id:container.id,container:container,name:eventName,listener:handler})\n    }\n\n    /**\n     * @ignore\n     * OnDblClick event handler, triggered when user double-clicks on shape or on shape container element\n     * @param event {MouseEvent} Event object\n     */\n    this.doubleclick = (event) => {\n        if (this.shapeOnCursor) {\n            this.shapeOnCursor.eventListener.doubleclick(createEvent(event,{target:this.shapeOnCursor}))\n        }\n        try {\n            event.stopPropagation();\n        } catch (err) {}\n        if (!this.activeShape || !this.activeShape.options.canAddPoints ||\n            this.activeShape.draggedPoint ||\n            this.activeShape.points.length>2 ||\n            this.activeShape.points.length === this.activeShape.options.maxPoints\n        ) {\n            return\n        }\n        if (this.activeShape.options.displayMode === SmartShapeDisplayMode.DEFAULT) {\n            this.activeShape.switchDisplayMode(SmartShapeDisplayMode.SELECTED);\n        }\n        const [x,y] = getMouseCursorPos(createEvent(event,{target:this.activeShape}));\n        this.activeShape.addPoint(x,y,{forceDisplay:false});\n    }\n\n    this.contextmenu = (event) => {\n        event.stopPropagation();\n        event.preventDefault();\n        if (this.shapeOnCursor) {\n            const menu = this.shapeOnCursor.shapeMenu\n            if (!menu) {\n                return\n            }\n            menu.contextMenu.origEvent = event;\n            menu.contextMenu.cursorX = event.pageX;\n            menu.contextMenu.cursorY = event.pageY;\n            menu.contextMenu.show();\n        }\n    }\n\n    /**\n     * @ignore\n     * onMouseDown event handler for shape's container. If cursor points on some shape,\n     * forwards this event to this shape.\n     * @param event {MouseEvent} Mouse down event\n     */\n    this.mousedown = (event) => {\n        if (this.shapeOnCursor && event.buttons !== 2) {\n            const parent = this.shapeOnCursor.getRootParent(true);\n            if (parent && parent.options.groupChildShapes) {\n                this.shapeOnCursor = parent;\n            }\n            this.draggedShape = this.shapeOnCursor;\n            this.shapeOnCursor.eventListener.mousedown(createEvent(event,{target:this.shapeOnCursor}));\n        }\n    }\n\n    /**\n     * @ignore\n     * OnMouseUp event handler, triggered when user releases mouse button on shape or on shape container element\n     * @param event {MouseEvent} Event object\n     */\n    this.mouseup = (event) => {\n        if (!this.draggedShape) {\n            return\n        }\n        const dragshape = this.draggedShape;\n        if (event.buttons === 1 &&\n            dragshape.options.canAddPoints &&\n            !dragshape.draggedPoint &&\n            (dragshape.options.maxPoints === -1 || dragshape.points.length < dragshape.options.maxPoints)) {\n            dragshape.addPoint(event.clientX-dragshape.root.offsetLeft,\n                event.clientY-dragshape.root.offsetTop)\n        }\n        if (dragshape.draggedPoint) {\n            EventsManager.emit(ShapeEvents.POINT_DRAG_END,this.draggedShape,{point:dragshape.draggedPoint})\n            dragshape.draggedPoint.mouseup(event);\n            dragshape.draggedPoint = null;\n        } else {\n            EventsManager.emit(ShapeEvents.SHAPE_MOUSE_UP,dragshape,{});\n        }\n        this.draggedShape = null;\n        EventsManager.emit(ShapeEvents.SHAPE_MOVE_END,dragshape,{pos:dragshape.getPosition(true)});\n    }\n\n    /**\n     * @ignore\n     * Mouse move event listener. Runs when user moves mouse cursor in the container\n     * @param event {MouseEvent} Mouse move event object\n     */\n    this.mousemove = (event) => {\n        if (event.buttons !== 1) {\n            if (this.draggedShape) {\n                this.draggedShape.draggedPoint = null;\n            }\n            this.draggedShape = null;\n        }\n        if (!this.draggedShape) {\n            this.processShapesUnderCursor(event);\n            return\n        }\n        if (this.draggedShape) {\n            this.draggedShape.eventListener.mousemove(event);\n        }\n    }\n\n    /**\n     * @ignore\n     * onMouseOver event handler for shape's container. If cursor points on some shape,\n     * forwards this event to this shape.\n     * @param event {MouseEvent} Mouse over event\n     */\n    this.mouseover = (event) => {\n        if (this.shapeOnCursor) {\n            this.shapeOnCursor.eventListener.mouseover(createEvent(event, {target:this.shapeOnCursor}));\n        }\n    }\n\n    /**\n     * @ignore\n     * onMouseEnter event handler for shape's container. If cursor points on some shape,\n     * forwards this event to this shape.\n     * @param event {MouseEvent} Mouse enter event\n     */\n    this.mouseenter = (event) => {\n        if (this.shapeOnCursor) {\n            this.shapeOnCursor.eventListener.mouseenter(createEvent(event, {target:this.shapeOnCursor}));\n        }\n    }\n\n    /**\n     * @ignore\n     * onMouseOut event handler for shape's container. If cursor outs from some shape\n     * forwards this event to this shape.\n     * @param event {MouseEvent} Mouse out event\n     */\n    this.mouseout = (event) => {\n        if (this.shapeOnCursor) {\n            this.shapeOnCursor.eventListener.mouseout(createEvent(event,{target:event.target}));\n        }\n    }\n\n    /**\n     * @ignore\n     * onMouseLeave event handler for shape's container. If cursor leaves some shape area\n     * during resizing the shape in a simple mode, it redraws the shape with new size\n     * @param event {MouseEvent} Mouse leave event\n     */\n    this.mouseleave = (event) => {\n        if (this.draggedShape && this.draggedShape.draggedPoint &&\n            this.draggedShape.options.id.search(\"_resizebox\") !== -1) {\n            const id = this.draggedShape.options.id.replace(\"_resizebox\",\"\");\n            const destShape = this.findShapeById(id);\n            if (destShape && destShape.options.simpleMode) {\n                EventsManager.emit(ResizeBoxEvents.RESIZE_BOX_RESIZE, destShape.resizeBox, createEvent(event, {\n                    buttons: 0,\n                    oldPos: destShape.getPosition(true),\n                    newPos: destShape.resizeBox.getPosition()\n                }))\n            }\n        }\n    }\n\n    /**\n     * @ignore\n     * onClicj event handler for shape's container. If cursor points on some shape,\n     * forwards this event to this shape.\n     * @param event {MouseEvent} Mouse click event\n     */\n    this.click = (event) => {\n        if (this.shapeOnCursor) {\n            this.shapeOnCursor.eventListener.click(createEvent(event,{target:this.shapeOnCursor}));\n        }\n    }\n\n    /**\n     * @ignore\n     * Method that runs all the time when user moves cursor\n     * over the container. Used to set which shape is currently on\n     * cursor, which shape is currently under the mouse cursor\n     * and trigger mouseover/mouseout events for previous shape\n     * and current shape.\n     * @param event {MouseEvent} Mouse movement object\n     */\n    this.processShapesUnderCursor = (event) => {\n        const [clientX,clientY] = [event.clientX,event.clientY];\n        const shapeOnCursor = this.getShapeOnCursor(clientX, clientY);\n        if (this.shapeOnCursor && this.shapeOnCursor !== shapeOnCursor && this.shapeOnCursor.getShapeSvg()) {\n            this.shapeOnCursor.getShapeSvg().style.cursor = \"default\";\n            this.shapeOnCursor.eventListener.mouseout(createEvent(event,{target:this.shapeOnCursor}));\n        }\n        if (shapeOnCursor && shapeOnCursor !== this.shapeOnCursor) {\n            shapeOnCursor.eventListener.mouseover(createEvent(event,{target:shapeOnCursor}))\n        }\n        this.shapeOnCursor = shapeOnCursor;\n        if (this.shapeOnCursor) {\n            EventsManager.emit(ShapeEvents.SHAPE_MOUSE_MOVE,this.shapeOnCursor,createEvent(event));\n            this.shapeOnCursor.getShapeSvg().style.cursor = \"crosshair\";\n        }\n    };\n\n    /**\n     * Internal method used to determine the shape which is under\n     * mouse cursor right now.\n     * @param x {number} X coordinate of mouse cursor\n     * @param y {number} Y coordinate of mouse cursor\n     * @returns {SmartShape|null} Either SmartShape object or null\n     */\n    this.getShapeOnCursor = (x,y) => {\n        const shapes = Object.values(this.visibleShapes);\n        if (!shapes.length) {\n            return null;\n        }\n        const matchedShapes = shapes.filter(shape => shape.belongsToShape(x,y));\n        if (!matchedShapes.length) {\n            return null;\n        }\n        return matchedShapes\n            .reduce((prevShape,shape) => shape.options.zIndex >= prevShape.options.zIndex ? shape : prevShape);\n    }\n\n    /**\n     * Method used to export shapes to JSON.\n     * @param shapes {array} Array of [SmartShape](#SmartShape) objects to export\n     * @param compact {boolean} If this is true, then it will save only coordinates of\n     * points, but not their properties\n     * @returns {string} JSON string with array of SmartShape objects. If not specified, then exports all\n     * shapes, that exists in SmartShapeManager.\n     */\n    this.toJSON = (shapes=null,compact=false) => {\n        if (!shapes) {\n            shapes = this.getShapes();\n        }\n        shapes = shapes.filter(shape => (!shape.getParent()));\n        return JSON.stringify(shapes.map(shape => shape.getJSON(true,compact)))\n    }\n\n    /**\n     * Method loads shapes from JSON string, previously serialized by `toJSON` method\n     * @param root {HTMLElement} Container element to bind shapes to\n     * @param json {string|object} JSON data with shapes as an object or as a string with array of shape definitions\n     * @param progressCallback {function} Callback function that triggered after loading each shape in collection\n     * with ratio of processed items between 0 and 1\n     * @returns {array|null} array of loaded [SmartShape](#SmartShape) objects or null in case\n     * of JSON reading error\n     */\n    this.fromJSON = (root,json,progressCallback=null,emitCreateEvent=true) => {\n        let jsonObj = json;\n        if (typeof(jsonObj) === \"string\") {\n            jsonObj = readJSON(json);\n        }\n        if (!jsonObj || !jsonObj.length) {\n            return null;\n        }\n        const result = [];\n        for (let index in jsonObj) {\n            const obj = jsonObj[index];\n            if (obj.options.id && this.findShapeById(obj.options.id)) {\n                continue\n            }\n            result.push(new SmartShape().fromJSON(root,obj,true,emitCreateEvent));\n            if (progressCallback && typeof(progressCallback) === \"function\") {\n                progressCallback(index/jsonObj.length);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Method returns all shapes which have option with specified `name` and specified `value`\n     * @param name {string} Name of option to check\n     * @param value {any} Value of option to check\n     * @returns {array} Array of [SmartShape](#SmartShape) objects that match condition\n     */\n    this.findShapesByOptionValue = (name,value) => (\n        this.getShapes().filter(shape => shape.options[name] === value)\n    )\n\n    /**\n     * Method returns shape by specified ID\n     * @param id {string} ID to check\n     * @returns {SmartShape|null} SmartShape object or null if no shape with specified ID found\n     */\n    this.findShapeById = (id) => {\n        const result = this.findShapesByOptionValue(\"id\",id);\n        if (result && result.length) {\n            return result[0]\n        }\n        return null;\n    }\n\n    /**\n     * Method returns shape by specified name\n     * @param name {string} Name to check\n     * @returns {SmartShape|null} SmartShape object or null if no shape with specified name found\n     */\n    this.findShapeByName = (name) => {\n        const result = this.findShapesByOptionValue(\"name\",name);\n        if (result && result.length) {\n            return result[0]\n        }\n        return null;\n    }\n\n    /**\n     * @ignore\n     * Method used to clean manager object. Removes all shapes from list and\n     * attached containers event listeners\n     */\n    this.clear  = () => {\n        this.containerEventListeners.forEach(({container,name,listener}) => {\n            try {\n                container.removeEventListener(name,listener)\n            } catch (err) {\n                console.error(err);\n            }\n        })\n        this.containerEventListeners = [];\n        while (Object.values(this.shapes).length) {\n            Object.values(this.shapes)[0].destroy();\n        }\n    }\n\n    /**\n     * Method used to import collection of shapes from JSON array in GeoJSON format: https://geojson.org/\n     * @param container {HTMLElement} The HTML element to connect loaded shapes\n     * @param geoJSON {object} Javascript object in geoJSON format\n     * @param options {object} Options to tune the import process:\n     * `idField`: the field from \"properties collection of GeoJSON object that used as a shape ID,\n     * `nameField`: the field from \"properties\" collection of GeoJSON object that used as a shape name,\n     * `width`: the width to which loaded shapes should be scaled (if not specified then calc automatically based on height),\n     * `height`: the height to which loaded shapes should be scaled (if not specified then calc automatically based on width),\n     * `options`: shape options [SmartShape.options](#SmartShape+options) to set to each shape after import\n     * `scale`: scaling factor to which loaded shapes should be scaled (if not specified, width and height used,\n     * if nothing specified, then scales to 200px width if natural width is less than this)\n     * `fields`: which other fields to import from GeoJSON, in addition to `idField` and `nameField`\n     * @param progressCallback {function} Function that executes after loading each shape from file. If specified, it will\n     * be executed with three arguments: `currentShapeIndex` - index of current processed shape, `totalShapesLength` - total\n     * number of shapes in the collection, shape - SmartShape object of currently processed shape.\n     * @returns {array} Array of SmartShape objects\n     */\n    this.fromGeoJson = (container,geoJSON,options={},progessCallback=null) => {\n        return fromGeoJSON(container,geoJSON, options, progessCallback);\n    }\n\n    /**\n     * Method returns total count of shapes, managed by this manager\n     * @returns {number}\n     */\n    this.length = () => {\n        return Object.values(this.shapes).length;\n    }\n}\n\n/**\n * Events that SmartShapeManager can emit.\n * @param MANAGER_ADD_CONTAINER_LISTENERS Emits each time when add SmartShape event listeners to container for shapes\n * (usually after first shape added to it)\n * @param MANAGER_REMOVE_CONTAINER_LISTENERS Emits each time when remove SmartShape event listeners from container\n * for shapes (usually after last shape removed from container)\n * @enum {string}\n */\nexport const SmartShapeManagerEvents = {\n    MANAGER_ADD_CONTAINER_EVENT_LISTENERS: \"manager_add_container_event_listeners\",\n    MANAGER_REMOVE_CONTAINER_EVENT_LISTENERS: \"manager_remove_container_event_listeners\"\n}\n\n/**\n * Enumeration of event names, that can be emitted by [SmartShape](#SmartShape) object.\n @param CONTAINER_BOUNDS_CHANGED Emitted by shape when dimensions of container changed, e.g. browser\n window resized. Sends the event with the following fields: `bounds` -an object with the following fields:\n left:number,top:number,right:number,bottom:number, `points` - array of points ([SmartPoint](#SmartPoint) objects)\n with array of all points of this shape, which could be affected by this bounds change.\n @enum {string}\n */\nexport const ContainerEvents = {\n    CONTAINER_BOUNDS_CHANGED: \"CONTAINER_BOUNDS_CHANGED\"\n}\n\nexport default new SmartShapeManager().init();\n","import SmartShapeManager from \"../SmartShapeManager/SmartShapeManager.js\";\nimport {EventsManager, ShapeEvents} from \"../index.js\";\n/**\n * Class used as an extension to [SmartShape](#SmartShape) class to add\n * shape groups functionality. The feature works the following way:\n *\n * Each shape can have a children shapes. If shape has children, then\n * all actions, that user do with the shape propagated to all children:\n * when user drags the shape, all children draged with it, if user resizes the shape,\n * then all children resized with it. If user rotates the shape, then all shapes\n * rotates with it.\n *\n * You should not use this class directly. SmartShape class instantiates it.\n * When init, this class extends provided SmartShape object by adding all it's methods to it\n * and then you can use them right from your [SmartShape](#SmartShape) instance.\n * For example, methods `addChild` and `removeChild` declared here can be used\n * right from SmartShape object, e.g. `shape.addChild(child)`, `shape.removeChild(child)`\n * and all other methods, declared here.\n * @param shape {SmartShape} SmartShape object to extend\n * @constructor\n */\nfunction SmartShapeGroupHelper(shape) {\n\n    /**\n     * SmartShape object to extend\n     * @type {SmartShape}\n     */\n    this.shape = shape;\n\n    /**\n     * @ignore\n     * Method used to add specified shape as a child of current shape\n     * @param child {SmartShape} Shape to add\n     */\n    this.addChild = (child,emitEvent=true) => {\n        if (!this.shouldAddChild(child)) {\n            return\n        }\n        if (this.shape.options.displayMode !== child.options.displayMode) {\n            if (child.svg) {\n                child.switchDisplayMode(this.shape.options.displayMode);\n            } else {\n                child.options.displayMode = shape.options.displayMode;\n            }\n        }\n        this.shape.children.push(child);\n        if (emitEvent) {\n            EventsManager.emit(ShapeEvents.SHAPE_ADD_CHILD, this.shape, {child});\n        }\n    }\n\n    /**\n     * @ignore\n     * Method used to add specified children to current shape\n     * @param children {array} Array of [SmartShape][#SmartShape) objects\n     */\n    this.addChildren = (children=[]) => {\n        children.forEach(child => {\n            this.addChild(child,false)\n        })\n        EventsManager.emit(ShapeEvents.SHAPE_ADD_CHILD, this.shape, {children});\n    }\n\n    /**\n     * @ignore\n     * Method used to remove specified shape from children list of current shape\n     * @param child {SmartShape} SmartShape object to add\n     */\n    this.removeChild = (child) => {\n        this.shape.children.splice(this.shape.children.indexOf(child),1);\n        EventsManager.emit(ShapeEvents.SHAPE_REMOVE_CHILD,this.shape,{child});\n    }\n\n    /**\n     * @ignore\n     * Method removes all children of current shape\n     * @param all {boolean} If true, then it removes all children hierarchically\n     */\n    this.removeAllChildren = (all=false) => {\n        while (this.getChildren(all).length) {\n            this.removeChild(this.getChildren(all)[0])\n        }\n    }\n\n    /**\n     * @ignore\n     * Method returns array of children of current shape\n     * @param all {boolean} If true, then it returns deep list, including all children of each children of this shape\n     * @returns {array} Array of [SmartShape](#SmartShape) objects\n     */\n    this.getChildren = (all=false) => {\n        if (!all) {\n            return this.shape.children;\n        }\n        const result = []\n        result.push(...this.shape.children)\n        for (let child of result) {\n            result.push(...child.getChildren())\n        }\n        return result;\n    }\n\n    /**\n     * @ignore\n     * Method returns if specified shape is child of current shape\n     * @param child {SmartShape} Shape to check\n     * @param all {boolean} Should check include subchildren\n     */\n    this.hasChild = (child,all=false) => {\n        return child.guid !== this.guid && !!this.getChildren(all).find(item => item.guid === child.guid)\n    }\n\n    /**\n     * @ignore\n     * Internal method used to determine is it possible to add specified child\n     * to current shape\n     * @param child {SmartShape} Checked SmartShape object\n     * @returns {boolean} True if possible or false otherwise\n     */\n    this.shouldAddChild = (child) => {\n        if (!child || typeof(child) !== \"object\" || typeof(child.getChildren) === \"undefined\") {\n            return false;\n        }\n        if (this.shape.children.indexOf(child) !== -1) {\n            return false;\n        }\n        if (child === this.shape) {\n            return false;\n        }\n        if (child.getChildren().indexOf(this.shape) !== -1) {\n            return false;\n        }\n        if (child.getParent()) {\n            return false;\n        }\n        const parents = this.getParentsList();\n        return parents.indexOf(child) === -1;\n    }\n\n    /**\n     * @ignore\n     * Method returns parent of current shape or null\n     * @returns {SmartShape|null}\n     */\n    this.getParent = () => {\n        const shapes = SmartShapeManager.getShapes();\n        for (let item of shapes) {\n            if (item.getChildren().indexOf(this.shape) !== -1) {\n                return item\n            }\n        }\n        return null;\n    }\n\n    /**\n     * @ignore\n     * Method returns top parent of current shape\n     * @returns {SmartShape|null} Parent shape or null\n     */\n    this.getRootParent = (groupChildShapes= null) => {\n        let parents = this.getParentsList();\n        if (!parents.length) {\n            return null;\n        }\n        if (groupChildShapes !== null) {\n            parents = parents.filter(parent => parent.options.groupChildShapes === groupChildShapes)\n        }\n        return parents[parents.length-1];\n    }\n\n    /**\n     * @ignore\n     * Method returns a list of parents of current shape ordered from nearest to root\n     * @param plist {array} Temporary list of parents from previous recursive call\n     * @returns {array} Array of [SmartShape](#SmartShape) objects\n     */\n    this.getParentsList = (plist=[]) => {\n        const parent = this.getParent();\n        if (parent == null) {\n            return plist;\n        }\n        plist.push(parent);\n        return parent.getParentsList(plist)\n    }\n\n    /**\n     * @ignore\n     * Method overrides SmartShape's getPosition method to return position\n     * of all group if forGroup parameter is set\n     * @returns {object} Position object {left,top,right,bottom,width,height}\n     */\n    this.getPosition = () => {\n        let children = this.getChildren(true);\n        children.push(this.shape);\n        children = children.filter(child=>child.points.length);\n        if (!children.length) {\n            return {left:0,right:0,top:0,bottom:0,width:0,height:0};\n        }\n        const pos = {\n            left: children.map(item => item.left).reduce((minLeft,left) => left < minLeft ? left : minLeft),\n            top: children.map(item => item.top).reduce((minTop,top) => top < minTop ? top : minTop),\n            right: children.map(item => item.right).reduce((maxRight,right) => right > maxRight ? right : maxRight),\n            bottom: children.map(item => item.bottom).reduce((maxBottom,bottom) => bottom > maxBottom ? bottom : maxBottom)\n        }\n        pos.width = Math.abs(pos.right-pos.left) || 1;\n        pos.height = Math.abs(pos.bottom-pos.top) || 1;\n        return pos;\n    }\n}\n\nexport default SmartShapeGroupHelper;\n","import SmartShape from \"../SmartShape/SmartShape.js\";\nimport RotateBoxEventListener from \"./RotateBoxEventListener.js\";\nimport EventsManager from \"../events/EventsManager.js\";\nimport {ShapeEvents} from \"../SmartShape/SmartShapeEventListener.js\";\nimport {rotate_tl,rotate_tr,rotate_br,rotate_bl} from \"../../assets/graphics.js\";\nimport {mergeObjects, uuid} from \"../utils\";\n/**\n * Class represents a special type of shape, that shows the rectangle with markers on\n * it corners, used to rotate it. [See demo](https://code.germanov.dev/smart_shape/tests/prod/rotate_box.html).\n * Mostly used to rotate [SmartShape](#SmartShape) object, but also can be used as an independent shape\n * for tasks like rotating objects on a web page or select rectangular regions.\n * @constructor\n */\nfunction RotateBox() {\n\n    /**\n     * Left corner of rotate box\n     * @type {number}\n     */\n    this.left = 0;\n\n    /**\n     * Top corner of rotate box\n     * @type {number}\n     */\n    this.top = 0;\n\n    /**\n     * Right corner of rotate box\n     * @type {number}\n     */\n    this.right = 0;\n\n    /**\n     * Bottom corner of rotate box\n     * @type {number}\n     */\n    this.bottom = 0;\n\n    /**\n     * Width of rotate box\n     * @type {number}\n     */\n    this.width = 0;\n\n    /**\n     * Height of rotate box\n     * @type {number}\n     */\n    this.height = 0;\n\n    /**\n     * Underlying shape, that used to service this rotate box\n     * (draw, point event handling and so on)\n     * @type {SmartShape}\n     */\n    this.shape = null;\n\n    /**\n     * Global unique identifier of this object.\n     * Generated automatically\n     * @type {string}\n     */\n    this.guid = uuid()\n\n    /**\n     * Options of rotate box\n     * @param id {string} Unique ID or rotate box. If instantiated by [SmartShape](#SmartShape), then setup\n     * automatically\n     * @param shapeOptions {object} Options of underlying shape, that used to draw and manage this RotateBox. See\n     * [SmartShape.options](#SmartShape+options)\n     * @param zIndex {number} Order of element in a stack of HTML elements\n     * (https://www.w3schools.com/cssref/pr_pos_z-index.asp). Elements if higher z-index value placed on top.\n     * @type {object}\n     */\n    this.options = {\n        id: \"\",\n        shapeOptions: {\n            id: \"\",\n            canAddPoints: false,\n            canDeletePoints: false,\n            pointOptions: {\n                style: {\n                    borderWidth: \"0px\",\n                    cursor:\"pointer\",\n                    backgroundColor:'rgba(0,0,0,0)'\n                },\n                width:13,\n                height:13,\n                forceDisplay:true\n            },\n            style: {\n                \"stroke-width\":\"2px\",\n                \"stroke\":\"#aaaaaa\",\n                \"stroke-dasharray\": \"10\",\n                fill:\"none\",\n            }\n        },\n        zIndex: 1000\n    }\n\n    /**\n     * Event listener that handles event listening logic for this rotate box.\n     * Instance of [ResizeBoxEventListener](#ResizeBoxEventListener) class.\n     * @type {RotateBoxEventListener}\n     */\n    this.eventListener = null;\n\n    /**\n     * Left top marker point\n     * @type {SmartPoint}\n     */\n    this.left_top = null;\n\n    /**\n     * Left bottom marker point\n     * @type {SmartPoint}\n     */\n    this.left_bottom = null;\n\n    /**\n     * Right top marker point\n     * @type {SmartPoint}\n     */\n    this.right_top = null;\n\n    /**\n     * Right bottom marker point\n     * @type {SmartPoint}\n     */\n    this.right_bottom = null;\n\n    /**\n     * Method used to construct RotateBox object with specified coordinates and\n     * size, with specified `options`. Then it binds this object to specified `root`\n     * HTML node and displays it\n     * @param root {HTMLElement} HTML element that used as a container for this RotateBox\n     * @param left {number} Left corner of shape relative to container top left\n     * @param top {number} Top corner of shape relative to container top left\n     * @param width {number} Width of shape\n     * @param height {number} Height of shape\n     * @param options {object} Options used to setup RotateBox. See [here](#RotateBox+options).\n     * @returns {RotateBox} constucted RotateBox object\n     */\n    this.init = (root,left,top,width,height,options={}) => {\n        this.left = parseInt(left);\n        this.top = parseInt(top);\n        this.width = parseInt(width);\n        this.height = parseInt(height);\n        this.right = this.left + this.width;\n        this.bottom = this.top + this.height;\n        this.setOptions(options);\n        this.options.shapeOptions.id = this.options.id;\n        this.options.shapeOptions.canRotate = false;\n        this.options.shapeOptions.canScale = false;\n        this.shape = new SmartShape().init(root,mergeObjects({},this.options.shapeOptions),[]);\n        EventsManager.emit(ShapeEvents.SHAPE_CREATE, this.shape, {});\n        this.options.shapeOptions.pointOptions.bounds = this.shape.getBounds();\n        this.addPoints();\n        this.eventListener = new RotateBoxEventListener(this).run();\n        return this;\n    }\n\n    /**\n     * Method used to change options of RotateBox.\n     * @param options {object} Options object. See [here](#RotateBox+options).\n     */\n    this.setOptions = (options = {}) => {\n        if (!options || typeof(options) !== \"object\") {\n            return\n        }\n        this.options = mergeObjects(this.options,options);\n        this.options.shapeOptions.zIndex = this.options.zIndex || this.options.zIndex;\n        this.options.shapeOptions.id = this.options.id ? this.options.id : this.options.id;\n        if (this.shape) {\n            this.shape.setOptions(this.options.shapeOptions);\n        }\n    }\n\n    /**\n     * @ignore\n     * Method used to add marker points to RotateBox, that lately used to rotate the box\n     */\n    this.addPoints = () => {\n        this.left_top = this.shape.addPoint(this.left,this.top,{id:this.shape.guid+\"_left_top\",style:{backgroundImage: \"url('\"+rotate_tl+\"')\"}});\n        this.right_top = this.shape.addPoint(this.right,this.top,{id:this.shape.guid+\"_right_top\",style:{backgroundImage: \"url('\"+rotate_tr+\"')\"}});\n        this.right_bottom = this.shape.addPoint(this.right,this.bottom,{id:this.shape.guid+\"_right_bottom\",style:{backgroundImage: \"url('\"+rotate_br+\"')\"}});\n        this.left_bottom = this.shape.addPoint(this.left,this.bottom,{id:this.shape.guid+\"_left_bottom\",style:{backgroundImage: \"url('\"+rotate_bl+\"')\"}});\n    }\n\n    /**\n     * @ignore\n     * Method used to recalculate coordinates of marker points\n     * according to current RotateBox coordinates and dimensions.\n     */\n    this.adjustCoordinates = () => {\n        this.right = this.left + this.width;\n        this.bottom = this.top + this.height;\n        this.left_top.x = this.left;\n        this.left_top.y = this.top;\n        this.right_top.x = this.right;\n        this.right_top.y = this.top;\n        this.left_bottom.x = this.left;\n        this.left_bottom.y = this.bottom;\n        this.right_bottom.x = this.right;\n        this.right_bottom.y = this.bottom;\n    }\n\n    /**\n     * @ignore\n     * Internal method that used to calculate rotate box dimensions, based on point coordinates.\n     * Set left,top,right,bottom,width and height of rotate box.\n     */\n    this.calcPosition = () => {\n        this.shape.calcPosition();\n        this.left = this.shape.left;\n        this.top = this.shape.top;\n        this.bottom = this.shape.bottom;\n        this.right = this.shape.right;\n        this.width = this.shape.width;\n        this.height = this.shape.height;\n    }\n\n    /**\n     * Method used to get current position of Rotate Box\n     * @returns {object} Position with fields:\n     * `top`,`left`,`right`,`bottom`,`width`,`height`\n     */\n    this.getPosition = () => (\n        {top:this.top, left: this.left, bottom: this.bottom, right: this.right, width: this.width, height:this.height}\n    )\n\n    /**\n     * Method used to redraw rotate box\n     */\n    this.redraw = () => {\n        this.adjustCoordinates();\n        this.shape.setOptions(this.options.shapeOptions);\n        this.shape.redraw();\n    }\n\n    /**\n     * Method used to show Rotate Box if it has hidden\n     */\n    this.show = () => {\n        this.options.shapeOptions.visible = true;\n        this.shape.show();\n    }\n\n    /**\n     * Method used to hide Rotate Box\n     */\n    this.hide = () => {\n        this.options.shapeOptions.visible = false;\n        this.shape.hide();\n    }\n\n    /**\n     * Destroys the RotateBox. Destroys all points, removes event listeners and removes the shape from screen.\n     * But variable continue existing. To completely remove the shape,\n     * set the variable to 'null' after calling this method.\n     */\n    this.destroy = () => {\n        EventsManager.emit(ShapeEvents.SHAPE_DESTROY,this,{});\n        this.eventListener.destroy();\n        this.shape.destroy();\n    }\n\n    /**\n     * Uniform method that used to add event handler of specified type to this object.\n     * RotateBox can emit events, defined in [RotateBoxEvents](#RotateBoxEvents) enumeration. So, you can\n     * listen any of these events.\n     * @param eventName {string} - Name of event. Use one of name, defined in [RotateBoxEvents](#RotateBoxEvents)\n     * @param handler {function} - Function that used as an event handler\n     * @returns {function} - Pointer to added event handler. Should be used to remove event listener later.\n     */\n    this.addEventListener = (eventName,handler) => {\n        return this.eventListener.addEventListener(eventName,handler);\n    }\n\n    /**\n     * Uniform method that used to remove event handler, that previously added\n     * to this object.\n     * @param eventName {RotateBoxEvents|string} Name of event to remove listener from\n     * @param listener {function} Pointer to event listener, that added previously.\n     * It was returned from [addEventListener](#RotateBox+addEventListener) method.\n     */\n    this.removeEventListener = (eventName,listener) => {\n        this.eventListener.removeEventListener(eventName,listener);\n    }\n}\n\n\n\nexport default RotateBox;\n","import {Menus} from \"../../context_menu/src/index.js\";\nimport {getMousePos} from \"../events/functions.js\";\nimport {add,del,save,svg,png,copy,group,ungroup,move_to_top,move_to_bottom,horizontal,vertical,to_path,to_shapes,\n    base64_export,zoom_in,zoom_out,reset_zoom} from \"../../assets/graphics.js\";\nimport {SmartShapeDisplayMode} from \"./SmartShape.js\";\nimport {PngExportTypes} from \"./SmartShapeDrawHelper.js\";\n\n/**\n * Helper class that used to manage SmartShape context menu\n * that appear on right mouse click\n * Should not be instantiated directly. SmartShape automatically calls it\n * when needed\n * @param shape {SmartShape} The shape object to manage menu for\n * @constructor\n */\nexport default function SmartShapeContextMenu(shape) {\n\n    /**\n     * @ignore\n     * The shape object to manage menu for\n     * @type {SmartShape}\n     */\n    this.shape = shape;\n\n    /**\n     * @ignore\n     * Context menu object instance\n     * @type {object}\n     */\n    this.contextMenu = null;\n\n    /**\n     * @ignore\n     * Method executed to check if context menu should be initialized\n     * or destroyed depending on options of the shape\n     */\n    this.updateContextMenu = () => {\n        if (this.shape.options.hasContextMenu && !this.contextMenu) {\n            this.init();\n        } else if (!this.shape.options.hasContextMenu) {\n            this.contextMenu = null;\n        }\n        this.shape.contextMenu = this.contextMenu;\n        if (this.contextMenu) {\n            const itemsToAdd = this.getMenuItems();\n            for (let itemToAdd of itemsToAdd) {\n                if (!this.contextMenu.items.find(item => item.id === itemToAdd.id)) {\n                    this.contextMenu.addItem(itemToAdd.id,itemToAdd.title,itemToAdd.image);\n                }\n            }\n        }\n    }\n\n    /**\n     * @ignore\n     * Initializes context menu. Creates context menu and binds event\n     * listeners to it\n     */\n    this.init = () => {\n        if (shape.svg) {\n            this.contextMenu = Menus.create([], shape.svg,\"contextmenu\", {customHandler:()=> {return }});\n            if (shape.options.canAddPoints) {\n                this.contextMenu.addItem(\"i\"+shape.guid+\"_add_point\", \"Add Point\", add);\n            }\n            this.displayGroupItems();\n            this.setEventListeners();\n        }\n    }\n\n    this.getMenuItems = () => {\n        const items = [\n            {id: \"i\" + shape.guid + \"_move_to_top\", title: \"Move to Top\", image: move_to_top },\n            {id: \"i\" + shape.guid + \"_move_to_bottom\", title: \"Move to Bottom\", image: move_to_bottom },\n            {id: \"i\" + shape.guid + \"_flip_horizontal\", title: \"Flip Horizontal\", image: horizontal },\n            {id: \"i\" + shape.guid + \"_flip_vertical\", title: \"Flip Vertical\", image: vertical },\n            {id: \"i\" + shape.guid + \"_clone\", title: \"Clone\", image: copy},\n            {id: \"i\" + shape.guid + \"_export_json\", title: \"Export to JSON\", image: save},\n            {id: \"i\" + shape.guid + \"_export_svg\", title: \"Export to SVG\", image: svg},\n            {id: \"i\" + shape.guid + \"_export_png\", title: \"Export to PNG\", image: png},\n            {id: \"i\" + shape.guid + \"_get_base64\", title: \"Copy Base64 to clipboard\", image: base64_export},\n            {id: \"i\" + shape.guid + \"_destroy\", title: \"Destroy\", image: del}\n        ];\n        if (shape.options.canAddPoints) {\n            items.push({id:\"i\"+shape.guid+\"_add_point\", title:\"Add Point\", image:add});\n        }\n        if (shape.options.zoomable) {\n            items.push({id:\"i\"+shape.guid+\"_zoom_in\", title:\"Zoom in\", image:zoom_in});\n            items.push({id:\"i\"+shape.guid+\"_zoom_out\", title:\"Zoom out\", image:zoom_out});\n            items.push({id:\"i\"+shape.guid+\"_reset_zoom\", title:\"Reset zoom\", image:reset_zoom});\n        }\n        return items;\n    }\n\n    /**\n     * @ignore\n     * Method used to set up handler functions for context menu items\n     */\n    this.setEventListeners = () => {\n        this.setOnItemClickListener();\n        this.contextMenu.on(\"show\", () => {\n            this.displayGroupItems();\n        })\n    }\n\n    /**\n     * @ignore\n     * Method used to react on user click events on menu items\n     */\n    this.setOnItemClickListener = () => {\n        let destShape,parent\n        this.contextMenu.on(\"click\",(event) => {\n            switch (event.itemId) {\n                case \"i\"+this.shape.guid+\"_destroy\":\n                    this.onDestroyClick(event);\n                    break\n                case \"i\"+this.shape.guid+\"_add_point\":\n                    this.onAddPointClick(event);\n                    break;\n                case \"i\"+this.shape.guid+\"_clone\":\n                    this.onCloneClick(event);\n                    break;\n                case \"i\"+this.shape.guid+\"_export_json\":\n                    this.onExportJsonClick(event);\n                    break;\n                case \"i\"+this.shape.guid+\"_export_svg\":\n                    this.onExportSvgClick(event);\n                    break;\n                case \"i\"+this.shape.guid+\"_export_png\":\n                    this.onExportPngClick(event);\n                    break;\n                case \"i\"+this.shape.guid+\"_get_base64\":\n                    this.onGetBase64ToClipboardClick(event);\n                    break;\n                case \"i\"+this.shape.guid+\"_group\":\n                    parent = this.shape.getRootParent();\n                    destShape =  parent || this.shape;\n                    destShape.setOptions({groupChildShapes:true});\n                    destShape.switchDisplayMode(SmartShapeDisplayMode.DEFAULT);\n                    break;\n                case \"i\"+this.shape.guid+\"_ungroup\":\n                    parent = this.shape.getRootParent();\n                    destShape = parent || this.shape;\n                    destShape.setOptions({groupChildShapes:false,displayAsPath:false});\n                    destShape.switchDisplayMode(SmartShapeDisplayMode.DEFAULT);\n                    destShape.getChildren(true).forEach(child=>child.redraw())\n                    break;\n                case \"i\"+this.shape.guid+\"_topath\":\n                    parent = this.shape.getRootParent();\n                    destShape =  parent || this.shape;\n                    destShape.setOptions({groupChildShapes:true,displayAsPath:true});\n                    destShape.switchDisplayMode(SmartShapeDisplayMode.SELECTED);\n                    destShape.getChildren(true).forEach(child=>child.redraw())\n                    break;\n                case \"i\"+this.shape.guid+\"_toshapes\":\n                    parent = this.shape.getRootParent();\n                    destShape = parent || this.shape;\n                    destShape.setOptions({displayAsPath:false});\n                    destShape.switchDisplayMode(SmartShapeDisplayMode.SELECTED);\n                    destShape.getChildren(true).forEach(child=>child.redraw())\n                    break;\n                case \"i\"+this.shape.guid+\"_move_to_top\":\n                    this.onMoveToTopClick(event)\n                    break;\n                case \"i\"+this.shape.guid+\"_move_to_bottom\":\n                    this.onMoveToBottomClick(event)\n                    break;\n                case \"i\"+this.shape.guid+\"_flip_horizontal\":\n                    this.onFlipHorizontalClick(event)\n                    break;\n                case \"i\"+this.shape.guid+\"_flip_vertical\":\n                    this.onFlipVerticalClick(event)\n                    break;\n                case \"i\"+this.shape.guid+\"_zoom_in\":\n                    this.onZoomInClick(event)\n                    break;\n                case \"i\"+this.shape.guid+\"_zoom_out\":\n                    this.onZoomOutClick(event)\n                    break;\n                case \"i\"+this.shape.guid+\"_reset_zoom\":\n                    this.onResetZoomClick(event)\n                    break;\n            }\n        })\n    }\n\n    /**\n     * @ignore\n     * Method used to display Group/Ungroup menu item\n     * depending on number of children of current shape\n     * and depending on status of `groupChildShapes` option\n     */\n    this.displayGroupItems = () => {\n        let destShape = this.shape.getRootParent() ? this.shape.getRootParent() : this.shape;\n\n        if (!destShape.getChildren().length) {\n            this.contextMenu.removeItem(\"i\"+this.shape.guid+\"_group\");\n            this.contextMenu.removeItem(\"i\"+this.shape.guid+\"_ungroup\");\n            this.contextMenu.removeItem(\"i\"+this.shape.guid+\"_topath\");\n            this.contextMenu.removeItem(\"i\"+this.shape.guid+\"_toshapes\");\n            return\n        }\n        if (destShape.options.groupChildShapes) {\n            if (!this.contextMenu.items.find(item => item.id === \"i\"+this.shape.guid+\"_ungroup\")) {\n                this.contextMenu.addItem(\"i\" + this.shape.guid + \"_ungroup\", \"Ungroup\", ungroup);\n                this.contextMenu.removeItem(\"i\"+this.shape.guid+\"_group\");\n            }\n        } else {\n            if (!this.contextMenu.items.find(item => item.id === \"i\"+this.shape.guid+\"_group\")) {\n                this.contextMenu.removeItem(\"i\"+this.shape.guid+\"_ungroup\");\n                this.contextMenu.addItem(\"i\" + this.shape.guid + \"_group\", \"Group\", group);\n            }\n        }\n        if (destShape.options.displayAsPath) {\n            if (!this.contextMenu.items.find(item => item.id === \"i\"+this.shape.guid+\"_toshapes\")) {\n                this.contextMenu.addItem(\"i\" + this.shape.guid + \"_toshapes\", \"Convert to shapes\", to_shapes);\n                this.contextMenu.removeItem(\"i\"+this.shape.guid+\"_topath\");\n            }\n        } else {\n            if (!this.contextMenu.items.find(item => item.id === \"i\"+this.shape.guid+\"_topath\")) {\n                this.contextMenu.addItem(\"i\" + this.shape.guid + \"_topath\", \"Convert to path\", to_path);\n                this.contextMenu.removeItem(\"i\"+this.shape.guid+\"_toshapes\");\n            }\n        }\n    }\n\n    /**\n     * @ignore\n     * Runs when click on \"Add Point\" menu option\n     * @param event {MouseEvent} Event object\n     */\n    this.onAddPointClick = (event) => {\n        if (this.shape.options.maxPoints !== -1 && this.shape.points.length >= this.shape.options.maxPoints) {\n            return\n        }\n        const [x,y] = getMousePos(this.shape.root,event.cursorX,event.cursorY);\n        if (this.shape.points.length < 2) {\n            this.shape.addPoint(x, y);\n        } else {\n            const [point1,point2] = this.shape.getClosestLine(x,y);\n            if (this.shape.getPointIndex(point2) === 0) {\n                this.shape.addPoint(x,y)\n            } else {\n                let point = point1;\n                if (this.shape.getPointIndex(point2) > this.shape.getPointIndex(point1)) {\n                    point = point2;\n                }\n                this.shape.insertPoint(x, y, point)\n            }\n        }\n        if (this.shape.options.displayMode === SmartShapeDisplayMode.DEFAULT) {\n            this.shape.switchDisplayMode(SmartShapeDisplayMode.SELECTED);\n        }\n    }\n\n    /**\n     * @ignore\n     * Runs when click on \"Clone\" menu option\n     * @param _event {MouseEvent} Event object\n     */\n    this.onCloneClick = (_event) => {\n        let destShape = this.shape;\n        const parent = destShape.getRootParent();\n        if (parent && parent.options.groupChildShapes) {\n            destShape = parent;\n        }\n        const clone = destShape.clone({},destShape.options.groupChildShapes);\n        const pos = clone.getPosition(true);\n        clone.moveTo(pos.left+5,pos.top+5);\n        SmartShapeManager.activateShape(clone);\n    }\n\n    /**\n     * @ignore\n     * Runs when click on \"Export to JSON\" menu option\n     * @param _event {MouseEvent} Event object\n     */\n    this.onExportJsonClick = (_event) => {\n        let destShape = this.shape;\n        const parent = destShape.getRootParent();\n        if (parent && parent.options.groupChildShapes) {\n            destShape = parent;\n        }\n        const jsonString = destShape.toJSON(destShape.options.groupChildShapes);\n        const blob = new Blob([jsonString]);\n        this.saveToFile(blob,this.getExportFileName(\"json\"))\n    }\n\n    /**\n     * @ignore\n     * Runs when click on \"Export to SVG\" menu option\n     * @param _event {MouseEvent} Event object\n     */\n    this.onExportSvgClick = (_event) => {\n        let destShape = this.shape;\n        const parent = destShape.getRootParent();\n        if (parent && parent.options.groupChildShapes) {\n            destShape = parent;\n        }\n        const svgString = destShape.toSvg();\n        const blob = new Blob([svgString]);\n        this.saveToFile(blob,this.getExportFileName(\"svg\"))\n    }\n\n    /**\n     * @ignore\n     * Runs when click on \"Export to PNG\" menu option\n     * @param _event {MouseEvent} Event object\n     */\n    this.onExportPngClick = async(_event) => {\n        let destShape = this.shape;\n        const parent = destShape.getRootParent();\n        if (parent && parent.options.groupChildShapes) {\n            destShape = parent;\n        }\n        const blob = await destShape.toPng(PngExportTypes.BLOB);\n        this.saveToFile(blob,this.getExportFileName(\"png\"));\n    }\n\n    /**\n     * @ignore\n     * Runs when click on \"Copy Base64 to clipboard\" menu option\n     * @param _event {MouseEvent} Event object\n     */\n    this.onGetBase64ToClipboardClick = async(_event) => {\n        let destShape = this.shape;\n        const parent = destShape.getRootParent();\n        if (parent && parent.options.groupChildShapes) {\n            destShape = parent;\n        }\n        await window.navigator.clipboard.writeText(await destShape.toPng(PngExportTypes.DATAURL));\n    }\n\n    /**\n     * @ignore\n     * Runs when click on \"Destroy\" menu option\n     * @param _event {MouseEvent} Event object\n     */\n    this.onDestroyClick = (_event) => {\n        const parent = this.shape.getParent();\n        if (parent && parent.options.groupChildShapes) {\n            parent.destroy();\n        } else {\n            this.shape.destroy();\n        }\n    }\n\n    /**\n     * @ignore\n     * Runs when click on \"Move to top\" menu option\n     * @param _event {MouseEvent} Event object\n     */\n    this.onMoveToTopClick = (_event) => {\n        const parent = this.shape.getParent();\n        if (parent && parent.options.groupChildShapes) {\n            parent.moveToTop();\n        } else {\n            this.shape.moveToTop();\n        }\n    }\n\n    /**\n     * @ignore\n     * Runs when click on \"Move to bottom\" menu option\n     * @param _event {MouseEvent} Event object\n     */\n    this.onMoveToBottomClick = (_event) => {\n        const parent = this.shape.getParent();\n        if (parent && parent.options.groupChildShapes) {\n            parent.moveToBottom();\n        } else {\n            this.shape.moveToBottom();\n        }\n    }\n\n    /**\n     * @ignore\n     * Runs when click on \"Flip Horizontal\" menu option\n     * @param _event {MouseEvent} Event object\n     */\n    this.onFlipHorizontalClick = (_event) => {\n        const parent = this.shape.getParent();\n        if (parent && parent.options.groupChildShapes) {\n            parent.flip(true,false);\n        } else {\n            this.shape.flip(true,false);\n            this.shape.redraw();\n        }\n    }\n\n    /**\n     * @ignore\n     * Runs when click on \"Flip Vertical\" menu option\n     * @param _event {MouseEvent} Event object\n     */\n    this.onFlipVerticalClick = (_event) => {\n        const parent = this.shape.getParent();\n        if (parent && parent.options.groupChildShapes) {\n            parent.flip(false,true);\n            parent.redraw();\n            parent.redraw();\n        } else {\n            this.shape.flip(false,true);\n            this.shape.redraw();\n        }\n    }\n\n    /**\n     * @ignore\n     * Runs when click on \"Zoom In\" menu option\n     * @param _event {MouseEvent} Event object\n     */\n    this.onZoomInClick = (_event) => {\n        const destShape = this.shape.getRootParent() || this.shape;\n        destShape.zoomBy(1+destShape.options.zoomStep);\n        destShape.redraw();\n    }\n\n    /**\n     * @ignore\n     * Runs when click on \"Zoom out\" menu option\n     * @param _event {MouseEvent} Event object\n     */\n    this.onZoomOutClick = (_event) => {\n        const destShape = this.shape.getRootParent() || this.shape;\n        destShape.zoomBy(1-destShape.options.zoomStep);\n        destShape.redraw();\n    }\n\n    /**\n     * @ignore\n     * Runs when click on \"Reset zoom\" menu option\n     * @param _event {MouseEvent} Event object\n     */\n    this.onResetZoomClick = (_event) => {\n        const destShape = this.shape.getRootParent() || this.shape;\n        destShape.scaleBy(1/destShape.options.zoomLevel,1/destShape.options.zoomLevel);\n        destShape.options.zoomLevel = 1;\n        destShape.redraw();\n    }\n\n    /**\n     * @ignore\n     * Method used to show \"Save file\" dialog\n     * that saves specified `blob` as a file with name `filename`\n     * @param blob {object} BLOB object with file data\n     * @param filename {string} Name of file to save to\n     */\n    this.saveToFile = (blob,filename) => {\n        const url = window.URL.createObjectURL(blob);\n        const a = document.createElement(\"a\");\n        a.download = filename;\n        a.href = url;\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n        window.URL.revokeObjectURL(url);\n\n    }\n\n    /**\n     * @ignore\n     * Method used to generate filename based on shape ID and specified file extension\n     * @param extension {string} Extension of file\n     * @returns {string} Generated file name\n     */\n    this.getExportFileName = (extension) => {\n        const parent = this.shape.getRootParent();\n        const destShape = parent || this.shape;\n        return (destShape.options.id ? destShape.options.id : \"shape\")+\".\"+extension;\n    }\n\n    /**\n     * @ignore\n     * Method used to remove all event listeners, added to this object\n     */\n    this.removeMenuEventListeners = () => {\n        this.contextMenu.removeEventListener(\"show\", this.onShowListener);\n    }\n\n    /**\n     * @ignore\n     * Method used to destroy context menu and all dependent functions\n     */\n    this.destroyContextMenu = () => {\n        this.removeMenuEventListeners();\n        this.contextMenu.destroy();\n    }\n}\n","import SmartShapeManager from \"../SmartShapeManager/SmartShapeManager.js\";\nimport SmartPoint from \"../SmartPoint/SmartPoint.js\";\nimport SmartShapeDrawHelper, {PngExportTypes} from \"./SmartShapeDrawHelper.js\";\nimport SmartShapeGroupHelper from \"./SmartShapeGroupHelper.js\";\nimport SmartShapeEventListener, {ShapeEvents} from \"./SmartShapeEventListener.js\";\nimport ResizeBox from \"../ResizeBox/ResizeBox.js\";\nimport RotateBox from \"../RotateBox/RotateBox.js\";\nimport {\n    getRotatedCoords,\n    mergeObjects,\n    notNull,\n    uuid,\n    isPointInsidePolygon,\n    getOffset,\n    readJSON, abs\n} from \"../utils\";\nimport EventsManager from \"../events/EventsManager.js\";\nimport {\n    applyAspectRatio,\n    distance,\n    distanceFromLine,\n    flipPoint,\n    mapPointCords,\n    PointMapTypes\n} from \"../utils/geometry.js\";\nimport SmartShapeContextMenu from \"./SmartShapeContextMenu.js\";\n/**\n * SmartShape class. Used to construct shapes.\n * @constructor\n * @return SmartShape object that should be initialised using `init` method.\n */\nfunction SmartShape() {\n\n    /**\n     * The HTML container element to which the shape will be injected. This can be any block element,\n     * that can have children (div,span etc.)\n     * @type {HTMLElement}\n     */\n    this.root = null\n\n    /**\n     * Array of points of shape polygon. Each item of array is [SmartPoint](#SmartPoint) object.\n     * @type {array}\n     */\n    this.points = [];\n\n    /**\n     * [SVG element](https://developer.mozilla.org/en-US/docs/Web/SVG/Element), which used as a backend for shape.\n     * SmartShape constructs SVG element based on provided point coordinates and options.\n     * @type {HTMLOrSVGElement}\n     */\n    this.svg = null;\n\n    /**\n     * [SVG element](https://developer.mozilla.org/en-US/docs/Web/SVG/Element), which used as a backend for shape.\n     * SVG Polygon element that defines a shape inside <SVG> element\n     * @type {HTMLOrSVGElement}\n     */\n    this.polygon = null;\n\n    /**\n     * Helper object that used to manage children shapes of this shape\n     * @type {SmartShapeGroupHelper}\n     */\n    this.groupHelper = null;\n\n    this.eventListener = null;\n\n    /**\n     * Options of shape as an object. Can have the following parameters.\n     * @param id {string} Unique ID of shape's SVG HTML element. By default, empty.\n     * @param name {string} Name of shape. By default, `Unnamed shape`\n     * @param maxPoints {number} Number of points, which possible to add to the shape interactively. By default `-1`,\n     * which means Unlimited\n     * @param style {object} CSS styles, that will be applied to underlying polygon SVG element. Using CSS styles and\n     * classes is an alternative way to specify options of SVG elements:\n     * https://jenkov.com/tutorials/svg/svg-and-css.html,\n     * https://css-tricks.com/svg-properties-and-css/\n     * @param fillGradient {object} Defines gradient object, that should be used to fill the shape. This could be either\n     * linear gradient or radial gradient. To make it work, it's required to set 'fill:#gradient' inside style.\n     * See demo [here](https://github.com/AndreyGermanov/smart_shape/blob/main/tests/dev/gradient.html).\n     * @param fillImage {object} Defines image fill object to fill the shape with image. Should contain following fields:\n     * `href` - URL to image, `width` - width of image, `height` - height of image\n     * To make image fill work, it's required to set 'fill:#image' inside style\n     * See demo [here](https://github.com/AndreyGermanov/smart_shape/blob/main/tests/dev/fillimage.html).\n     * @param filters {object} Object, that defines a set of SVG filters, that will be applied to this shape.\n     * Keys are names of filters, for example `feDropShadow` for drop-shadow filter. Values are objects with attributes\n     * for each filter. All attributes, that supported by each particular SVG filter are supported. See more about SVG\n     * filters [here](#https://developer.mozilla.org/en-US/docs/Web/SVG/Element/filter).\n     * The demo of applying feDropShadow filter see\n     * [here](https://github.com/AndreyGermanov/smart_shape/blob/main/tests/dev/svgfilters.html)\n     * @param classes {string} CSS class names, that will be applied to underlying polygon SVG element.\n     * @param canDragShape {boolean} Is it allowed to drag shape. Default `true`.\n     * @param canAddPoints {boolean} Is it allowed to add points to the shape interactively,\n     * by mouse double-click on the screen. Default `false`.\n     * @param canScale {boolean} Is it allowed to scale this shape. If true, then [ResizeBox](#ResizeBox) appears\n     * around shape and user can drag it to resize shape in different directions\n     * @param canRotate {boolean} Is it allowed to rotate this shape. If true, then [RotateBox](#RotateBox) appears\n     * around shape and user can drag it to rotate shape in different directions\n     * @param pointOptions {object} Default options for created points. See  [options](#SmartPoint+options)\n     * property of `SmartPoint` object.\n     * @param zIndex {number} Order of element in a stack of HTML elements\n     * (https://www.w3schools.com/cssref/pr_pos_z-index.asp). Elements if higher z-index value placed on top.\n     * @param bounds {object} Bounds for shape movement and points dragging. This is an object with `left`, `top`, `right`\n     * and `bottom` values. By default, all values are equal -1, which means that bounds not specified. If bounds not\n     * specified, then left, top, right and bottom of container element will be used for this\n     * @param visible {boolean} Shape is visible or not. By default, `true`.\n     * @param displayMode {SmartShapeDisplayMode} In which mode the shape is displayed: default mode or with resize\n     * or rotate box around it. See [SmartShapeDisplayMode](#SmartShapeDisplayMode)\n     * @param managed {boolean} Should this shape be managed by [SmartShapeManager](#SmartShapeManager). Default: true\n     * @param minWidth {number} Minimum width of shape. By default `-1` - unlimited\n     * @param minHeight {number} Minimum height of shape. By default `-1` - unlimited\n     * @param maxWidth {number} Maximum width of shape. By default `-1` - unlimited\n     * @param maxHeight {number} Maximum width of shape. By default `-1` - unlimited\n     * @param hasContextMenu {boolean} Should the shape have context menu. False by default\n     * @param minPoints {number} Minimum number of points in the shape. Default: 3.\n     * @param groupChildShapes {boolean} Should child shapes be grouped and move/resize/rotate/destroy together.\n     * True by default\n     * @param moveToTop {boolean} Should shape go to top based on \"zIndex\" when user clicks on it. True by default\n     * @param compactExport {boolean} If this is true, then it will save only coordinates of\n     * points, but not their properties during export to JSON using .toJSON() method\n     * @param forceCreateEvent {boolean} Internal parameter used by JSON import.\n     * By default, if shape does not have point when create, it does not emit SHAPE_CREATE event on init() method.\n     * If this option set to true, then init() methods emits SHAPE_CREATE event event for empty shapes.\n     * @param initialPoints {array} 2D array of initial coordinates of points in format [ [x,y], [x,y] ...]\n     * If this shape loaded from external resource and then modified, this array is a way to return back to initial\n     * coordinates\n     * @param zoomLevel {number} Current zoom level of shape. By default it is 1, which means that shape is not zoomed.\n     * If less than 1, than shape decreased, if greater than 1, then shape increased.\n     * to the bottom. Helps to move entire figure without need to change coordinates of each point. Default: `0`\n     * @param zoomable {boolean} Determines if shape can be zoomed in or out using context menu or mouse wheel.\n     * True by default\n     * @parap zoomStep {number} Defines to which extend the shape will be increased/decreased when apply Zoom in/Zoom out\n     * command from menu or drag mouse wheel. By default 0.1 .\n     to the bottom. Helps to move entire figure without need to change coordinates of each point. Default: `0`\n     * @param offsetX {number} Offset on X axis that shape moved from initial position when initially loaded from external source.\n     * @param offsetY {number} Offset on Y axis that shape moved from initial position when initially loaded.\n     * @param displayAsPath {boolean} Should display all children of shape as a single SVG path. Default - false.\n     * @param simpleMode {boolean} Simple load mode (do not create point objects)\n     * @param scaleFactorX {number} Scaling factor that shows to which extent the shape was scaled in current moment\n     * after create by X axis. By default 1 (not scaled)\n     * @param scaleFactorY {number} Scaling factor that shows to which extent the shape was scaled in current moment\n     * after create by Y axis. By default 1 (not scaled)\n     * @param flippedX {boolean}  Shows that the shape was flipped by X axis after create. By default false.\n     * @param flippedY {boolean}  Shows that the shape was flipped by Y axis after create. By default false.\n     * @param rotateAngle {number} Shows the angle to which the shape was rotated after create. By default 0.\n     * @type {object}\n     */\n    this.options = {\n        id: \"\",\n        name: \"Unnamed shape\",\n        maxPoints: -1,\n        fillGradient: null,\n        fillImage: null,\n        filters:{},\n        canDragShape: true,\n        canAddPoints: false,\n        canScale: false,\n        canRotate: false,\n        offsetX: 0,\n        offsetY: 0,\n        classes: \"\",\n        style: {\n            fill:\"none\",\n            \"fill-opacity\":1,\n            \"stroke\":\"black\",\n            \"stroke-width\":2,\n            \"stroke-opacity\":1,\n            \"stroke-dasharray\":0,\n            \"stroke-linecap\":\"square\"\n        },\n        pointOptions:{canDrag:true},\n        zIndex: 1000,\n        bounds: {left:-1,top:-1,right:-1,bottom:-1},\n        visible:true,\n        displayMode: SmartShapeDisplayMode.DEFAULT,\n        managed: true,\n        minWidth: -1,\n        minHeight : -1,\n        maxWidth: -1,\n        maxHeight: -1,\n        hasContextMenu:true,\n        minPoints: 3,\n        groupChildShapes: true,\n        moveToTop: true,\n        compactExport: false,\n        forceCreateEvent: false,\n        zoomLevel:1,\n        zoomable: true,\n        zoomStep: 0.1,\n        initialPoints: [],\n        displayAsPath: false,\n        simpleMode: false,\n        scaleFactorX: 1,\n        scaleFactorY: 1,\n        rotateAngle: 0,\n        flippedX: false,\n        flippedY: false,\n    };\n\n    /**\n     * Left position of the shape relative to container top left.\n     * (Read-only, calculated automatically based on points coordinates)\n     * @type {number}\n     */\n    this.left = 0;\n\n    /**\n     * Top position of the shape relative to container top left.\n     * (Read-only, calculated automatically based on points coordinates)\n     * @type {number}\n     */\n    this.top = 0;\n\n    /**\n     * Right position of the shape relative to container top left.\n     * (Read-only, calculated automatically based on points coordinates)\n     * @type {number}\n     */\n    this.right = 0;\n\n    /**\n     * Bottom position of the shape relative to container top left.\n     * (Read-only, calculated automatically based on points coordinates)\n     * @type {number}\n     */\n    this.bottom = 0;\n\n    /**\n     * Width of shape\n     * (Read-only, calculated automatically based on points coordinates)\n     * @type {number}\n     */\n    this.width = 0;\n\n    /**\n     * Height of shape\n     * (Read-only, calculated automatically based on points coordinates)\n     * @type {number}\n     */\n    this.height = 0;\n\n    /**\n     * Internal global unique identifier of shape. Generated automatically.\n     * @type {string}\n     */\n    this.guid = uuid();\n\n    /**\n     * Array of children of current shape\n     * @type {array}\n     */\n    this.children = [];\n\n    /**\n     * [ResizeBox](#ResizeBox) component, used to scale shape if\n     * `canScale` option enabled\n     * @type {ResizeBox}\n     */\n    this.resizeBox = null;\n\n    /**\n     * [RotateBox](#RotateBox) component, used to rotate shape if\n     * `canRotate` option enabled\n     * @type {RotateBox}\n     */\n    this.rotateBox = null;\n\n    /**\n     * Initial center of shape, when user started rotating the shape\n     * using Rotate Box\n     * @type {array} Coordinates as an array [x,y]\n     */\n    this.initCenter = null;\n\n    /**\n     * Context menu of shape that appear on right mouse click\n     * if `hasContextMenu` option is true\n     * @type {SmartShapeContextMenu}\n     */\n    this.shapeMenu = null;\n\n    /**\n     * Method used to construct SmartShape object with specified `points` and\n     * with specified `options`.\n     * Then it binds this object to specified `root` HTML node and displays it\n     * @param root {HTMLElement} HTML DOM node af a container element\n     * @param options {object} Options object to construct this shape ([see above](#SmartShape+options))\n     * @param points {array} 2D Array of points for shape polygon.\n     * Each element is [x,y] coordinate array\n     * @param show {boolean} Should display the shape by default. Default: true\n     * @returns {object} constructed SmartShape object\n     */\n    this.init = (root,options= null,points= null,show= true) => {\n        if (!root) {\n            console.error(\"Root HTML node not specified. Could not create shape.\")\n            return\n        }\n        if (SmartShapeManager.getShape(this)) {\n            console.error(\"This shape already initialized\");\n            return\n        }\n        this.root = root;\n        this.root.style.position = \"relative\";\n        if (this.options.hasContextMenu && (typeof(options.hasContextMenu)===\"undefined\" || options.hasContextMenu)) {\n            this.shapeMenu = new SmartShapeContextMenu(this)\n        }\n        this.eventListener = new SmartShapeEventListener(this);\n        this.setOptions(options);\n        this.groupHelper = new SmartShapeGroupHelper(this);\n        if (points && points.length) {\n            this.setupPoints(points, mergeObjects({}, this.options.pointOptions));\n            this.redraw();\n        }\n        this.eventListener.run();\n        if (this.shapeMenu && typeof(this.shapeMenu) === \"object\") {\n            this.shapeMenu.updateContextMenu();\n        }\n        if (show) {\n            this.applyDisplayMode();\n        }\n        if (points && points.length || this.options.forceCreateEvent) {\n            EventsManager.emit(ShapeEvents.SHAPE_CREATE, this, {});\n        }\n        return this;\n    }\n\n    /**\n     * Set specified options to the shape. You may not set all options, that exist, but only what you want to change.\n     * Options that you set by this method will be merged with already active options.\n     * @param options {object} Options object, [described above](#SmartShape+options)\n     */\n    this.setOptions = (options) => {\n        if (!options || typeof(options) !== \"object\") {\n            return\n        }\n        if (notNull(options.visible) && options.visible !== this.options.visible) {\n            if (!this.options.simpleMode) {\n                this.points.filter(point => typeof (point.setOptions) === \"function\")\n                    .forEach(point => point.options.visible = options.visible);\n            }\n            this.resizeBox && this.resizeBox.setOptions({shapeOptions:{visible:options.visible}});\n            this.rotateBox && this.rotateBox.setOptions({shapeOptions:{visible:options.visible}});\n        }\n        if (notNull(options.fillGradient)) {\n            this.options.fillGradient = {};\n        }\n        if (notNull(options.fillImage)) {\n            this.options.fillImage = {};\n        }\n        this.options = mergeObjects(this.options,options);\n        if (!this.options.simpleMode) {\n            this.points.filter(point => typeof (point.setOptions) === \"function\").forEach(point => {\n                point.setOptions(mergeObjects({}, this.options.pointOptions))\n                point.options.bounds = this.getBounds();\n                if (point.options.zIndex <= this.options.zIndex) {\n                    point.options.zIndex = this.options.zIndex + 1;\n                }\n                point.redraw();\n            })\n        }\n        if (this.shapeMenu && typeof(this.shapeMenu) === \"object\") {\n            this.shapeMenu.updateContextMenu();\n        }\n    }\n\n    /**\n     * @ignore\n     * Internal function that set points of figure\n     * @param points {array} 2D array of points to add. Each point is array of [x,y] coordinates\n     * @param pointOptions {object} Array of points options. Described in  [SmartPoint.options](#SmartPoint+options).\n     * Can be empty, in this case default `SmartShape.options.pointOptions` will be used,\n     * or default options of SmartPoint class itself.\n     */\n    this.setupPoints = (points,pointOptions={}) => {\n        this.points = [];\n        this.isNewObject = true;\n        this.addPoints(points,mergeObjects({},pointOptions));\n        this.isNewObject = false;\n        this.calcPosition();\n    }\n\n    /**\n     * Add point to shape.\n     * @param x {number} X coordinate relative to container left corner\n     * @param y {number} Y coordinate relative to container top corner\n     * @param pointOptions {object} Array of point options. Described in\n     * [SmartPoint.options](#SmartPoint+options). Can be empty,\n     * in this case default `SmartShape.options.pointOptions` will be used,\n     * or default options of SmartPoint class itself.\n     * @returns {object} [SmartPoint](#SmartPoint) object of added point\n     */\n    this.addPoint = (x,y,pointOptions= {}) => {\n        let point = this.putPoint(x, y,mergeObjects({},this.options.pointOptions, pointOptions));\n        if (!point) {\n            return null;\n        }\n        if (this.options.displayMode !== SmartShapeDisplayMode.DEFAULT) {\n            pointOptions.createDOMElement = true;\n        }\n        point = point.init(x, y, pointOptions);\n        if (point.element) {\n            try {\n                this.root.appendChild(point.element);\n            } catch (err) {}\n            point.updateContextMenu();\n        }\n        this.redraw();\n        if (this.options.hasContextMenu && !this.shapeMenu.contextMenu) {\n            this.shapeMenu.updateContextMenu();\n        }\n        return point;\n    }\n\n    /**\n     * Insert point to shape before specified point\n     * @param x {number} X coordinate relative to container left corner\n     * @param y {number} Y coordinate relative to container top corner\n     * @param beforePoint {array|SmartPoint} Coordinates of point as [x,y] array or as a SmartPoint object,\n     * before which point should be inserted\n     * @param pointOptions {object} Array of point options. Described in\n     * [SmartPoint.options](#SmartPoint+options). Can be empty,\n     * in this case default `SmartShape.options.pointOptions` will be used,\n     * or default options of SmartPoint class itself.\n     * @returns {object} [SmartPoint](#SmartPoint) object of added point\n     */\n    this.insertPoint = (x,y,beforePoint,pointOptions= {}) => {\n        let point = this.putPoint(x, y,mergeObjects({}, this.options.pointOptions, pointOptions),beforePoint);\n        if (!point) {\n            return null;\n        }\n        if (this.options.displayMode !== SmartShapeDisplayMode.DEFAULT) {\n            pointOptions.createDOMElement = true;\n        }\n        point = point.init(x, y, pointOptions);\n        try {\n            this.root.appendChild(point.element);\n        } catch (err) {};\n        point.updateContextMenu();\n        this.redraw();\n        if (this.options.hasContextMenu && !this.shapeMenu.contextMenu) {\n            this.shapeMenu.updateContextMenu();\n        }\n        return point;\n    }\n\n    /**\n     * Adds specified points to shape.\n     * @param points {array} 2D array of points to add. Each point is array of [x,y] coordinates\n     * @param pointOptions {object} Points options. Described in\n     * [SmartPoint.options](#SmartPoint+options). Can be empty,\n     * in this case default `SmartShape.options.pointOptions` will be used,\n     * or default options of SmartPoint class itself.\n     * */\n    this.addPoints = (points,pointOptions= {}) => {\n        if (!points || typeof(points) !== \"object\") {\n            return\n        }\n        if (this.options.simpleMode) {\n            if (typeof(points[0].x) !== \"undefined\") {\n                this.points = mergeObjects({},points);\n            } else {\n                this.points = points.map(point => ({x: point[0], y: point[1]}))\n            }\n        } else {\n            for (let point of points) {\n                const x = typeof(point.x) !== \"undefined\" ? point.x : point[0];\n                const y = typeof(point.y) !== \"undefined\" ? point.y : point[1];\n                if (this.options.displayMode !== SmartShapeDisplayMode.DEFAULT) {\n                    pointOptions.createDOMElement = true;\n                }\n                const p = this.putPoint(x, y,\n                    mergeObjects({}, this.options.pointOptions,pointOptions)\n                )\n                if (p) {\n                    p.init(p.x, p.y, pointOptions)\n                    if (p.element) {\n                        try {\n                            this.root.appendChild(p.element);\n                            p.redraw();\n                        } catch (err) {}\n                    }\n                }\n            }\n        }\n\n        if (this.options.hasContextMenu && !this.shapeMenu.contextMenu) {\n            this.shapeMenu.updateContextMenu();\n        }\n    }\n\n    /**\n     * @ignore\n     * Internal method that used to add point to the shape\n     * @param x {number} X coordinate relative to container left corner\n     * @param y {number} Y coordinate relative to container top corner\n     * @param pointOptions - Points options. Described in\n     * [SmartPoint.options](#SmartPoint+options). Can be empty,\n     * in this case default `SmartShape.options.pointOptions` will be used,\n     * or default options of SmartPoint class itself.\n     * @param beforePoint {array|SmartPoint} Coordinates of point as [x,y] array or as a SmartPoint object,\n     * before which point should be inserted\n     * @returns {object} [SmartPoint](#SmartPoint) object of added point\n     */\n    this.putPoint = (x,y,pointOptions= {}, beforePoint=null) => {\n        let beforeIndex = this.getPointIndex(beforePoint);\n        if (beforePoint && beforeIndex === -1) {\n            return null;\n        }\n        if (!this.isNewObject && this.findPoint(x,y)) {\n            return null;\n        }\n        pointOptions.bounds = this.getBounds();\n        pointOptions.zIndex = this.options.zIndex+1;\n        const point = new SmartPoint();\n        point.x = x;\n        point.y = y;\n        if (this.options.displayMode !== SmartShapeDisplayMode.DEFAULT) {\n            pointOptions.createDOMElement = true;\n        }\n        point.setOptions(pointOptions);\n        if (beforePoint && beforeIndex !== -1) {\n            this.points.splice(beforeIndex ,0,point)\n        } else {\n            this.points.push(point);\n        }\n        return point;\n    }\n\n    /**\n     * Method returns the closest point from specified array of points or all points of this shape\n     * to specified x,y coordinates.\n     * @param x {number} X coordinate\n     * @param y {number} Y coordinate\n     * @param points {array} Array of coordinates of points to. Each coordinate is [x,y] array. If not specified\n     * then all points of this shapes used.\n     * @returns {null|Object|*}\n     */\n    this.getClosestPoint = (x,y,points=null) => {\n        if (!points) {\n            points = this.getPointsArray();\n        }\n        if (!points || !points.length) {\n            return null;\n        }\n        points = points.filter(([x1,y1]) => !isNaN(parseFloat(x1)) && !isNaN(parseFloat(y1)));\n        if (points.length === 1) {\n            return this.points[0];\n        }\n        if (!points || !points.length) {\n            return null;\n        }\n        const cords = points\n            .map(([x1,y1]) => ({x:x1,y:y1,d:distance(x,y,x1,y1)}))\n            .reduce((s1,s2) => s1.d < s2.d ? s1 : s2);\n        return this.findPoint(cords.x,cords.y);\n    }\n\n    /**\n     * @ignore\n     * This method returns the line which is closest to specified (x,y) point.\n     * @param x X coordinate\n     * @param y Y coordinate\n     * @returns {object} Object with fields `point1` - Start point of line,\n     * `point2` - end point of line, `d` - distance from this line to point (x,y)\n     */\n    this.getClosestLine = (x,y) => {\n        return this.points\n            .map((point1,index) => {\n                let point2 = null;\n                if (index < this.points.length-1) {\n                    point2 = this.points[index+1];\n                } else {\n                    point2 = this.points[0];\n                }\n                return [point1,point2,distanceFromLine(x,y,point1.x,point1.y,point2.x,point2.y)]\n            })\n            .filter(l => l[2]>=0)\n            .reduce((l1,l2) => l1[2] < l2[2] ? l1 : l2)\n    }\n\n    /**\n     * Method returns and index of specified point in points array\n     * @param point {array|SmartPoint} Point to find index for. Can be specified either as\n     * coordinates array [x,y] or as a SmartPoint object\n     * @returns {number} Index of point or -1 if not found\n     */\n    this.getPointIndex = (point) => {\n        if (point && point.length) {\n            if (point.length !== 2) {\n                return -1\n            }\n            point = this.findPoint(...point);\n        }\n        if (!point || !this.isShapePoint(point)) {\n            return -1;\n        }\n        return this.points.indexOf(point);\n    }\n\n    /**\n     * Method used to delete all points from shape\n     */\n    this.deleteAllPoints = () => {\n        if (this.options.simpleMode) {\n            this.points = [];\n        } else {\n            while (this.points.length) {\n                this.points[0].destroy();\n            }\n        }\n    }\n\n    /**\n     * Method used to delete point with specified coordinates.\n     * If point with specified coordinates not found then just\n     * do nothing\n     * @param x {number} X coordinate of point\n     * @param y {number} Y coordinate of point\n     */\n    this.deletePoint = (x,y) => {\n        if (this.points.length-1 < this.options.minPoints) {\n            return\n        }\n        const point = this.findPoint(x,y);\n        if (point && typeof(point.destroy) === \"function\") {\n            point.destroy();\n        } else {\n            this.points.splice(this.points.indexOf(point),1);\n        }\n    }\n\n    /**\n     * Method returns SmartPoint object of point with specified coordinates or null, if point not found\n     * @param x {number} X coordinate of point\n     * @param y {number} Y coordinate of point\n     * @returns {null|object}  [SmartPoint](#SmartPoint) object instance of point,\n     * or null if point does not exist\n     */\n    this.findPoint = (x,y) => {\n        const point = this.points.find(item => item.x === x && item.y === y)\n        if (typeof(point) === \"undefined\" || !point) {\n            return null;\n        }\n        return point\n    }\n\n    /**\n     * Method returns SmartPoint object for point with specified ID or null, if point not found\n     * @param id {string} ID of point, provided to it as an options\n     * @returns {null|object} [SmartPoint](#SmartPoint) object instance of point,\n     * or null if point does not exist\n     */\n    this.findPointById = (id) => {\n        const point = this.points.find(item => item.options && item.options.id === id)\n        if (typeof(point) === \"undefined\" || !point) {\n            return null;\n        }\n        return point\n    }\n\n    /**\n     * Returns 2D array of points coordinates in format [ [x,y], [x,y], [x,y] ... ].\n     * @returns {array} 2D array of points in format [ [x,y], [x,y], [x,y] ... ]\n     */\n    this.getPointsArray = () => {\n        let result = [];\n        if (this.points && typeof(this.points) === \"object\" && this.points.length) {\n            result = this.points.map(point => [point.x,point.y])\n        }\n        return result;\n    }\n\n    /**\n     * Moves shape to specific position. It only changes coordinates of points, but do not\n     * redraw the shape on new position. So, you need to call `redraw` yourself after move.\n     * @param x {number} new X coordinate\n     * @param y {number} new Y coordinate\n     * @param redraw {boolean} should the function redraw the shape after move. True by default\n     * @param fast {boolean} if true, then only change shape dimensions without recalculate points\n     */\n    this.moveTo = (x,y,redraw= true,respectBounds=true,fast=false) => {\n        const bounds = this.getBounds();\n        const pos = this.getPosition(this.options.groupChildShapes);\n        let newX = x;\n        let newY = y;\n        if (respectBounds) {\n            newX = x + pos.width > bounds.right ? bounds.right - pos.width : x;\n            newY = y + pos.height > bounds.bottom ? bounds.bottom - pos.height : y;\n        }\n        this.moveBy(newX-pos.left,newY-pos.top, redraw, fast);\n        this.calcPosition();\n    }\n\n    /**\n     * Moves shape by specified number of pixels by X and Y.\n     * @param stepX {number} number of pixels to move horizontally\n     * @param stepY {number} number of pixes to move vertically\n     * @param redraw {boolean} should the function redraw the shape after move. True by default\n     * @param fast {boolean} if true, then only change shape dimensions without recalculate points\n     */\n    this.moveBy = (stepX, stepY,redraw=true,fast=false) => {\n        for (let index in this.points) {\n            this.points[index].x += stepX;\n            this.points[index].y += stepY;\n            if (!this.options.simpleMode && redraw && typeof (this.points[index].redraw) === \"function\") {\n                this.points[index].redraw();\n            }\n        }\n        this.options.offsetX += stepX;\n        this.options.offsetY += stepY;\n        this.left += stepX;\n        this.top += stepY;\n        this.right += stepX;\n        this.bottom += stepY;\n        const children = this.getChildren(true)\n        if (redraw) {\n            if (!fast) {\n                this.redraw();\n            } else {\n                if (this.svg) {\n                    this.svg.style.left = this.left + \"px\";\n                    this.svg.style.top = this.top + \"px\";\n                }\n            }\n        }\n        if (children.length && this.options.groupChildShapes) {\n            children.forEach(child => {\n                for (let point of child.points) {\n                    point.x += stepX;\n                    point.y += stepY;\n                    if (!this.options.simpleMode && redraw && typeof (point.redraw) === \"function\") {\n                        point.redraw();\n                    }\n                }\n                child.left += stepX;\n                child.top += stepY;\n                child.right += stepX;\n                child.bottom += stepY;\n                child.options.offsetX += stepX;\n                child.options.offsetY += stepY;\n                if (fast && child.svg) {\n                    child.svg.style.left = child.left + \"px\";\n                    child.svg.style.top = child.top + \"px\";\n                }\n            });\n        }\n        if (fast) {\n            SmartShapeDrawHelper.redrawResizeBox(this);\n            SmartShapeDrawHelper.redrawRotateBox(this);\n        }\n    }\n\n    /**\n     * Scales image to fit specified `width` and `height`. It only changes coordinates of points, but do not\n     * redraws the shape on new position. So, you need to call `redraw` yourself after scale.\n     * @param width {number|null} new width. If not specified, then will be calculated automatically based on height to\n     * preserve aspect ratio\n     * @param height {number|null} new height. If not specifie, then will be calculated automatically based on width\n     * to preserve aspect ratio\n     */\n    this.scaleTo = (width=null,height= null,includeChildren=null) => {\n        const bounds = this.getBounds();\n        this.calcPosition();\n        if (!width && !height) {\n            return null;\n        }\n        const pos = this.getPosition(includeChildren || this.options.groupChildShapes);\n        if (pos.width === width && pos.height === height) {\n            return\n        }\n        [width,height] = this.applyScaleRestriction(...applyAspectRatio(width,height,pos.width,pos.height));\n        if (pos.width>=10 && width<10) {\n            width = 10;\n        }\n        if (pos.height>=10 && height<10) {\n            height = 10;\n        }\n        let newWidth = abs(pos.left) + width > bounds.right && bounds.right !== -1 ? bounds.right - abs(pos.left) : width;\n        let newHeight = abs(pos.top) + height > bounds.bottom && bounds.bottom !== -1 ? bounds.bottom - abs(pos.top) : height;\n        let scaleX = abs(newWidth/pos.width);\n        let scaleY = abs(newHeight/pos.height);\n        this.scaleBy(scaleX,scaleY,includeChildren);\n    }\n\n    /**\n     * Method used to scale the shape by specified ratio by X and Y\n     * @param scaleX {number} Horizontal scale ratio\n     * @param scaleY {number} Vertical scale ratio\n     */\n    this.scaleBy = (scaleX=null,scaleY= null,includeChildren=null) => {\n        if (scaleX === 1 && scaleY === 1) {\n            return\n        }\n        const pos = this.getPosition(includeChildren || this.options.groupChildShapes);\n        this.points.forEach(point => {\n            point.x = (point.x-pos.left)*scaleX+pos.left;\n            point.y = (point.y-pos.top)*scaleY+pos.top}\n        );\n        this.width *= scaleX;\n        this.height *= scaleY;\n        this.options.scaleFactorX *= scaleX;\n        this.options.scaleFactorY *= scaleY;\n        if (this.options.groupChildShapes || includeChildren) {\n            this.getChildren(true).forEach(child => {\n                child.points.forEach(point => {\n                        point.x = (point.x - pos.left) * scaleX + pos.left;\n                        point.y = (point.y - pos.top) * scaleY + pos.top\n                    }\n                );\n                child.width *= scaleX;\n                child.height *= scaleY;\n                child.options.scaleFactorX *= scaleX;\n                child.options.scaleFactorY *= scaleY;\n                child.calcPosition();\n            })\n            if (!this.options.simpleMode && this.options.visible) {\n                this.getChildren().forEach(child => child.redraw());\n            }\n        }\n        this.calcPosition();\n    }\n\n    /**\n     * Method used to zoom shape by specified level\n     * @param level {number} Zoom level. Can be any positive number. If number is greater than 1,\n     * then it increases the size of shape, if it between 0 and 1, then it decreases the shape.\n     */\n    this.zoomBy = (level) => {\n        this.options.zoomLevel *= level;\n        this.scaleBy(level,level);\n        if (this.options.groupChildShapes) {\n            this.getChildren(true).forEach(child => child.options.zoomLevel *= level);\n        }\n    }\n\n    /**\n     * @ignore\n     * Method returns width and height of shape after applying\n     * `minWidth`, `minHeight`, `maxWidth` and `maxHeight` restrictions\n     * to it\n     * @param width {number} Original width\n     * @param height {number} Original height\n     * @returns {array} Returns array in a format [width,height] which is not\n     * less than minWidth and minHeight and not greater than maxWidth and maxHeight\n     */\n    this.applyScaleRestriction = (width,height) => {\n        if (this.options.minWidth !== -1 && width < this.options.minWidth) {\n            width = this.options.minWidth;\n        }\n        if (this.options.minWidth !== -1 && height < this.options.minHeight) {\n            height = this.options.minHeight;\n        }\n        if (this.options.minWidth !== -1 && width > this.options.maxWidth) {\n            width = this.options.maxWidth;\n        }\n        if (this.options.minWidth !== -1 && height > this.options.maxHeight) {\n            height = this.options.maxHeight;\n        }\n        return [width,height];\n    }\n\n    /**\n     * Method used to rotate this shape by specified angle around it's center.\n     * @param angle {number} Angle in degrees. Positive - clockwise, Negative - counterclock-wise\n     * @param centerX {number} X coordinate of center around which to rotate the shape. By default it's a center\n     * of the shape\n     * @param centerY {number} Y coordinate of center around which to rotate the shape. By default it's a center\n     * of the shape\n     * @param checkBounds {boolean} Should the function check that shape won't go beyond defined bounds or\n     * container bounds after rotation. By default false.\n     */\n    this.rotateBy = (angle,centerX=null,centerY=null,checkBounds=false) => {\n        this.calcPosition();\n        const pos = this.getPosition(this.options.groupChildShapes);\n        let [shapeCenterX,shapeCenterY] = this.getCenter(this.options.groupChildShapes)\n        const parent = this.getRootParent(true);\n        if (parent && parent.options.groupChildShapes) {\n            [shapeCenterX,shapeCenterY] = parent.getCenter(parent.options.groupChildShapes);\n        }\n        if (!centerX) {\n            centerX = shapeCenterX;\n        }\n        if (!centerY) {\n            centerY = shapeCenterY\n        }\n        if (this.initCenter) {\n            [centerX,centerY] = this.initCenter;\n        }\n        if (checkBounds && (!this.isInBounds(...getRotatedCoords(angle,pos.left,pos.top,centerX,centerY)) ||\n            !this.isInBounds(...getRotatedCoords(angle,pos.right,pos.top,centerX,centerY)) ||\n            !this.isInBounds(...getRotatedCoords(angle,pos.left,pos.bottom,centerX,centerY)) ||\n            !this.isInBounds(...getRotatedCoords(angle,pos.right,pos.bottom,centerX,centerY)))) {\n            return\n        }\n        this.points.forEach(point => {\n            if (typeof(point.rotateBy) === \"function\") {\n                point.rotateBy(angle, centerX, centerY)\n            } else {\n                [point.x,point.y] = getRotatedCoords(angle, point.x,point.y, centerX,centerY)\n            }\n        });\n        this.options.rotateAngle += angle;\n        if (this.options.groupChildShapes) {\n            this.getChildren(true).forEach(child => {\n                child.points.forEach(point => {\n                    if (typeof(point.rotateBy) === \"function\") {\n                        point.rotateBy(angle, centerX, centerY)\n                    } else {\n                        [point.x,point.y] = getRotatedCoords(angle, point.x,point.y, centerX,centerY)\n                    }\n                });\n                child.options.rotateAngle += angle;\n                child.redraw();\n            })\n        }\n    }\n\n    /**\n     * Method used to flip shape and its children vertically or horizontally\n     * @param byX {boolean} Flip horizontally\n     * @param byY {boolean} Flip vertically\n     * @param includeChildren {boolean} Flip includes children shapes\n     */\n    this.flip = (byX,byY,includeChildren) => {\n        if (!byX && !byY) {\n            return\n        }\n        includeChildren = includeChildren || this.options.groupChildShapes;\n        this.calcPosition()\n        let children = includeChildren ? this.getChildren(true) : null;\n        children && children.forEach(child => child.calcPosition());\n        const pos = this.getPosition(includeChildren);\n        this.points.forEach(point=>this.flipPoint(point,byX,byY,pos));\n        if (byX) {\n            this.options.flippedX = !this.options.flippedX;\n        }\n        if (byY) {\n            this.options.flippedY = !this.options.flippedY;\n        }\n        if (!children) {\n            return\n        }\n        children.forEach(child=>{\n            if (byX) {\n                child.options.flippedX = !child.options.flippedX;\n                child.options.flippedY = !child.options.flippedY;\n            }\n            child.points.forEach(point => child.flipPoint(point,byX,byY,pos))\n        })\n    }\n\n    /**\n     * @ignore\n     * Internal method to flip specified point over X or/and Y axis\n     * according to specified dimensions of shape\n     * @param point {SmartPoint} Point object (or any object with x and y fields)\n     * @param byX {boolean} Flip horizontally\n     * @param byY {boolean} Flip vertically\n     * @param pos {object} Shape dimensions, object with fields: `top`,`left`,`bottom`,`right`,`width`,`height`\n     * @returns {SmartPoint} point object with flipped coordinates\n     */\n    this.flipPoint = (point, byX, byY, pos) => {\n        [point.x,point.y] = flipPoint(point.x,point.y,byX,byY,pos);\n        return point\n    }\n\n    /**\n     * Method used to change shape z-index to topmost\n     */\n    this.moveToTop = () => {\n        SmartShapeDrawHelper.moveShapeToTop(this);\n    }\n\n    /**\n     * Method used to change shape z-index to bottommost\n     */\n    this.moveToBottom = () => {\n        SmartShapeDrawHelper.moveShapeToBottom(this);\n    }\n\n    /**\n     * Method used to change shape z-index to specified number\n     * @param zIndex {number} z-index value\n     */\n    this.changeZIndex = (zIndex) => {\n        SmartShapeDrawHelper.changeShapeZIndex(this,zIndex)\n    }\n\n    /**\n     * @ignore\n     * Method used to check is specified coordinate not goes beyond bounds\n     * @param x {number} X coordinate\n     * @param y {number} Y coordinate\n     * @returns true if it does not go beyond or false otherwise.\n     */\n    this.isInBounds = (x,y) => {\n        const [width,height] = this.getMaxPointSize();\n        const bounds = this.getBounds();\n        return (x >= bounds.left + width /2) &&\n            (x <= bounds.right - width/2) &&\n            (y >= bounds.top + height/2) &&\n            (y <= bounds.bottom - height/2)\n    }\n\n    /**\n     * Method used to redraw shape polygon. Runs automatically when add/remove points or change their properties.\n     */\n    this.redraw = () => {\n        this.applyDisplayMode();\n        SmartShapeDrawHelper.draw(this);\n        if (this.options.groupChildShapes && !this.options.displayAsPath) {\n            this.getChildren().forEach(child=>child.redraw());\n        }\n    }\n\n    /**\n     * @ignore\n     * Method used to setup shape drawing depending on current `options.displayMode`.\n     * Depending on this it shows either ResizeBox around it, or RotateBox, or nothing.\n     */\n    this.applyDisplayMode = () => {\n        this.points.filter(point=>typeof(point.setOptions) === \"function\").forEach(point => {\n            const options = {zIndex: this.options.zIndex + 15}\n            if (this.options.displayMode === SmartShapeDisplayMode.DEFAULT) {\n                options.createDOMElement = false;\n            } else {\n                options.createDOMElement = true;\n            }\n            point.setOptions(options);\n            if (point.element) {\n                point.element.style.zIndex = point.options.zIndex;\n                if (this.options.displayMode === SmartShapeDisplayMode.DEFAULT && !point.options.forceDisplay) {\n                    point.element.style.display = 'none';\n                }\n            }\n        })\n        if (this.options.groupChildShapes) {\n            this.getChildren(true).forEach(child => {\n                child.points.filter(point=>typeof(point.setOptions) === \"function\").forEach(point => {\n                    if (this.options.displayMode === SmartShapeDisplayMode.DEFAULT) {\n                        point.setOptions({createDOMElement:false});\n                    } else {\n                        point.setOptions({createDOMElement:true});\n                    }\n                    if (point.options.visible && !point.options.hidden && point.options.canDrag) {\n                        if (point.element) {\n                            point.element.style.display = '';\n                        }\n                    }\n                })\n                child.options.displayMode = this.options.displayMode;\n            })\n        }\n    }\n\n    /**\n     * Method used to switch display mode of SmartShape from Default to Resize to Rotate.\n     * @param mode {SmartShapeDisplayMode} Display mode to switch to. One of values of\n     * [SmartShapeDisplayMode](#SmartShapeDisplayMode). If not specified, then automatically\n     * switches to next mode in the following loop sequence: DEFAULT -> SCALE -> ROTATE -> DEFAULT\n     */\n    this.switchDisplayMode = (mode=null) => {\n        if (!mode) {\n            mode = this.getNextDisplayMode();\n        }\n        if ((mode === SmartShapeDisplayMode.SCALE && !this.options.canScale) ||\n            (mode === SmartShapeDisplayMode.ROTATE && !this.options.canRotate) ||\n            (mode === SmartShapeDisplayMode.SELECTED && (this.points.length && !this.options.pointOptions.canDrag))) {\n            mode = SmartShapeDisplayMode.DEFAULT;\n        }\n        this.options.displayMode = mode;\n        if (this.options.simpleMode) {\n            this.applyDisplayMode();\n        } else {\n            this.redraw();\n        }\n        if (mode === SmartShapeDisplayMode.DEFAULT && this.options.groupChildShapes) {\n            setTimeout(() => {\n                this.getChildren(true).forEach(child => {\n                    child.switchDisplayMode(mode)\n                    if (this.options.simpleMode) {\n                        child.applyDisplayMode();\n                    } else {\n                        child.redraw();\n                    }\n                });\n            },10)\n        }\n    }\n\n    /**\n     * @ignore\n     * Method returns next display mode after current one\n     * in the following sequence DEFAULT -> SCALE -> ROTATE\n     * taking in account `canScale` and `canRotate` options\n     * @returns {SmartShapeDisplayMode|string|*}\n     */\n    this.getNextDisplayMode = () => {\n        let mode;\n        if (this.options.displayMode === SmartShapeDisplayMode.DEFAULT) {\n            mode = SmartShapeDisplayMode.SELECTED;\n        } else if (this.options.displayMode === SmartShapeDisplayMode.SELECTED) {\n            mode = SmartShapeDisplayMode.SCALE;\n        } else if (this.options.displayMode === SmartShapeDisplayMode.SCALE) {\n            mode = SmartShapeDisplayMode.ROTATE;\n        } else {\n            mode = SmartShapeDisplayMode.DEFAULT;\n        }\n        if (mode === SmartShapeDisplayMode.SELECTED && !this.options.pointOptions.canDrag) {\n            mode = SmartShapeDisplayMode.SCALE\n        }\n        if (mode === SmartShapeDisplayMode.SCALE && !this.options.canScale) {\n            mode = SmartShapeDisplayMode.ROTATE\n        }\n        if (mode === SmartShapeDisplayMode.ROTATE && !this.options.canRotate) {\n            mode = SmartShapeDisplayMode.DEFAULT;\n        }\n        return mode\n    }\n\n    /**\n     * @ignore\n     * Internal method that used to calculate shape dimensions, based on point coordinates.\n     * Set left,top,right,bottom,width and height of shape.\n     */\n    this.calcPosition = () => {\n        if (!this.points.length) {\n            return;\n        }\n        Object.assign(this,this.calcPositionFromPointsArray(this.getPointsArray()))\n    }\n\n    /**\n     * @ignore\n     * Service method that used to update shape dimensions based on\n     * changed point coordinates (or if point removed)\n     * @param x {number} X coordinate\n     * @param y {number} Y coordinate\n     * @param removed {boolean} Indicates that point with specified (x,y) removed\n     */\n    this.updatePosition = (x,y,removed) => {\n        if (x<this.left) {\n            if (removed) {\n                this.left = this.oldLeft;\n            } else {\n                this.oldLeft = this.left;\n                this.left = x;\n            }\n        }\n        if (x>this.right) {\n            if (removed) {\n                this.right = this.oldRight\n            } else {\n                this.oldRight = this.right;\n                this.right = x\n            }\n        }\n        if (y<this.top) {\n            if (removed) {\n                this.top = this.oldTop;\n            } else {\n                this.oldTop = this.top;\n                this.top = y;\n            }\n        }\n        if (y>this.bottom) {\n            if (removed) {\n                this.bottom = this.oldBottom;\n            } else {\n                this.oldBottom = this.bottom;\n                this.bottom = y;\n            }\n        }\n        this.width = this.right - this.left || 1\n        this.height = this.bottom - this.top || 1\n    }\n\n    /**\n     * @ignore\n     * Function calculates shape dimensions based on provided points array.\n     * @param points {array} 2D array of points in format [ [x,y], [x,y] [x,y] ...]\n     * @returns {object} Object with fields: `left`,`top`,`right`,`bottom`,`width`,`height`\n     */\n    this.calcPositionFromPointsArray = (points) => {\n        const result = {};\n        result.left = points.map(point => point[0]).reduce((minx,x) => x < minx ? x : minx);\n        result.top = points.map(point => point[1]).reduce((miny,y) => y < miny ? y : miny);\n        result.right = points.map(point => point[0]).reduce((maxx,x) => x > maxx ? x : maxx);\n        result.bottom = points.map(point => point[1]).reduce((maxy,y) => y > maxy ? y : maxy);\n        result.width = abs(result.right-result.left) || 1;\n        result.height = abs(result.bottom-result.top) || 1;\n        return result;\n    }\n\n    /**\n     * Method used to get current position of shape\n     * @param forGroup {boolean} If true, then it calculates left, top, right and bottom of this shape\n     * and all its children\n     * @returns {object} Position with fields:\n     * `top`,`left`,`right`,`bottom`,`width`,`height`\n     */\n    this.getPosition = (forGroup=false) => {\n        if (forGroup) {\n            return this.groupHelper.getPosition();\n        }\n        return {\n            top: this.top,\n            left: this.left,\n            bottom: this.bottom,\n            right: this.right,\n            width: parseFloat(this.width),\n            height: parseFloat(this.height)\n        }\n    }\n\n    /**\n     * Method returns the bounds of this shape, e.g. inside which square it's allowed to drag it.\n     * By default, if [options.bounds](#SmartShape+options) not specified, the bounds of shape are equal to\n     * the bounds of shape's container element (clientLeft, clientTop, clientLeft+clientWidth, clientTop+clientHeight)\n     * @returns {object} Object with `left`, `top`, `right` and `bottom` fields.\n     */\n    this.getBounds = () => {\n        return {\n            left: this.options.bounds.left !== -1 ? this.options.bounds.left : this.root.style.display === 'none' ? -1 : this.root.clientLeft,\n            top: this.options.bounds.top !== -1 ? this.options.bounds.top : this.root.style.display === 'none' ? -1 : this.root.clientTop,\n            right: this.options.bounds.right !== -1 ? this.options.bounds.right : this.root.style.display === 'none' ? -1 : this.root.clientLeft + this.root.clientWidth,\n            bottom: this.options.bounds.bottom !== -1 ? this.options.bounds.bottom : this.root.style.display === 'none' ? -1 : this.root.clientTop + this.root.clientHeight\n        }\n    };\n\n    /**\n     * Method returns true if specified point exists in the array of this shape or false if not.\n     * @param point [SmartPoint](#SmartPoint) object of point to search\n     * @returns {boolean} True if this point exists and false if not\n     */\n    this.isShapePoint = (point) => {\n        return !!this.points.find(item => item === point);\n    }\n\n    /**\n     * Method returns true if point with specified coordinates lays\n     * inside shape or false otherwise.\n     * @param x {number} X coodrinate\n     * @param y {number} Y coordinate\n     * @returns {boolean} True if (x,y) belongs to shape and false otherwise\n     */\n    this.belongsToShape = (x,y,applyOffset=true) => {\n        if (!this.isInShapePolygon(x,y)) {\n            return false;\n        }\n        const off = getOffset(this.root)\n        if (this.findPoint(x-off.left,y-off.top)) {\n            return true;\n        }\n        let points = this.getPointsArray();\n        if (applyOffset) {\n            points = points.map(point => ([point[0]+off.left,point[1]+off.top]));\n        }\n        return isPointInsidePolygon(points,[x,y]);\n    }\n\n    this.isInShapePolygon = (x,y) => {\n        const off = getOffset(this.root)\n        return x>=this.left+off.left && x<=this.right+off.left && y>=this.top+off.top && y <= this.bottom+off.top;\n    }\n\n    /**\n     * Uniform method that used to add event handler of specified type to this object.\n     * SmartShape can emit events, defined in [ShapeEvents](#ShapeEvents) enumeration. So, you can\n     * listen any of these events.\n     * @param eventName {string} - Name of event. Use one of names, defined for [ShapeEvents](#ShapeEvents).\n     * @param handler {function} - Function that used as an event handler\n     * @returns {function} - Pointer to added event handler. Should be used to remove event listener later.\n     */\n    this.addEventListener = (eventName,handler) => {\n        return this.eventListener.addEventListener(eventName,handler)\n    }\n\n    /**\n     * Uniform method that used to remove event handler, that previously added\n     * to this object.\n     * @param eventName {string} Name of event to remove listener from\n     * @param listener {function} Pointer to event listener, that added previously.\n     * It was returned from [addEventListener](#ResizeBox+addEventListener) method.\n     */\n    this.removeEventListener = (eventName,listener) => {\n        this.eventListener.removeEventListener(eventName,listener);\n    }\n\n    /**\n     * Method used to show shape if it has hidden\n     */\n    this.show = () => {\n        this.setOptions({visible:true});\n        this.getChildren().forEach(child => {\n            child.options.visible = true;\n        });\n        this.redraw();\n    }\n\n    /**\n     * Method used to hide the shape\n     */\n    this.hide = () => {\n        this.setOptions({visible:false});\n        this.getChildren().forEach(child => {\n            child.options.visible = false;\n        });\n        this.redraw();\n    }\n\n    /**\n     * Destroys the shape. Destroys all points, removes event listeners and removes the shape from screen.\n     * But variable continue existing. To completely remove the shape,\n     * set the variable to 'null' after calling this method.\n     */\n    this.destroy = () => {\n        EventsManager.emit(ShapeEvents.SHAPE_DESTROY,this,{});\n        if (this.eventListener) {\n            this.eventListener.destroy();\n        }\n        if (this.resizeBox) {\n            this.resizeBox.destroy();\n        }\n        if (this.rotateBox) {\n            this.rotateBox.destroy();\n        }\n        if (this.root) {\n            try {\n                if (this.svg) {\n                    this.root.removeChild(this.svg);\n                }\n                this.points.filter(point => point.element).forEach(point => this.root.removeChild(point.element))\n            } catch (err) {}\n        }\n        if (this.options.groupChildShapes) {\n            this.getChildren(true).forEach(child => {\n                child.destroy()\n            });\n        }\n        if (this.shapeMenu && this.shapeMenu.contextMenu) {\n            this.shapeMenu.destroyContextMenu();\n        }\n        const parent = this.getParent();\n        if (parent) {\n            parent.removeChild(this);\n        }\n        this.points.filter(point=>typeof(point.destroy) === \"function\").forEach(point => point.destroy());\n        this.points = [];\n    }\n\n    /**\n     * @ignore\n     * Used to setup [ResizeBox](#ResizeBox) around shape if shape scaling is enabled\n     */\n    this.setupResizeBox = () => {\n        if (!this.points.length) {\n            return null;\n        }\n        const bounds = this.getResizeBoxBounds();\n        this.resizeBox = new ResizeBox().init(this.root,bounds.left,bounds.top,bounds.width,bounds.height,{\n            zIndex: this.options.zIndex+1,\n            id: this.options.id+\"_resizebox\",\n            shapeOptions:{\n                canDragShape: false,\n                visible: this.options.visible,\n                managed: false,\n                hasContextMenu:false\n            }\n        })\n        this.resizeBox.redraw();\n        this.eventListener.addResizeEventListener();\n    }\n\n    /**\n     * @ignore\n     * Used to setup [Rotate](#RotateBox) around shape if shape rotation is enabled\n     */\n    this.setupRotateBox = () => {\n        if (!this.points.length) {\n            return null;\n        }\n        const bounds = this.getResizeBoxBounds();\n        this.rotateBox = new RotateBox().init(this.root,bounds.left,bounds.top,bounds.width,bounds.height,{\n            zIndex: this.options.zIndex+1,\n            id: this.options.id+\"_rotatebox\",\n            shapeOptions:{\n                canDragShape: false,\n                visible: this.options.visible,\n                managed: false,\n                hasContextMenu: false\n            }\n        })\n        this.rotateBox.redraw();\n        this.eventListener.addRotateEventListener();\n    }\n\n    /**\n     * @ignore\n     * Returns dimensions of resize box around shape according to shape dimensions\n     * @returns {{top: number, left: number, bottom: *, width: *, right: *, height: *}}\n     */\n    this.getResizeBoxBounds = () => {\n        let pos = this.getPosition(this.options.groupChildShapes);\n        const parent = this.getRootParent(true);\n        if (parent && parent.options.groupChildShapes) {\n            if (parent.options.displayAsPath) {\n                pos = parent.getPosition(parent.options.groupChildShapes);\n            } else {\n                pos = this.getPosition(this.options.groupChildShapes);\n            }\n        }\n        const [pointWidth,pointHeight] = this.getMaxPointSize();\n        const result = {\n            left: pos.left - pointWidth,\n            right: pos.right + pointWidth,\n            top: pos.top - pointHeight,\n            bottom: pos.bottom + pointHeight,\n            width: pos.width + (pointWidth)*2,\n            height: pos.height + (pointHeight)*2,\n        }\n        return result;\n    }\n\n    /**\n     * @ignore\n     * Method finds and return the size of the biggest point in this shape\n     * @returns {array} [width,height]\n     */\n    this.getMaxPointSize = () => {\n        if (!this.points.length) {\n            return [0,0];\n        }\n        const pointWidth = this.points.map(point=>point.options ? point.options.width : 0).reduce((w1,w2) => Math.max(w1,w2));\n        const pointHeight = this.points.map(point=>point.options? point.options.height : 0).reduce((h1,h2) => Math.max(h1,h2));\n        return [pointWidth,pointHeight];\n    }\n\n    /**\n     * Method returns coordinates of the center of the shape.\n     * @param forGroup {boolean} Should get center of all shapes in the group. Default: false\n     * @returns {array} Center of a shape as an array [x,y]\n     */\n    this.getCenter = (forGroup=false) => {\n        const pos = this.getPosition(forGroup)\n        return [pos.left+pos.width/2, pos.top+pos.height/2]\n    };\n\n    /**\n     * @ignore\n     * Internal method that used to return SVG element to which this shape belongs\n     * If this is a root shape, then just returns svg of current shape object,\n     * if it's a child, then SVG element of the parent\n     * @param shape {SmartShape} Shape to return SVG element for\n     * @returns {HTMLOrSVGElement|null|*}\n     */\n    this.getShapeSvg = () => {\n        return SmartShapeDrawHelper.getShapeSvg(this);\n    }\n\n    /**\n     * Method exports shape and all its children to SVG document.\n     * @param includeChildren {boolean} Should include children of this shape to output.\n     * 'null' by default. In this case value of shape.options.groupChildShapes will be used*\n     * @returns {string} Body of SVG document as a string\n     */\n    this.toSvg = (includeChildren=null) => {\n        return SmartShapeDrawHelper.toSvg(this,includeChildren);\n    }\n\n    /**\n     * Method exports shape and all its children as a PNG image\n     * @param {PngExportTypes} type Format of returned result - `dataurl` or `blob`. By default `dataurl`\n     * @param {number|null} width Width of image. If not specified, then calculate based on height or current\n     * width of shape\n     * @param {number|null} height Height of image. If not specified, then calculate based on width or current\n     * height of shape\n     * @param includeChildren {boolean} Should include children of this shape to output.\n     * 'null' by default. In this case value of shape.options.groupChildShapes will be used*\n     * @return {Promise} Promise that resolves either to DataURL string or to BLOB object, depending on value of\n     * `type` argument\n     */\n    this.toPng = (type= PngExportTypes.DATAURL,width=null,height=null,includeChildren=null) => {\n        return SmartShapeDrawHelper.toPng(this,type,width,height,includeChildren);\n    }\n\n    /**\n     * Method used to save shape to JSON string.\n     * Returns string with JSON object or JSON array, depending on should it save children too\n     * @param includeChildren {boolean} If true, then it appends JSONs\n     * of all children to `children` property of resulting JSON.\n     * @param compact {boolean} If this is true, then it will save only coordinates of\n     * points, but not their properties\n     * @returns {string} Serialized JSON as string.\n     */\n    this.toJSON = (includeChildren=true,compact=false) => {\n        return JSON.stringify(this.getJSON(includeChildren,compact))\n    }\n\n    /**\n     * Method creates complete copy of current shape\n     * @param options {object} Array of shape options to override on cloned object.\n     * @param includeChildren {boolean} If true, then clones all children of this shape as well\n     * Any [SmartShape options](#SmartShape+options) can be in this object.\n     * @returns {SmartShape|null} Created shape object or null in case of errors\n     */\n    this.clone = (options={},includeChildren=true) => {\n        const json = mergeObjects({},this.getJSON(includeChildren));\n        json.parent_guid = this.guid;\n        json.options = mergeObjects(json.options,options);\n        const result = new SmartShape().fromJSON(this.root,json,includeChildren);\n        if (!result) {\n            return null\n        }\n        result.getChildren(true).forEach(child => {\n            child.options.id += \"_\" + SmartShapeManager.length();\n            child.options.name += \" \" + SmartShapeManager.length();\n        });\n        return result;\n    }\n\n    /**\n     * @ignore\n     * Method used to save shape to Javascript object\n     * Returns JSON object or JSON array, depending on should it save children too\n     * @param includeChildren {boolean} If true, then it appends JSONs\n     * of all children to `children` property of resulting JSON\n     * @param compact {boolean} If this is true, then it will save only coordinates of\n     * points, but not their properties\n     * @returns {object} Javascript object with shape and it's children, if `includeChildren` is true.\n     */\n    this.getJSON = (includeChildren = true, compact = false) => {\n        const result = {\n            options: mergeObjects({},this.options)\n        }\n        result.options.displayMode = SmartShapeDisplayMode.DEFAULT;\n        if (compact || this.options.compactExport) {\n            result.points = this.points.map(point => [point.x,point.y]);\n        } else {\n            result.points = this.points.filter(point => typeof(point.getJSON) === \"function\").map(point => point.getJSON());\n        }\n        if (includeChildren) {\n            let children = this.getChildren();\n            if (children.length) {\n                result.children = children.map(\n                    child => child.getJSON(includeChildren,compact || this.options.compactExport)\n                );\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Method used to load shape data from specified JSON string, that previously serialized by `toJSON` method\n     * @param root {HTMLElement} HTML container to insert loaded shape\n     * @param json {string|object} JSON-Serialized shape data as an object or as a string\n     * @param includeChildren {boolean} Should load children of this shape if existed. True by default.\n     * @returns {SmartShape|null} Loaded SmartShape object or null in case of JSON reading errors\n     */\n    this.fromJSON = (root,json,includeChildren = true,emitCreateEvent = true) => {\n        let jsonObj = typeof(json) === \"string\" ? readJSON(json) : json;\n        if (!jsonObj) {\n            return null;\n        }\n        this.root = root;\n        if (SmartShapeManager.findShapeById(jsonObj.options.id)) {\n            jsonObj.options.id += \"_\"+SmartShapeManager.length();\n            jsonObj.options.name += \" \"+SmartShapeManager.length();\n        }\n        if (!this.svg) {\n            jsonObj.options.forceCreateEvent = false;\n            this.init(root,jsonObj.options,null,false);\n        } else {\n            this.setOptions(jsonObj.options);\n        }\n        jsonObj.points.forEach(point => {\n            let p\n            if (point.length) {\n                p = this.putPoint(point[0],point[1]);\n                p.setOptions(jsonObj.options.pointOptions || {})\n            } else {\n                p = this.putPoint(point.x, point.y, point.options || jsonObj.options.pointOptions);\n            }\n            p && p.updateContextMenu();\n        })\n        const parent = SmartShapeManager.getShapeByGuid(jsonObj.parent_guid);\n        SmartShapeManager.addShape(this);\n        if (includeChildren && typeof(jsonObj.children) !== \"undefined\" && jsonObj.children) {\n            this.getChildren(true).forEach(child=>child.destroy());\n            jsonObj.children.forEach(child => {\n                child.parent_guid = this.guid;\n                this.addChild(new SmartShape().fromJSON(root,child));\n            })\n        }\n        if (emitCreateEvent) {\n            EventsManager.emit(ShapeEvents.SHAPE_CREATE, this, {parent});\n        }\n        return this;\n    }\n\n    /**\n     * GroupHelper methods\n     */\n\n    /**\n     * Method used to add specified shape as a child of current shape\n     * @param child {SmartShape} Shape to add\n     * @param emitEvent {boolean} Should this method emit ADD_CHILD event. True by default\n     */\n    this.addChild = (child,emitEvent) => this.groupHelper.addChild(child,emitEvent);\n\n    /**\n     * Method used to add specified children to current shape\n     * @param children {array} Array of [SmartShape][#SmartShape) objects\n     */\n    this.addChildren = (children=[]) => this.groupHelper.addChildren(children);\n\n    /**\n     * Method used to remove specified shape from children list of current shape\n     * @param child {SmartShape} SmartShape object to add\n     */\n    this.removeChild = (child) => this.groupHelper.removeChild(child);\n\n    /**\n     * Method removes all children of current shape\n     * @param all {boolean} If true, then it removes all children hierarchically\n     */\n    this.removeAllChildren = (all=false) => this.groupHelper.removeAllChildren(all);\n\n    /**\n     * Method returns array of children of current shape\n     * @param all {boolean} If true, then it returns deep list, including all children of each children of this shape\n     * @returns {array} Array of [SmartShape](#SmartShape) objects\n     */\n    this.getChildren = (all=false) => this.groupHelper.getChildren(all);\n\n    /**\n     * Method returns if specified shape is child of current shape\n     * @param child {SmartShape} Shape to check\n     * @param all {boolean} Should check include subchildren\n     */\n    this.hasChild = (child,all=false) => this.groupHelper.hasChild(child,all);\n\n    /**\n     * Method returns parent of current shape or null\n     * @returns {SmartShape|null}\n     */\n    this.getParent = () => this.groupHelper.getParent();\n\n    /**\n     * Method returns top parent of current shape\n     * @returns {SmartShape|null} Parent shape or null\n     */\n    this.getRootParent = (groupChildShapes= null) => this.groupHelper.getRootParent(groupChildShapes);\n\n    /**\n     * Method returns a list of parents of current shape ordered from nearest to root\n     * @param plist {array} Temporary list of parents from previous recursive call\n     * @returns {array} Array of [SmartShape](#SmartShape) objects\n     */\n    this.getParentsList = (plist=[]) => this.groupHelper.getParentsList(plist);\n\n    /**\n     * Method used to transform coordinates of point on current shape\n     * to coordinate of points of original shape, before all transformations done\n     * on it (move,scale or flip)\n     * @param x X coordinate\n     * @param y Y coordinate\n     * @returns {array} Array of new coordinates [x,y]\n     */\n    this.mapCurrentPointToOriginal = (x,y) =>\n        mapPointCords(x, y, PointMapTypes.CURRENT_TO_ORIGINAL, {\n            ...this.options,\n            ...this.getPosition(this.options.groupChildShapes),\n        }\n    );\n\n    /**\n     * Method used to transform coordinates of point of orignal shape\n     * to coordinate of points of current shape, after all transformations done\n     * on it (move,scale or flip)\n     * @param x X coordinate\n     * @param y Y coordinate\n     * @returns {array} Array of new coordinates [x,y]\n     */\n    this.mapOriginalPointToCurrent = (x,y) =>\n        mapPointCords(x, y, PointMapTypes.ORIGINAL_TO_CURRENT, {\n            ...this.options,\n            ...this.getPosition(this.options.groupChildShapes),\n        }\n    );\n}\n\n/**\n * Enumeration of SmartShape display modes\n * @param default basic display mode without resize or rotate boxes and points are hidden\n * @param selected In this mode the points displayed on shape, but resize and rotate boxes are hidden\n * @param scale In this mode the shape displayed with resize box around it\n * @param rotate In this mode the shape displayed with rotate box around it\n * @enum {string}\n */\nexport const SmartShapeDisplayMode = {\n    DEFAULT: \"default\",\n    SELECTED: \"selected\",\n    SCALE: \"scale\",\n    ROTATE: \"rotate\"\n}\n\nexport default SmartShape;\n","import SmartShape from \"../SmartShape/SmartShape.js\";\nimport {PointMoveDirections} from \"../SmartPoint/SmartPoint.js\";\nimport ResizeBoxEventListener from \"./ResizeBoxEventListener.js\";\nimport EventsManager from \"../events/EventsManager.js\";\nimport {ShapeEvents} from \"../SmartShape/SmartShapeEventListener.js\";\nimport {resize_lb,resize_cb,resize_ct,resize_lc,resize_lt,resize_rb,resize_rc,resize_rt} from \"../../assets/graphics.js\";\nimport {mergeObjects, uuid} from \"../utils\";\n/**\n * Class represents a special type of shape, that shows the rectangle with markers on\n * it corners, used to resize it. [See demo](https://code.germanov.dev/smart_shape/tests/prod/resize_box.html).\n * Mostly used to resize [SmartShape](#SmartShape) object, but also can be used as an independent shape\n * for tasks like resizing objects on a web page or select rectangular regions.\n * @constructor\n */\nfunction ResizeBox() {\n\n    /**\n     * Left corner of resize box\n     * @type {number}\n     */\n    this.left = 0;\n\n    /**\n     * Top corner of resize box\n     * @type {number}\n     */\n    this.top = 0;\n\n    /**\n     * Right corner of resize box\n     * @type {number}\n     */\n    this.right = 0;\n\n    /**\n     * Bottom corner of resize box\n     * @type {number}\n     */\n    this.bottom = 0;\n\n    /**\n     * Width of resize box\n     * @type {number}\n     */\n    this.width = 0;\n\n    /**\n     * Height of resize box\n     * @type {number}\n     */\n    this.height = 0;\n\n    /**\n     * Underlying shape, that used to service this resize box\n     * (draw, point event handling and so on)\n     * @type {SmartShape}\n     */\n    this.shape = null;\n\n    /**\n     * Global unique identifier of this object.\n     * Generated automatically\n     * @type {string}\n     */\n    this.guid = uuid()\n\n    /**\n     * Options of resize box\n     * @param id {string} Unique ID or resize box. If instantiated by [SmartShape](#SmartShape), then setup\n     * automatically\n     * @param shapeOptions {object} Options of underlying shape, that used to draw and manage this ResizeBox. See\n     * [SmartShape.options](#SmartShape+options)\n     * @param zIndex {number} Order of element in a stack of HTML elements\n     * (https://www.w3schools.com/cssref/pr_pos_z-index.asp). Elements if higher z-index value placed on top.\n     * @param onlyMove {boolean} If enabled, then resizeBox displayed as hidden. It's possible to drag it, but\n     * but not resize\n     * @type {object}\n     */\n    this.options = {\n        id: \"\",\n        shapeOptions: {\n            id: \"\",\n            canAddPoints: false,\n            canDeletePoints: false,\n            pointOptions: {\n                style: {\n                    \"border-width\": \"0px\",\n                    \"border-radius\": \"0px\",\n                    backgroundColor: \"rgba(0,0,0,0)\",\n                    cursor:\"pointer\",\n                },\n                forceDisplay:true,\n                width:13,\n                height:13,\n            },\n            style: {\n                \"stroke-width\":\"2px\",\n                \"stroke\":\"#aaaaaa\",\n                \"stroke-dasharray\": \"10\",\n                fill:\"none\",\n            }\n        },\n        zIndex: 1000,\n        onlyMove: false\n    }\n\n    /**\n     * Event listener that handles event listening logic for this resize box.\n     * Instance of [ResizeBoxEventListener](#ResizeBoxEventListener) class.\n     * @type {ResizeBoxEventListener}\n     */\n    this.eventListener = null;\n\n    /**\n     * Left top marker point\n     * @type {SmartPoint}\n     */\n    this.left_top = null;\n\n    /**\n     * Left center marker point\n     * @type {SmartPoint}\n     */\n    this.left_center = null;\n\n    /**\n     * Left bottom marker point\n     * @type {SmartPoint}\n     */\n    this.left_bottom = null;\n\n    /**\n     * Center top marker point\n     * @type {SmartPoint}\n     */\n    this.center_top = null;\n\n    /**\n     * Center bottom marker point\n     * @type {SmartPoint}\n     */\n    this.center_bottom = null;\n\n    /**\n     * Right top marker point\n     * @type {SmartPoint}\n     */\n    this.right_top = null;\n\n    /**\n     * Right center marker point\n     * @type {SmartPoint}\n     */\n    this.right_center = null;\n\n    /**\n     * Right bottom marker point\n     * @type {SmartPoint}\n     */\n    this.right_bottom = null;\n\n    /**\n     * Method used to construct ResizeBox object with specified coordinates and\n     * size, with specified `options`. Then it binds this object to specified `root`\n     * HTML node and displays it\n     * @param root {HTMLElement} HTML element that used as a container for this ResizeBox\n     * @param left {number} Left corner of shape relative to container top left\n     * @param top {number} Top corner of shape relative to container top left\n     * @param width {number} Width of shape\n     * @param height {number} Height of shape\n     * @param options {object} Options used to setup ResizeBox. See [here](#ResizeBox+options).\n     * @returns {ResizeBox} constucted ResizeBox object\n     */\n    this.init = (root,left,top,width,height,options={}) => {\n        this.left = parseInt(left);\n        this.top = parseInt(top);\n        this.width = parseInt(width);\n        this.height = parseInt(height);\n        this.right = this.left + this.width;\n        this.bottom = this.top + this.height;\n        this.setOptions(options);\n        this.options.shapeOptions.id = this.options.id;\n        this.options.shapeOptions.canRotate = false;\n        this.options.shapeOptions.canScale = false;\n        this.shape = new SmartShape().init(root,mergeObjects({},this.options.shapeOptions),[]);\n        EventsManager.emit(ShapeEvents.SHAPE_CREATE, this.shape, {});\n        this.options.shapeOptions.pointOptions.bounds = this.shape.getBounds();\n        this.addPoints();\n        this.eventListener = new ResizeBoxEventListener(this).run();\n        return this;\n    }\n\n    /**\n     * Method used to change options of ResizeBox.\n     * @param options {object} Options object. See [here](#ResizeBox+options).\n     */\n    this.setOptions = (options = {}) => {\n        if (!options || typeof(options) !== \"object\") {\n            return\n        }\n        this.options = mergeObjects(this.options,options);\n        this.options.shapeOptions.zIndex = this.options.zIndex || 1000;\n        this.options.shapeOptions.id = this.options.id || \"\";\n        if (this.shape) {\n            this.shape.setOptions(this.options.shapeOptions);\n        }\n    }\n\n    /**\n     * @ignore\n     * Method used to add marker points to ResizeBox, that lately used to resize the box\n     */\n    this.addPoints = () => {\n        this.left_top = this.shape.putPoint(this.left,this.top,{id:this.shape.guid+\"_left_top\",style:{backgroundImage: \"url('\"+resize_lt+\"')\"}});\n        this.center_top = this.shape.putPoint(this.left+this.width/2,this.top,{id:this.shape.guid+\"_center_top\",style:{backgroundImage: \"url('\"+resize_ct+\"')\"}});\n        this.right_top = this.shape.putPoint(this.right,this.top,{id:this.shape.guid+\"_right_top\",style:{backgroundImage: \"url('\"+resize_rt+\"')\"}});\n        this.right_center = this.shape.putPoint(this.right,this.top+this.height/2,{id:this.shape.guid+\"_right_center\",style:{backgroundImage: \"url('\"+resize_rc+\"')\"}});\n        this.right_bottom = this.shape.putPoint(this.right,this.bottom,{id:this.shape.guid+\"_right_bottom\",style:{backgroundImage: \"url('\"+resize_rb+\"')\"}});\n        this.center_bottom = this.shape.putPoint(this.left+this.width/2,this.bottom,{id:this.shape.guid+\"_center_bottom\",style:{backgroundImage: \"url('\"+resize_cb+\"')\"}});\n        this.left_bottom = this.shape.putPoint(this.left,this.bottom,{id:this.shape.guid+\"_left_bottom\",style:{backgroundImage: \"url('\"+resize_lb+\"')\"}});\n        this.left_center = this.shape.putPoint(this.left,this.top+this.height/2,{id:this.shape.guid+\"_left_center\",style:{backgroundImage: \"url('\"+resize_lc+\"')\"}});\n        this.setPointsOptions();\n    }\n\n    /**\n     * @ignore\n     * Method used to setup marker points of ResizeBox\n     */\n    this.setPointsOptions = () => {\n        this.setPointsMoveDirections();\n        this.setPointsMoveBounds();\n    }\n\n    /**\n     * @ignore\n     * Method used to setup to which directions allowed to move marker points.\n     * For example, some of them possible to move only horizontally, others, only vertically.\n     * See [SmartShape.options.moveDirections](#SmartShape+options) to learn more.\n     */\n    this.setPointsMoveDirections = () => {\n        this.center_top.setOptions({moveDirections:[PointMoveDirections.TOP,PointMoveDirections.BOTTOM]});\n        this.center_bottom.setOptions({moveDirections:[PointMoveDirections.TOP,PointMoveDirections.BOTTOM]});\n        this.left_center.setOptions({moveDirections:[PointMoveDirections.LEFT,PointMoveDirections.RIGHT]});\n        this.right_center.setOptions({moveDirections:[PointMoveDirections.LEFT,PointMoveDirections.RIGHT]});\n    }\n\n    /**\n     * @ignore\n     * Method used to set bounds, to which possible to move each marker point of ResizeBox\n     * For example, it's impossible to drag right corner beyond left corner, top corner beyond bottom corner.\n     */\n    this.setPointsMoveBounds = () => {\n        this.left_top.options.bounds.bottom = this.left_bottom.y-this.left_bottom.options.height-this.left_center.options.height;\n        this.left_top.options.bounds.right = this.right_top.x-this.right_top.options.width-this.center_top.options.width;\n        this.center_top.options.bounds.bottom = this.left_bottom.y-this.left_bottom.options.height-this.left_center.options.height;\n        this.right_top.options.bounds.bottom = this.left_bottom.y-this.left_bottom.options.height-this.left_center.options.height;\n        this.right_top.options.bounds.left = this.left_top.x+this.right_top.options.width+this.center_top.options.width;\n        this.right_center.options.bounds.left = this.left_top.x+this.right_center.options.width+this.center_top.options.width;\n        this.right_bottom.options.bounds.left = this.left_top.x+this.right_bottom.options.width+this.center_bottom.options.width;\n        this.right_bottom.options.bounds.top = this.right_top.y+this.right_top.options.height+this.right_center.options.height;\n        this.center_bottom.options.bounds.top =this.center_top.y+this.center_top.options.height+this.right_center.options.height;\n        this.left_bottom.options.bounds.right = this.right_bottom.x-this.right_bottom.options.width-this.center_bottom.options.width;\n        this.left_bottom.options.bounds.top = this.left_top.y+this.left_top.options.height+this.left_center.options.height;\n        this.left_center.options.bounds.right = this.right_center.x-this.right_center.options.width-this.center_top.options.width;\n    }\n\n    /**\n     * @ignore\n     * Method used to recalculate coordinates of marker points\n     * according to current ResizeBox coordinates and dimensions.\n     */\n    this.adjustCoordinates = () => {\n        this.right = this.left + this.width;\n        this.bottom = this.top + this.height;\n        this.left_top.x = this.left;\n        this.left_top.y = this.top;\n        this.right_top.x = this.right;\n        this.right_top.y = this.top;\n        this.left_bottom.x = this.left;\n        this.left_bottom.y = this.bottom;\n        this.right_bottom.x = this.right;\n        this.right_bottom.y = this.bottom;\n        this.center_top.y = this.top;\n        this.center_bottom.y = this.bottom;\n        this.left_center.x = this.left;\n        this.right_center.x = this.right;\n        this.adjustCenters();\n    }\n\n    /**\n     * @ignore\n     * Method used to recalculate coordinates of point markers, located on the centers of rectangle,\n     * after user dragged corner markers.\n     */\n    this.adjustCenters = () => {\n        this.center_top.x = parseInt(this.left_top.x+(this.right_top.x-this.left_top.x)/2);\n        this.center_bottom.x = parseInt(this.left_top.x+(this.right_top.x-this.left_top.x)/2);\n        this.left_center.y = parseInt(this.left_top.y+(this.left_bottom.y-this.left_top.y)/2);\n        this.right_center.y = parseInt(this.right_top.y+(this.right_bottom.y-this.right_top.y)/2);\n    }\n\n    /**\n     * @ignore\n     * Internal method that used to calculate resize box dimensions, based on point coordinates.\n     * Set left,top,right,bottom,width and height of resize box.\n     */\n    this.calcPosition = () => {\n        this.shape.calcPosition();\n        this.left = this.shape.left;\n        this.top = this.shape.top;\n        this.bottom = this.shape.bottom;\n        this.right = this.shape.right;\n        this.width = this.shape.width;\n        this.height = this.shape.height;\n    }\n\n    /**\n     * Method used to get current position of Resize Box\n     * @returns {object} Position with fields:\n     * `top`,`left`,`right`,`bottom`,`width`,`height`\n     */\n    this.getPosition = () => {\n        return  {top:this.top, left: this.left, bottom: this.bottom, right: this.right, width: this.width, height:this.height}\n    }\n\n\n    /**\n     * Method used to redraw resize box\n     */\n    this.redraw = () => {\n        this.adjustCoordinates();\n        this.shape.setOptions(this.options.shapeOptions);\n        this.setPointsMoveBounds();\n        this.shape.redraw();\n        this.applyOnlyMove();\n    }\n\n    /**\n     * Method used to show Resize Box if it has hidden\n     */\n    this.show = () => {\n        this.options.shapeOptions.visible = true;\n        this.shape.show();\n    }\n\n    /**\n     * Method used to hide Resize Box\n     */\n    this.hide = () => {\n        this.options.shapeOptions.visible = false;\n        this.shape.hide();\n    }\n\n    /**\n     * Destroys the ResizeBox. Destroys all points, removes event listeners and removes the shape from screen.\n     * But variable continue existing. To completely remove the shape,\n     * set the variable to 'null' after calling this method.\n     */\n    this.destroy = () => {\n        EventsManager.emit(ShapeEvents.SHAPE_DESTROY,this,{});\n        this.eventListener.destroy();\n        this.shape.destroy();\n    }\n\n    /**\n     * Uniform method that used to add event handler of specified type to this object.\n     * ResizeBox can emit events, defined in [ResizeBoxEvents](#ResizeBoxEvents) enumeration. So, you can\n     * listen any of these events.\n     * @param eventName {string} - Name of event. Use one of names, defined in [ResizeBoxEvents](#ResizeBoxEvents)\n     * @param handler {function} - Function that used as an event handler\n     * @returns {function} - Pointer to added event handler. Should be used to remove event listener later.\n     */\n    this.addEventListener = (eventName,handler) => {\n        return this.eventListener.addEventListener(eventName,handler);\n    }\n\n    /**\n     * Uniform method that used to remove event handler, that previously added\n     * to this object.\n     * @param eventName {ResizeBoxEvents|string} Name of event to remove listener from\n     * @param listener {function} Pointer to event listener, that added previously.\n     * It was returned from [addEventListener](#ResizeBox+addEventListener) method.\n     */\n    this.removeEventListener = (eventName,listener) => {\n        this.eventListener.removeEventListener(eventName,listener);\n    }\n\n    this.applyOnlyMove = () => {\n        if (this.options.onlyMove) {\n            this.shape.svg.style.opacity = 0;\n            this.shape.points.forEach((point) => {\n               point.options.visible = false;\n               if (point.element) {\n                   point.redraw();\n               }\n            })\n        } else {\n            this.shape.svg.style.opacity = 1;\n            this.shape.points.forEach((point) => {\n                point.options.visible = this.shape.options.visible;\n                if (point.element) {\n                    point.redraw();\n                }\n            })\n        }\n    }\n}\n\nexport default ResizeBox;\n","import ResizeBox from \"./ResizeBox/ResizeBox.js\";\nimport RotateBox from \"./RotateBox/RotateBox.js\";\nimport SmartShape, {SmartShapeDisplayMode} from \"./SmartShape/SmartShape.js\";\nimport SmartShapeManager from \"./SmartShapeManager/SmartShapeManager.js\";\nimport EventsManager from \"./events/EventsManager.js\";\nimport SmartShapeEventListener,{ShapeEvents} from \"./SmartShape/SmartShapeEventListener.js\";\nimport SmartShapeGroupHelper from \"./SmartShape/SmartShapeGroupHelper.js\";\nimport {createEvent,getMousePos,getMouseCursorPos} from \"./events/functions.js\";\n\ntry {\n    window.ResizeBox = ResizeBox;\n    window.SmartShape = SmartShape;\n    window.RotateBox = RotateBox;\n    window.SmartShapeManager = SmartShapeManager;\n    window.SmartShapeGroupHelper = SmartShapeGroupHelper;\n    window.SmartShapeDisplayMode = SmartShapeDisplayMode;\n    window.ShapeEvents = ShapeEvents;\n    window.createEvent = createEvent;\n    window.getMousePos = getMousePos;\n    window.getMouseCursorPos = getMouseCursorPos\n} catch (err) {}\n\nexport {\n    SmartShape,ResizeBox,RotateBox,SmartShapeManager,EventsManager,ShapeEvents,\n    SmartShapeDisplayMode,SmartShapeGroupHelper,SmartShapeEventListener,\n    createEvent, getMousePos, getMouseCursorPos\n};\n"],"names":["EventsManager","events","handler","event","eventName","h","target","params","result","index","EventsManager$3","degrees_to_radians","degrees","radians_to_degrees","radians","getRotatedCoords","angle","x","y","centerX","centerY","resultX","resultY","distance","x1","y1","x2","y2","distanceFromLine","x0","y0","t","d","isPointInsidePolygon","polygon","point","onSegment","q","r","orientation","val","doIntersect","p1","q1","p2","q2","o1","o2","o3","o4","extreme","count","i","next","applyAspectRatio","width","height","origWidth","origHeight","mapPointCords","type","scaleX","scaleY","offsetX","offsetY","flippedX","flippedY","PointMapTypes","flipPoint","byX","byY","pos","abs","defaultIsMergeableObject","value","isNonNullObject","isSpecial","stringValue","isReactElement","REACT_ELEMENT_TYPE","emptyTarget","cloneUnlessOtherwiseSpecified","options","deepmerge","defaultArrayMerge","source","element","getMergeFunction","key","customMerge","getEnumerableOwnPropertySymbols","symbol","getKeys","propertyIsOnObject","object","property","propertyIsUnsafe","mergeObject","destination","sourceIsArray","targetIsArray","array","prev","getOffset","elem","deep","uuid","c","pauseEvent","e","notNull","mergeObjects","objects","dataURLtoBlob","dataURI","byteString","mimeString","ab","ia","blobToDataURL","blob","resolve","reader","readJSON","jsonString","CSStoJsStyleName","cssName","timeout","ms","createEvent","origEvent","getMouseCursorPos","getMousePos","offset","EventsManager$1","MenuStylesHelper","menu","item","itemDiv","ItemParts","span","img","className","id","classType","Menu","items","container","eventType","StylesHelper","MenuEvents","div","imgItems","name","listener","maxSize","left","top","title","image","Menus","Menus$1","rotate_tl","rotate_tr","rotate_br","rotate_bl","resize_cb","resize_ct","resize_lb","resize_lc","resize_lt","resize_rb","resize_rc","resize_rt","add","del","save","svg","png","copy","group","ungroup","move_to_top","move_to_bottom","horizontal","vertical","to_path","to_shapes","base64_export","zoom_in","zoom_out","reset_zoom","SmartPointContextMenu","PointEvents","_event","PointMoveDirections","SmartPoint","ContainerEvents","SmartShapeManager","oldX","oldY","newX","newY","json","jsonObj","isNew","RotateBoxEventListener","rotateBox","ShapeEvents","clientX","clientY","angleDiff","RotateBoxEvents","hypotenuse","cathetus","startAngle","ResizeBoxEventListener","resizeBox","oldPos","newPos","ResizeBoxEvents","SmartShapeEventListener","shape","parent","diffX","diffY","pointWidth","pointHeight","stepX","stepY","bounds","SmartShapeDrawHelper","defs","child","SmartShapeDisplayMode","path","size","fill","gradientOptions","gradient","gradientTag","foundSteps","step","stepNode","imageFillOptions","pattern","filters","filterName","filter","filterOptions","attribute","includeChildren","groupChanged","paths","zoom","viewBox","parts","w1","w2","PngExportTypes","svgObj","href","svgString","DOMURL","url","canvas","ctx","zIndex","diff","SmartShapeDrawHelper$1","fromGeoJSON","geoJSON","progressCallback","obj","createShapeFromGeoJson","importOptions","isCorrectJSON","loadOptions","polygons","loadPolygons","idx","shapeOpts","geometry","fieldName","_polygon","cords","right","bottom","root","points","show","SmartShape","guid","shapes","max","min","displayMode","SmartShapeManagerEvents","dragshape","destShape","shapeOnCursor","matchedShapes","prevShape","compact","emitCreateEvent","err","progessCallback","SmartShapeManager$2","SmartShapeGroupHelper","emitEvent","children","all","groupChildShapes","parents","plist","minLeft","minTop","maxRight","maxBottom","RotateBox","SmartShapeContextMenu","itemsToAdd","itemToAdd","point1","point2","clone","filename","a","extension","pointOptions","beforePoint","p","beforeIndex","s1","s2","l","l1","l2","redraw","respectBounds","fast","newWidth","newHeight","level","checkBounds","shapeCenterX","shapeCenterY","mode","removed","minx","miny","maxx","maxy","forGroup","applyOffset","off","ResizeBox","h1","h2"],"mappings":"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"}