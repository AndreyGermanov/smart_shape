{"version":3,"file":"smart_shape.js","sources":["src/events/EventsManager.js","src/utils/geometry.js","src/utils/deepmerge.js","src/utils/index.js","src/events/functions.js","../context_menu/src/EventsManager.js","../context_menu/src/MenuStylesHelper.js","../context_menu/src/functions.js","../context_menu/src/Menu.js","../context_menu/src/Menus.js","../context_menu/src/index.js","assets/graphics.js","src/SmartPoint/SmartPointContextMenu.js","src/SmartPoint/SmartPoint.js","src/RotateBox/RotateBoxEventListener.js","src/ResizeBox/ResizeBoxEventListener.js","src/SmartShape/SmartShapeEventListener.js","src/SmartShape/SmartShapeDrawHelper.js","src/SmartShapeManager/GeoJSONImport.js","src/SmartShapeManager/SmartShapeManager.js","src/SmartShape/SmartShapeGroupHelper.js","src/RotateBox/RotateBox.js","src/SmartShape/SmartShapeContextMenu.js","src/SmartShape/SmartShape.js","src/ResizeBox/ResizeBox.js","src/index.js"],"sourcesContent":["/**\n * Used as a singleton object to emit events and subscribe to these events.\n * One object can subscribe to events of specified type, other object can emit events of this type.\n * Each time when object emits event, all subscribed event handlers triggered.\n * @constructor\n */\n\nfunction EventsManager() {\n\n    /**\n     * Hashmap of all registered event subscriptions.\n     * Keys are event names as strings. Values are arrays of functions.\n     * Several handlers can subscribe to each event by providing function that should be triggered.\n     * this.subscriptions[event_name] = [handler_func,handler_func ...]\n     * @type {object}\n     */\n    this.subscriptions = {};\n\n    /**\n     * Add subscription to event of specified type or to array of events of specified types\n     * @param events {string|array} Name of event as a string or names of events as an array of strings.\n     * @param handler {function} Handling function, which will be called each time when event of this type emitted.\n     * Each time, when handling function triggered, it receives a single argument - `event` {object} which contains\n     * the following fields: `type` - type of event (`eventType`), `target` - pointer to object, which emitted\n     * this event, and also any custom params, that emitter sent with this event by using `emit` method.\n     * @returns {function} Pointer to handling function, that will be added\n     */\n    this.subscribe = (events,handler) => {\n        if (typeof(events) === \"string\") {\n            return this.subscribeToEvent(events,handler)\n        } else if (typeof(events) === \"object\") {\n            for (let event of events) {\n                this.subscribeToEvent(event,handler)\n            }\n            return handler;\n        }\n        return null;\n    }\n\n    /**\n     * @ignore\n     * Add subscription to event of specified type\n     * @param eventName {string|array} Name of event as a string or array of names of events to subscribe to\n     * @param handler {function} Handling function, which will be called each time when event of this type emitted.\n     * Each time, when handling function triggered, it receives a single argument - `event` {object} which contains\n     * the following fields: `type` - type of event (`eventType`), `target` - pointer to object, which emitted\n     * this event, and also any custom params, that emitter sent with this event by using `emit` method.\n     * @returns {function} Pointer to handling function, that will be added\n     */\n    this.subscribeToEvent = (eventName,handler) => {\n        if (typeof(this.subscriptions[eventName]) === \"undefined\" || !this.subscriptions[eventName]) {\n            this.subscriptions[eventName] = [];\n        }\n        if (typeof(this.subscriptions[eventName].find(h => h === handler)) !== \"undefined\") {\n            return null;\n        }\n        this.subscriptions[eventName].push(handler);\n        return handler;\n    }\n\n    /**\n     * Emits event of specified name. Based on specified arguments, it constructs `event` object, that contains\n     * the following fields: `type` - eventName, `target` - object that emitted this event and any other fields\n     * that received from `params` argument. Then, all subscribers will receive this `event` object to their handling\n     * functions.\n     * @param eventName {string} Name of event to emit.\n     * @param target {object} Which object emitted this event.\n     * @param params {object} Event specific params. Can be any number of params.\n     * @returns {boolean} True if this event triggered at least of one handler, or false if it does not.\n     */\n    this.emit = (eventName,target,params=null) => {\n        if (!params || typeof(params) !== \"object\") {\n            params = {}\n        }\n        params[\"type\"] = eventName;\n        params[\"target\"] = target;\n        if (typeof(this.subscriptions[eventName]) !== \"undefined\" && this.subscriptions[eventName] &&\n        this.subscriptions[eventName].length) {\n            for (let handler of this.subscriptions[eventName]) {\n                handler(params)\n            }\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Removes specified handler from event with specified name or from array of events with specified names.\n     * @param events {string|array} Name of event as a string or names of events as an array of strings.\n     * @param handler {function} Pointer to a function to remove. (This pointer returned from `subscribe` method and\n     * can be used here to unsubscribe\n     * @returns {boolean} True if really removed the handler or false if you could not remove because it does not exist\n     */\n    this.unsubscribe = (events, handler) => {\n        let result = false;\n        if (typeof(events) === \"string\") {\n            if (this.unsubscribeFromEvent(events,handler)) {\n                result = true;\n            }\n        } else if (typeof(events) === \"object\") {\n            for (let event of events) {\n                if (this.unsubscribeFromEvent(event,handler)) {\n                    result = true;\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @ignore\n     * Removes specified handler from event with specified name.\n     * @param eventName {string} Name of event as a string\n     * @param handler {function} Pointer to a function to remove. (This pointer returned from `subscribe` method and\n     * can be used here to unsubscribe\n     * @returns {boolean} True if really removed the handler or false if you could not remove because it does not exist\n     */\n    this.unsubscribeFromEvent = (eventName,handler) => {\n        if (typeof(this.subscriptions[eventName]) === \"undefined\" || !this.subscriptions[eventName]) {\n            return false\n        }\n        const index = this.subscriptions[eventName].indexOf(handler);\n        if (index !== -1) {\n            this.subscriptions[eventName].splice(index,1);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Method removes all subscriptions to events.\n     */\n    this.clear = () => {\n        this.subscriptions = {};\n    }\n}\n\nexport default new EventsManager();\n","import {abs} from \"./index.js\";\n\n/**\n * @ignore\n * Function converts degrees to radians\n * @param degrees {number} Angle in degrees\n * @returns {number} Angle in radians\n */\nexport const degrees_to_radians = (degrees) =>  degrees * (Math.PI/180);\n\n/**\n * @ignore\n * Functions converts radians to degrees\n * @param radians {number} Angle in radians\n * @returns {number} Angle in degrees\n */\nexport const radians_to_degrees = (radians) => radians * (180/Math.PI);\n\n/**\n * @ignore\n * Function used to rotate point with specified coordinate x,y around the center with\n * coordinates centerX, centerY by specified angle in degrees.\n * @param angle {number} Rotation angle\n * @param x {number} X coordinate of point\n * @param y {number} Y coordinate of point\n * @param centerX {number} X coordinate of center\n * @param centerY {number} Y coordinate of center\n * @returns {array} New coordinates of point in array [x,y]\n */\nexport const getRotatedCoords = (angle, x, y, centerX, centerY) => {\n    if (angle === 0) {\n        return [x,y];\n    }\n    const radians = degrees_to_radians(angle);\n    const resultX = (x-centerX)*Math.cos(radians)-(y-centerY)*Math.sin(radians)+centerX;\n    const resultY = (x-centerX)*Math.sin(radians)+(y-centerY)*Math.cos(radians)+centerY;\n    return [resultX, resultY];\n}\n\n/**\n * @ignore\n * Function calculates euclidean distance between two points\n * @param x1 {number} X coordinate of point 1\n * @param y1 {number} Y coordinate of point 1\n * @param x2 {number} X coordinate of point 2\n * @param y2 {number} Y coordinate of point 2\n * @returns {number} Distance from (x1,y1) to (x2,y2)\n */\nexport const distance = (x1,y1,x2,y2) => {\n    return Math.sqrt(Math.pow(x2-x1,2)+Math.pow(y2-y1,2))\n}\n\n/**\n * @ignore\n * Function calculates distance from point (x0,y0) to line, defined by points (x1,y1) and (x2,y2)\n * https://code.germanov.dev/smart_shape/assets/distance.png\n * @param x0 X coordinate of point\n * @param y0 Y coordinate of point\n * @param x1 X coordinate of line start\n * @param y1 Y coordinate of line start\n * @param x2 X coordinate of line end\n * @param y2 Y coordinate of line end\n */\nexport const distanceFromLine = (x0,y0,x1,y1,x2,y2) => {\n    let t = (x0-x1)*(x2-x1)+(y0-y1)*(y2-y1);\n    const d = Math.pow(x2-x1,2) +Math.pow(y2-y1,2)\n    if (d === 0) {\n        return -1;\n    }\n    t /= d;\n    if (t<0) {\n        t = 0;\n    } else if (t>1) {\n        t = 1;\n    }\n    return Math.sqrt(Math.pow(x1-x0 + t*(x2-x1),2) + Math.pow(y1-y0+t*(y2-y1),2))\n}\n\n/**\n * @ignore\n * Function returns true is specified `point` lays inside or on the borders of specified `polygon`\n * @param polygon {array} Array of points of polygon [ [x,y] , [x,y] , [x,y] ... ]\n * @param point {array} Coordinates of point [x,y]\n * @returns {boolean} True if the point belongs to the polygon or false otherwise\n */\nexport const isPointInsidePolygon = (polygon,point) => {\n\n    const onSegment = (p,q,r) => {\n        return !!(q.x <= Math.max(p.x, r.x) &&\n            q.x >= Math.min(p.x, r.x) &&\n            q.y <= Math.max(p.y, r.y) &&\n            q.y >= Math.min(p.y, r.y));\n    }\n\n    const orientation = (p,q,r) => {\n        let val = (q[1] - p[1]) * (r[0] - q[0])\n            - (q[0] - p[0]) * (r[1] - q[1]);\n\n        if (val === 0) {\n            return 0;\n        }\n        return (val > 0) ? 1 : 2;\n    }\n\n    const doIntersect = (p1,q1,p2,q2) => {\n        let o1 = orientation(p1, q1, p2);\n        let o2 = orientation(p1, q1, q2);\n        let o3 = orientation(p2, q2, p1);\n        let o4 = orientation(p2, q2, q1);\n\n        if (o1 !== o2 && o3 !== o4) {\n            return true;\n        }\n\n        if (o1 === 0 && onSegment(p1, p2, q1))  {\n            return true;\n        }\n\n        if (o2 === 0 && onSegment(p1, q2, q1)) {\n            return true;\n        }\n\n        if (o3 === 0 && onSegment(p2, p1, q2))  {\n            return true;\n        }\n        return !!(o4 === 0 && onSegment(p2, q1, q2));\n    }\n    if (polygon.length < 3) {\n        return false;\n    }\n\n    let extreme = [10000,point[1]]\n\n    let count = 0, i = 0;\n    do {\n        let next = (i + 1) % polygon.length;\n        if (doIntersect(polygon[i], polygon[next], point, extreme)) {\n            if (orientation(polygon[i], point, polygon[next]) === 0) {\n                return onSegment(polygon[i], point,\n                    polygon[next]);\n            }\n            count++;\n        }\n        i = next;\n    } while (i !== 0);\n    return (count % 2 === 1)\n}\n\n/**\n * @ignore\n * Function used to calculate width or height respecting aspect ratio, calculated from `origWidth` and `origHeight`.\n * Either `width` or `height` must be null. Otherwise, just returns width and height\n * @param width {number|null} Destination width. If null, then calculates it\n * @param height {number|null} Destination height. If null, then calculates it\n * @param origWidth {number} Original width used to calculate aspect ratio\n * @param origHeight {number} Original height used to calculate aspect ration\n * @returns {array} Array in the form [width,height] after apply aspect ratio\n */\nexport const applyAspectRatio = (width,height,origWidth,origHeight) => {\n    if (!width && !height || !origWidth || !origHeight) {\n        return [origWidth, origHeight];\n    }\n    if (width && height) {\n        return [width,height]\n    }\n    if (!width) {\n        width = height * (origWidth/origHeight);\n    }\n    if (!height) {\n        height = width * (origHeight/origWidth);\n    }\n    return [width,height]\n}\n\n/**\n * @ignore\n * Returns true if two rectangles overlap each other\n * @param rect1 {object} First rectangle coordinates in format {left,top,right,bottom}\n * @param rect2 {object} Second rectangle coordinates in format {left,top,right,bottom}\n * @returns {boolean} True if rectangles overlap and false otherwise\n */\nexport const rectsOverlap = (rect1,rect2) => {\n    if (rect1.left === rect1.right || rect1.top === rect1.bottom || rect2.left === rect2.right || rect2.top === rect2.bottom)\n        return false;\n\n    if (rect1.left > rect2.right || rect2.left > rect1.left) {\n        return false;\n    }\n\n    return !(rect1.bottom > rect2.top || rect2.bottom > rect1.top);\n}\n\n/**\n * Method used to transform specified coordinates\n * using transformations, specified in `params` argument.\n * @param x {number} X coordinate\n * @param y {number} Y coordinate\n * @param type {PointMapTypes} This options specifies the transformation direction.\n * If it equals to `original_to_current` then need to apply specified transformations\n * to point, if  it equals `current_to_original`, the it assumed that all transformations\n * already applied to specified coordinates and need to un-apply them.\n * @param params Transformation parameters: `offsetX` - move by X, `offsetY` - move by Y,\n * `scaleX` - scale by X, `scaleY` - scale by Y, `flippedX` - flip by X, `flippedY` - flip by Y\n * @returns {array} New coordinates after transformation in [x,y] format\n */\nexport const mapPointCords = (x,y,type,params) => {\n    const scaleX = params.scaleFactorX || 1;\n    const scaleY = params.scaleFactorY || 1;\n    const offsetX = params.offsetX || 0;\n    const offsetY = params.offsetY || 0;\n    const flippedX = params.flippedX || false;\n    const flippedY = params.flippedY || false;\n    if (type === PointMapTypes.CURRENT_TO_ORIGINAL) {\n        [x,y] = flipPoint(x,y,flippedX,flippedY,params);\n        x -= offsetX;\n        y -= offsetY;\n        x *= (1/scaleX);\n        y *= (1/scaleY);\n    } else if (type === PointMapTypes.ORIGINAL_TO_CURRENT) {\n        x *= scaleX;\n        y *= scaleY;\n        x += offsetX;\n        y += offsetY;\n        [x,y] = flipPoint(x,y,flippedX,flippedY,params);\n    }\n    return [x,y];\n}\n\n/**\n * @ignore\n * Internal method to flip specified point over X or/and Y axis\n * according to specified dimensions of shape\n * @param x {number} X coordinate of point\n * @param y {number} Y coordinate of point\n * @param byX {boolean} Flip horizontally\n * @param byY {boolean} Flip vertically\n * @param pos {object} Shape dimensions, object with fields: `top`,`left`,`bottom`,`right`,`width`,`height`\n * @returns {array} New point coordinates in [x,y] format\n */\nexport const flipPoint = (x,y, byX, byY, pos) => {\n    if (byX) {\n        x = abs(pos.right - x) + pos.left\n    }\n    if (byY) {\n        y = abs(pos.bottom - y) + pos.top\n    }\n    return [x,y]\n}\n\n/**\n * @ignore\n * Function used to convert polar coordinates to\n * screen coordinates\n * @param lat {number} Latitude\n * @param lon {number} Longitude\n * @returns {array} X and Y coordinates as array [x,y]\n */\nexport const latLonToXY = (lat, lon) => {\n    const width = 1000000\n    const x = (width * (180 + lon) / 360) % (1.5 * width)\n    const rad = lat * Math.PI / 180\n    const merc = 0.5 * Math.log((1 + Math.sin(rad)) / (1 - Math.sin(rad)))\n    const y = (width * merc / (2 * Math.PI))\n    return [x,y]\n}\n\nexport const PointMapTypes = {\n    CURRENT_TO_ORIGINAL: \"current_to_original\",\n    ORIGINAL_TO_CURRENT: \"original_to_current\"\n}\n","// https://github.com/TehShrike/is-mergeable-object/blob/master/index.js\nfunction defaultIsMergeableObject(value) {\n    return isNonNullObject(value)\n        && !isSpecial(value)\n}\n\nfunction isNonNullObject(value) {\n    return !!value && typeof value === 'object'\n}\n\nfunction isSpecial(value) {\n    const stringValue = Object.prototype.toString.call(value)\n    return stringValue === '[object RegExp]'\n        || stringValue === '[object Date]'\n        || isReactElement(value)\n}\n\nconst canUseSymbol = typeof Symbol === 'function' && Symbol.for\nconst REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7\n\nfunction isReactElement(value) {\n    return value.$$typeof === REACT_ELEMENT_TYPE\n}\n\n// https://github.com/TehShrike/deepmerge/blob/master/index.js\nfunction emptyTarget(val) {\n    return Array.isArray(val) ? [] : {}\n}\n\nfunction cloneUnlessOtherwiseSpecified(value, options) {\n    return (options.clone !== false && options.isMergeableObject(value))\n        ? deepmerge(emptyTarget(value), value, options)\n        : value\n}\n\nfunction defaultArrayMerge(target, source, options) {\n    return target.concat(source).map(function(element) {\n        return cloneUnlessOtherwiseSpecified(element, options)\n    })\n}\n\nfunction getMergeFunction(key, options) {\n    if (!options.customMerge) {\n        return deepmerge\n    }\n    const customMerge = options.customMerge(key)\n    return typeof customMerge === 'function' ? customMerge : deepmerge\n}\n\nfunction getEnumerableOwnPropertySymbols(target) {\n    return Object.getOwnPropertySymbols\n        ? Object.getOwnPropertySymbols(target).filter(function(symbol) {\n            return target.propertyIsEnumerable(symbol)\n        })\n        : []\n}\n\nfunction getKeys(target) {\n    return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))\n}\n\nfunction propertyIsOnObject(object, property) {\n    try {\n        return property in object\n    } catch(_) {\n        return false\n    }\n}\n\n// Protects from prototype poisoning and unexpected merging up the prototype chain.\nfunction propertyIsUnsafe(target, key) {\n    return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n        && !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n            && Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.\n}\n\nfunction mergeObject(target, source, options) {\n    const destination = {}\n    if (options.isMergeableObject(target)) {\n        getKeys(target).forEach(function(key) {\n            destination[key] = cloneUnlessOtherwiseSpecified(target[key], options)\n        })\n    }\n    getKeys(source).forEach(function(key) {\n        if (propertyIsUnsafe(target, key)) {\n            return\n        }\n\n        if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\n            destination[key] = getMergeFunction(key, options)(target[key], source[key], options)\n        } else {\n            destination[key] = cloneUnlessOtherwiseSpecified(source[key], options)\n        }\n    })\n    return destination\n}\n\nexport const deepmerge = (target, source, options) => {\n    options = options || {}\n    options.arrayMerge = options.arrayMerge || defaultArrayMerge\n    options.isMergeableObject = options.isMergeableObject || defaultIsMergeableObject\n    // cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\n    // implementations can use it. The caller may not replace it.\n    options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified\n\n    const sourceIsArray = Array.isArray(source)\n    const targetIsArray = Array.isArray(target)\n    const sourceAndTargetTypesMatch = sourceIsArray === targetIsArray\n\n    if (!sourceAndTargetTypesMatch) {\n        return cloneUnlessOtherwiseSpecified(source, options)\n    } else if (sourceIsArray) {\n        return options.arrayMerge(target, source, options)\n    } else {\n        return mergeObject(target, source, options)\n    }\n}\n\ndeepmerge.all = function deepmergeAll(array, options) {\n    if (!Array.isArray(array)) {\n        throw new Error('first argument should be an array')\n    }\n\n    return array.reduce(function(prev, next) {\n        return deepmerge(prev, next, options)\n    }, {})\n}\n","import {getRotatedCoords, distance, degrees_to_radians, radians_to_degrees,isPointInsidePolygon,rectsOverlap} from \"./geometry.js\";\nimport {deepmerge} from \"./deepmerge.js\";\n\nexport const getOffset = ( elem,deep=true ) => {\n    let x = 0;\n    let y = 0;\n    if (!deep) {\n        return {top: elem.offsetTop - elem.scrollTop, left: elem.offsetLeft - elem.scrollLeft};\n    }\n    while( elem && !isNaN( elem.offsetLeft ) && !isNaN( elem.offsetTop ) ) {\n        x += elem.offsetLeft - elem.scrollLeft;\n        y += elem.offsetTop - elem.scrollTop;\n        elem = elem.offsetParent;\n    }\n    return { top: y, left: x };\n}\n\nexport const uuid = () => {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n        const r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);\n        return v.toString(16);\n    }).replace(/-/g,\"\");\n}\n\nexport const pauseEvent = (e) => {\n    try {\n        if (e.stopPropagation) e.stopPropagation();\n        if (e.preventDefault) e.preventDefault();\n        e.cancelBubble = true;\n        e.returnValue = false;\n    } catch (err) {}\n    return false;\n}\n\n\n\nexport const notNull = (value) => {\n    return typeof(value) !== \"undefined\" && value !== null;\n}\n\nexport const mergeObjects = (...objects) => {\n    if (!objects.length) {\n        return null;\n    }\n    let result = objects[0];\n    if (objects.length === 1) {\n        return result;\n    }\n    for (let index=1;index<objects.length;index++) {\n        if (notNull(objects[index]) && typeof(objects[index]) === \"object\") {\n            result = deepmerge(result, objects[index]);\n        }\n    }\n    return result;\n}\n\nexport const round = (number,precission) => {\n    return Math.round(number*precission)/precission;\n}\n\nexport const dataURLtoBlob = (dataURI) => {\n    const byteString = atob(dataURI.split(',')[1]);\n    const mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0]\n    const ab = new ArrayBuffer(byteString.length);\n    const ia = new Uint8Array(ab);\n    for (let i = 0; i < byteString.length; i++) {\n        ia[i] = byteString.charCodeAt(i);\n    }\n    return new Blob([ab], {type: mimeString});\n}\n\nexport const blobToDataURL = (blob) =>{\n    return new Promise(resolve => {\n        const reader = new FileReader();\n        reader.onload = function(e) {resolve(e.target.result);}\n        reader.readAsDataURL(blob);\n    })\n}\n\nexport const readJSON = (jsonString) => {\n    try {\n        return JSON.parse(jsonString);\n    } catch (err) {\n        return null;\n    }\n}\n\nexport const CSStoJsStyleName = (cssName) => {\n    let result = cssName;\n    let index = result.indexOf(\"-\");\n    while (index !== -1) {\n        result = result.replace(\"-\"+result[index+1],result[index+1].toString().toUpperCase())\n        index = result.indexOf(\"-\");\n    }\n    return result;\n\n}\n\nexport const recursiveDeepCopy = (o) => {\n    let newO, i;\n\n    if (typeof o !== 'object') {\n        return o;\n    }\n    if (!o) {\n        return o;\n    }\n\n    if ('[object Array]' === Object.prototype.toString.apply(o)) {\n        newO = [];\n        for (i = 0; i < o.length; i += 1) {\n            newO[i] = recursiveDeepCopy(o[i]);\n        }\n        return newO;\n    }\n\n    newO = {};\n    for (i in o) {\n        if (o.hasOwnProperty(i)) {\n            newO[i] = recursiveDeepCopy(o[i]);\n        }\n    }\n    return newO;\n}\n\nexport const abs = (value) => value < 0 ? -value : value;\n\nexport const timeout = (ms) => {\n    return new Promise(resolve => {\n        setTimeout(() => {\n            resolve()\n        },ms);\n    })\n}\nexport {radians_to_degrees,degrees_to_radians,getRotatedCoords,distance,isPointInsidePolygon,rectsOverlap};\n","/**\n * @ignore\n * Function used to create SmartShape event from raw Javascript DOM event.\n * @param origEvent {Event} Original DOM event to get as a base\n * @param params {object} Params to add to event\n */\nimport {getOffset} from \"../utils/index.js\";\n\nexport const createEvent = (origEvent,params={}) => {\n    const result = {};\n    for (let key in origEvent) {\n        if (key !== \"type\" && key !== \"target\") {\n            result[key] = origEvent[key];\n        }\n    }\n    Object.keys(params).forEach((key) => {\n        result[key] = params[key];\n    })\n    return result;\n}\n\n/**\n * @ignore\n * Method returns coordinates of mouse cursor from Mouse event\n * @param event {MouseEvent}\n * @param elem {HTMLElement}\n * @returns {array} Coordinates as an array [x,y]\n */\nexport const getMouseCursorPos = (event,elem=null) => {\n    if (!elem) {\n        elem = event.target.root || event.target;\n    }\n    return getMousePos(elem, event.pageX, event.pageY);\n}\n\nexport const getMousePos = (elem, x, y) => {\n    const offset = getOffset(elem,true);\n    return [x-offset.left,y-offset.top];\n}\n","/**\n * @ignore\n * Used as a singleton object to emit events and subscribe to these events.\n * One object can subscribe to events of specified type, other object can emit events of this type.\n * Each time when object emits event, all subscribed event handlers triggered.\n * @constructor\n */\nfunction EventsManager() {\n\n    /**\n     * Hashmap of all registered event subscriptions.\n     * Keys are event names as strings. Values are arrays of functions.\n     * Several handlers can subscribe to each event by providing function that should be triggered.\n     * this.subscriptions[event_name] = [handler_func,handler_func ...]\n     * @type {object}\n     */\n    this.subscriptions = {};\n\n    /**\n     * Add subscription to event of specified type or to array of events of specified types\n     * @param events {string|array} Name of event as a string or names of events as an array of strings.\n     * @param handler {function} Handling function, which will be called each time when event of this type emitted.\n     * Each time, when handling function triggered, it receives a single argument - `event` {object} which contains\n     * the following fields: `type` - type of event (`eventType`), `target` - pointer to object, which emitted\n     * this event, and also any custom params, that emitter sent with this event by using `emit` method.\n     * @returns {function} Pointer to handling function, that will be added\n     */\n    this.subscribe = (events,handler) => {\n        if (typeof(events) === \"string\") {\n            return this.subscribeToEvent(events,handler)\n        } else if (typeof(events) === \"object\") {\n            for (let event of events) {\n                this.subscribeToEvent(event,handler)\n            }\n            return handler;\n        }\n        return null;\n    }\n\n    /**\n     * @ignore\n     * Add subscription to event of specified type\n     * @param eventName {string|array} Name of event as a string or array of names of events to subscribe to\n     * @param handler {function} Handling function, which will be called each time when event of this type emitted.\n     * Each time, when handling function triggered, it receives a single argument - `event` {object} which contains\n     * the following fields: `type` - type of event (`eventType`), `target` - pointer to object, which emitted\n     * this event, and also any custom params, that emitter sent with this event by using `emit` method.\n     * @returns {function} Pointer to handling function, that will be added\n     */\n    this.subscribeToEvent = (eventName,handler) => {\n        if (typeof(this.subscriptions[eventName]) === \"undefined\" || !this.subscriptions[eventName]) {\n            this.subscriptions[eventName] = [];\n        }\n        if (typeof(this.subscriptions[eventName].find(h => h === handler)) !== \"undefined\") {\n            return null;\n        }\n        this.subscriptions[eventName].push(handler);\n        return handler;\n    }\n\n    /**\n     * Emits event of specified name. Based on specified arguments, it constructs `event` object, that contains\n     * the following fields: `type` - eventName, `target` - object that emitted this event and any other fields\n     * that received from `params` argument. Then, all subscribers will receive this `event` object to their handling\n     * functions.\n     * @param eventName {string} Name of event to emit.\n     * @param target {object} Which object emitted this event.\n     * @param params {object} Event specific params. Can be any number of params.\n     * @returns {boolean} True if this event triggered at least of one handler, or false if it does not.\n     */\n    this.emit = (eventName,target,params=null) => {\n        if (!params || typeof(params) !== \"object\") {\n            params = {}\n        }\n        params[\"type\"] = eventName;\n        params[\"target\"] = target;\n        if (typeof(this.subscriptions[eventName]) !== \"undefined\" && this.subscriptions[eventName] &&\n        this.subscriptions[eventName].length) {\n            for (let handler of this.subscriptions[eventName]) {\n                handler(params)\n            }\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Removes specified handler from event with specified name or from array of events with specified names.\n     * @param events {string|array} Name of event as a string or names of events as an array of strings.\n     * @param handler {function} Pointer to a function to remove. (This pointer returned from `subscribe` method and\n     * can be used here to unsubscribe\n     * @returns {boolean} True if really removed the handler or false if you could not remove because it does not exist\n     */\n    this.unsubscribe = (events, handler) => {\n        let result = false;\n        if (typeof(events) === \"string\") {\n            if (this.unsubscribeFromEvent(events,handler)) {\n                result = true;\n            }\n        } else if (typeof(events) === \"object\") {\n            for (let event of events) {\n                if (this.unsubscribeFromEvent(event,handler)) {\n                    result = true;\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @ignore\n     * Removes specified handler from event with specified name.\n     * @param eventName {string} Name of event as a string\n     * @param handler {function} Pointer to a function to remove. (This pointer returned from `subscribe` method and\n     * can be used here to unsubscribe\n     * @returns {boolean} True if really removed the handler or false if you could not remove because it does not exist\n     */\n    this.unsubscribeFromEvent = (eventName,handler) => {\n        if (typeof(this.subscriptions[eventName]) === \"undefined\" || !this.subscriptions[eventName]) {\n            return false\n        }\n        const index = this.subscriptions[eventName].indexOf(handler);\n        if (index !== -1) {\n            this.subscriptions[eventName].splice(index,1);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Method removes all subscriptions to events.\n     */\n    this.clear = () => {\n        this.subscriptions = {};\n    }\n}\n\nexport default new EventsManager();\n","/**\n * Extender class for `Menu` class, which extends it by methods\n * used to change styles of menu panel and menu items. All methods of\n * this class can be executed directly on `Menu` instance.\n * @param menu {Menu} Menu object to extend\n * @constructor\n */\nfunction MenuStylesHelper(menu) {\n    /**\n     * Menu object to extend\n     * @type {Menu}\n     */\n    this.menu = menu;\n\n    /**\n     * CSS class that used to style menu panel\n     * @type {string}\n     */\n    this.panelCssClass = \"\";\n\n    /**\n     * CSS class name or names that used to style menu items DIV elements\n     * @type {string}\n     */\n    this.itemCssClass = \"\";\n\n    /**\n     * CSS class name or names that used to style text of menu items\n     * @type {string}\n     */\n    this.itemTextCssClass = \"\";\n\n    /**\n     * CSS class name or names that used to style images of menu items\n     * @type {string}\n     */\n    this.itemImageCssClass = \"\";\n\n    /**\n     * CSS classes for concrete items by their IDs.\n     * @type {object}\n     */\n    this.itemsCssClassesById = {};\n\n    /**\n     * @ignore\n     * Method used to apply styles to menu panel and items\n     * either from provided CSS classes or using default styles\n     */\n    this.setStyles = () => {\n        if (!this.menu.panel) {\n            return\n        }\n        if (!this.panelCssClass) {\n            this.menu.panel.style.padding = \"3px\";\n            this.menu.panel.style.borderStyle = \"solid\";\n            this.menu.panel.style.borderColor = \"#dddddd\";\n            this.menu.panel.style.borderWidth = \"1px\";\n            this.menu.panel.style.backgroundColor = \"#eeeeee\";\n            this.menu.panel.className = \"\";\n        } else {\n            this.menu.panel.className = this.panelCssClass;\n        }\n        for (let item of this.menu.items) {\n            this.setItemStyles(item);\n        }\n    }\n\n    /**\n     * @ignore\n     * Method used to apply styles to menu items and their parts\n     * either from provided CSS classes or using default styles\n     * @param item {object} Menu item object\n     */\n    this.setItemStyles = (item) => {\n        this.setItemDivStyles(item);\n        this.setItemSpanStyles(item);\n        this.setItemImageStyles(item);\n    }\n\n    /**\n     * @ignore\n     * Method used to apply styles to menu items DIVs\n     * either from provided CSS classes or using default styles\n     * @param item {object} Menu item object\n     */\n    this.setItemDivStyles = (item) => {\n        const itemDiv = this.menu.panel.querySelector(\"#\"+item.id);\n        if (!itemDiv) {\n            return\n        }\n        itemDiv.style.display = 'flex';\n        itemDiv.style.flexDirection = 'row';\n        itemDiv.style.alignItems = 'center';\n        if (this.itemsCssClassesById[item.id] && typeof(this.itemsCssClassesById[item.id]) == \"object\" &&\n            this.itemsCssClassesById[item.id][ItemParts.ITEM]) {\n            itemDiv.className = this.itemsCssClassesById[item.id][ItemParts.ITEM]\n        } else if (this.itemCssClass) {\n            itemDiv.className = this.itemCssClass || \"\";\n        } else {\n            itemDiv.className = \"\";\n            itemDiv.style.paddingTop = \"2px\";\n            itemDiv.style.paddingLeft = \"3px\";\n            itemDiv.style.paddingRight = \"3px\";\n            itemDiv.addEventListener(\"mouseover\", () => {\n                itemDiv.style.backgroundColor = \"#0066CC\";\n                itemDiv.style.color = \"white\";\n            })\n            itemDiv.addEventListener(\"mouseout\", () => {\n                itemDiv.style.backgroundColor = \"transparent\";\n                itemDiv.style.color = \"black\";\n            })\n        }\n        itemDiv.style.whiteSpace = 'nowrap';\n    }\n\n    /**\n     * @ignore\n     * Method used to apply styles to text of menu items\n     * either from provided CSS classes or using default styles\n     * @param item {object} Menu item object\n     */\n    this.setItemSpanStyles = (item) => {\n        const itemDiv = this.menu.panel.querySelector(\"#\"+item.id);\n        if (!itemDiv) {\n            return\n        }\n        const span = itemDiv.querySelector(\"span\");\n        if (span) {\n            if (this.itemsCssClassesById[item.id] && typeof(this.itemsCssClassesById[item.id]) == \"object\" &&\n                this.itemsCssClassesById[item.id][ItemParts.TEXT]) {\n                span.className = this.itemsCssClassesById[item.id][ItemParts.TEXT]\n            } else if (this.itemTextCssClass) {\n                span.className = this.itemTextCssClass;\n            } else {\n                span.className = \"\";\n                span.style.color = \"black\";\n            }\n        }\n    }\n\n    /**\n     * @ignore\n     * Method used to apply styles to images of menu items\n     * either from provided CSS classes or using default styles\n     * @param item {object} Menu item object\n     */\n    this.setItemImageStyles = (item) => {\n        const itemDiv = this.menu.panel.querySelector(\"#\"+item.id);\n        if (!itemDiv) {\n            return\n        }\n        const img = itemDiv.querySelector(\"img\");\n        if (img) {\n            if (this.itemsCssClassesById[item.id] && typeof (this.itemsCssClassesById[item.id]) == \"object\" &&\n                this.itemsCssClassesById[item.id][ItemParts.IMAGE]) {\n                img.className = this.itemsCssClassesById[item.id][ItemParts.IMAGE];\n            } else if (this.itemImageCssClass) {\n                img.className = this.itemImageCssClass;\n            } else {\n                img.className = \"\";\n            }\n        }\n    }\n\n    /**\n     * Method used to override CSS class for menu panel\n     * @param className {string} CSS class to apply\n     */\n    this.setPanelClass = (className=null) => {\n        this.panelCssClass = className || \"\";\n    }\n\n    /**\n     * Method used to override CSS class for menu items\n     * or only for menu item with specified `id`\n     * @param className {string} CSS class to apply\n     * @param id {string} ID of item or null\n     */\n    this.setItemClass = (className=null,id=null) => {\n        if (id) {\n            this.setClassForItem(id,ItemParts.ITEM, className);\n            return\n        }\n        this.itemCssClass = className || \"\";\n    }\n\n    /**\n     * Method used to override CSS class for text of menu items\n     * or only for menu item with specified `id`\n     * @param className {string} CSS class to apply\n     * @param id {string} ID of item or null\n     */\n    this.setTextClass = (className=null,id=null) => {\n        if (id) {\n            this.setClassForItem(id,ItemParts.TEXT, className);\n            return\n        }\n        this.itemTextCssClass = className || \"\";\n    }\n\n    /**\n     * Method used to override CSS class for images of menu items\n     * or only for menu item with specified `id`\n     * @param className {string} CSS class to apply\n     * @param id {string} ID of item or null\n     */\n    this.setImageClass = (className=null,id=null) => {\n        if (id) {\n            this.setClassForItem(id,ItemParts.IMAGE,className);\n            return\n        }\n        this.itemImageCssClass = className || \"\";\n    }\n\n    /**\n     * @ignore\n     * Method that sets CSS classes for different parts of menu item with specified `id`\n     * @param id {string} ID of menu item\n     * @param classType {ItemParts} name of part to apply CSS class to: `item`, `text` or `image`\n     * @param className\n     */\n    this.setClassForItem = (id,classType,className) => {\n        if (!this.itemsCssClassesById[id] || typeof(this.itemsCssClassesById[id]) === \"undefined\") {\n            this.itemsCssClassesById[id] = {};\n        }\n        this.itemsCssClassesById[id][classType] = className;\n    }\n}\n\n/**\n * Enumeration of menu item parts using internally\n * to define CSS classes for different parts of menu item\n * @param div DIV element that contains menu item\n * @param text text inside menu item\n * @param image image inside menu item\n * @enum\n */\nconst ItemParts = {\n    ITEM: \"div\",\n    TEXT: \"text\",\n    IMAGE: \"image\"\n}\n\nexport default MenuStylesHelper;\n","/**\n * @ignore\n * Function used to create a custom event from raw Javascript DOM event.\n * @param origEvent {Event} Original DOM event to get as a base\n * @param params {object} Params to add to event\n */\nexport const createEvent = (origEvent,params={}) => {\n    const result = {};\n    for (let key in origEvent) {\n        if (key !== \"type\" && key !== \"target\") {\n            result[key] = origEvent[key];\n        }\n    }\n    Object.keys(params).forEach((key) => {\n        result[key] = params[key];\n    })\n    return result;\n}\n\nexport const blobToDataURL = (blob) =>{\n    return new Promise(resolve => {\n        const reader = new FileReader();\n        reader.onload = function(e) {resolve(e.target.result);}\n        reader.readAsDataURL(blob);\n    })\n}\n","import StylesHelper from \"./MenuStylesHelper.js\";\nimport EventsManager from \"./EventsManager.js\";\nimport {createEvent} from \"./functions.js\";\n\n/**\n * Context menu panel object.\n * @param items {array} Array of menu items. Each item is an object with a following fields:\n * `id` - unique ID of menu item.\n * `title` - Text of menu of item\n * `image` - URL of image, displayed on the left side of menu item (optional)\n * @param container {HTMLElement} HTML element to which this menu belongs\n * @param eventType {string} Name of event on HTML element that triggers the menu to appear\n * (by default `contextmenu`, triggers when user do right mouse click on element)\n * @constructor\n */\nfunction Menu(items,container,eventType=null, options={}) {\n    /**\n     * Menu panel element\n     * @type {HTMLDivElement}\n     */\n    this.panel = null;\n\n    /**\n     * Event on HTML element that triggers the menu to appear\n     * @type {HTMLElement}\n     */\n    this.container = container;\n\n    /**\n     * Array of menu items. Each item is an object with a following fields:\n     * `id` - unique ID of menu item.\n     * `title` - Text of menu of item\n     * `image` - URL of image, displayed on the left side of menu item (optional)\n     * @type {Array}\n     */\n    this.items = items;\n\n    /**\n     * Name of event on HTML element that triggers the menu to appear\n     * (by default `contextmenu`, triggers when user do right mouse click on element)\n     * @type {string}\n     */\n    this.event = eventType || \"contextmenu\";\n\n    /**\n     * Additional options for context menu\n     * @param customHandler {function} Custom function, that will be triggered on menu\n     * display instead of original one. Function receives two arguments: `menu` with link to menu\n     * and `event` with context menu Mouse Event object\n     */\n    this.options = options;\n\n    /**\n     * @ignore\n     * All registered listeners of mouse events on menu items HTML elements.\n     * keys of object are event types (like 'click', 'mouseover', 'mouseout')\n     * values of object are arrays of functions. Each function is one of event listeners,\n     * registered for this event\n     * @type {array}\n     */\n    this.listeners = {};\n\n    /**\n     * @ignore\n     * Original event object which triggered on `container` element when menu appeared\n     * @type {Event}\n     */\n    this.origEvent = null;\n\n    /**\n     * Mouse cursor X position in a moment when event to show menu triggered\n     * @type {number}\n     */\n    this.cursorX = 0;\n\n    /**\n     * Mouse cursor Y position in a moment when event to show menu triggered\n     * @type {number}\n     */\n    this.cursorY = 0;\n\n    /**\n     * @ignore\n     * Temporary value of body overflowY style before menu appeared.\n     * Used for internal reasons.\n     * @type {string}\n     */\n    this.overflowY = \"\";\n\n    /**\n     * @ignore\n     * The maximum height of all images of menu items. Used to\n     * calculate correct width for image of items\n     * @type {number}\n     */\n    this.maxImageHeight = 0;\n\n    /**\n     * @ignore\n     * List of subscribers, that subscribed to events, emitted by\n     * this menu. This is an object, that consists of array\n     * of event handlers of each event. Each handler is a function\n     * that called when event of specified type emitted by\n     * this shape\n     * @type {object}\n     */\n    this.subscriptions = {};\n\n    /**\n     * Method constructs and initializes menu, based on\n     * settings, provided in constructor\n     * @returns {Menu} this menu object\n     */\n    this.init = () => {\n        Object.assign(this,new StylesHelper(this));\n        this.listener = (event) => {\n            this.onEvent(event);\n            return false;\n        };\n        this.container.addEventListener(this.event, this.listener);\n        EventsManager.emit(MenuEvents.CREATE,this,{owner:this});\n        return this;\n    }\n\n    /**\n     * @ignore\n     * Method executed when event that should show menu triggers on `container` element\n     * @param event {Event} Event object\n     */\n    this.onEvent = (event) => {\n        if (this.options.customHandler && typeof(this.options.customHandler === \"function\")) {\n            this.options.customHandler(this,event);\n            return\n        }\n        this.origEvent = event;\n        event.preventDefault();\n        event.stopPropagation();\n        event.cancelBubble = true;\n        this.cursorX = event.pageX;\n        this.cursorY = event.pageY;\n        this.show();\n    }\n\n    /**\n     * @ignore\n     * Method used to construct menu HTML element with it items\n     */\n    this.drawMenu = () => {\n        try {\n            document.body.removeChild(this.panel);\n        } catch (err) {}\n        this.panel = document.createElement(\"div\");\n        document.body.appendChild(this.panel);\n        for (let item of this.items) {\n            if (this.panel.querySelector(\"#\"+item.id)) {\n                continue;\n            }\n            const div = document.createElement(\"div\");\n            div.id = item.id;\n            div.style.cursor = 'pointer';\n            const span = document.createElement(\"span\");\n            span.innerHTML = item.title;\n            div.appendChild(span);\n            this.panel.appendChild(div);\n        }\n        this.setStyles();\n        this.drawImages();\n        this.setStyles();\n        this.setItemsEventListeners();\n        this.panel.style.display = 'none'\n    }\n\n    /**\n     * @ignore\n     * Method used to inject images to menu items\n     * while constructing them\n     */\n    this.drawImages = () => {\n        if (!this.panel) {\n            return\n        }\n        const imgItems = this.items.filter(item => item.image && typeof(item.image)!== \"undefined\");\n        this.maxImageHeight = 0;\n        for (let item of imgItems) {\n            const img = new Image();\n            if (!this.panel) {\n                continue;\n            }\n            const span = this.panel.querySelector(\"#\"+item.id+\" > span\");\n            img.style.display = 'none';\n            img.src = item.image;\n            if (!this.panel) {\n                return\n            }\n            const div = document.createElement(\"div\");\n            div.style.marginRight = '5px';\n            div.style.display = 'flex';\n            div.style.flexDirection = 'row';\n            div.style.justifyContent = 'center';\n            div.style.alignItems = 'center';\n            img.height = this.panel.querySelector(\"#\" + item.id).clientHeight;\n            if (img.height > this.maxImageHeight) {\n                this.maxImageHeight = img.height;\n            }\n            img.style.verticalAlign = \"middle\";\n            img.style.display = '';\n            div.appendChild(img)\n            if (!this.panel.querySelector(\"#\"+item.id+\" div\")) {\n                this.panel.querySelector(\"#\" + item.id).insertBefore(div, span);\n            }\n        }\n        this.adjustImagesWidth();\n    }\n\n    /**\n     * @ignore\n     * Method used to set up event listening functions for all menu items.\n     * It forwards these events to all `subscribers`, connected to the menu object\n     */\n    this.setItemsEventListeners = () => {\n        for (let name of [\"click\",\"mouseover\",\"mouseout\",\"dblclick\",\"mousedown\",\"mouseup\",\"mousemove\"]) {\n            this.setListenersForMouseEvent(name)\n        }\n    }\n\n    /**\n     * Set event listeners for all menu items for specified mouse event\n     * @param eventName {string} Mouse event name (click,mousedown,mouseup ...)\n     */\n    this.setListenersForMouseEvent = (eventName) => {\n        for (let item of this.items) {\n            this.setListenerForItem(eventName,item)\n        }\n    }\n\n    /**\n     * Set mouse event listener for specified event for specified menu item\n     * @param eventName {string} Mouse event name (click,mousedown,mouseup ...)\n     * @param item {object} Menu item object\n     */\n    this.setListenerForItem = (eventName, item) => {\n        const listener = (event) => {\n            if (!this.origEvent) {\n                return\n            }\n            EventsManager.emit(eventName, this.origEvent.target, createEvent(event, {\n                container: this.container, owner:this, cursorX: this.cursorX, cursorY: this.cursorY, itemId: item.id\n            }))\n            setTimeout(() => {\n                if ([\"click\", \"mousedown\", \"mouseup\", \"dblclick\"].indexOf(eventName) !== -1) {\n                    if (event.button !== 2) {\n                        this.hide();\n                    }\n                }\n            }, 100)\n        }\n        this.listeners[eventName+\"_\"+item.id] = listener;\n        this.panel.querySelector(\"#\"+item.id).addEventListener(eventName, listener)\n    }\n\n    /**\n     * @ignore\n     * Internal method that used to adjust image size to match size of menu item text\n     * and correct width to respect aspect ratio and align all items correctly\n     */\n    this.adjustImagesWidth = () => {\n        if (!this.panel) {\n            return\n        }\n        let maxSize = 0;\n        for (let item of this.items) {\n            if (this.panel.querySelector(\"#\"+item.id).clientHeight > maxSize) {\n                maxSize = this.panel.querySelector(\"#\"+item.id).clientHeight;\n            }\n        }\n        for (let img of this.panel.querySelectorAll(\"img\")) {\n            img.parentNode.style.width = maxSize+\"px\";\n            img.parentNode.style.height = maxSize+\"px\";\n        }\n\n    }\n\n    /**\n     * Method shows menu\n     */\n    this.show = () => {\n        if (!this.container) {\n            return\n        }\n        EventsManager.emit(MenuEvents.SHOW,this,{owner:this});\n        this.drawMenu();\n        if (!this.panel) {\n            return\n        }\n        this.panel.style.display = '';\n        let left = this.cursorX;\n        let top = this.cursorY;\n        this.panel.style.left = left +\"px\";\n        this.panel.style.top = top+\"px\";\n        this.panel.style.zIndex = \"10000\";\n        this.panel.style.position = 'absolute';\n        if (left+this.panel.clientWidth > window.innerWidth) {\n            left = window.innerWidth - this.panel.clientWidth - 10;\n            this.panel.style.left = left +\"px\";\n        }\n        if (this.origEvent && this.origEvent.clientY+this.panel.clientHeight > window.innerHeight) {\n            top = top - (window.innerHeight + this.panel.clientHeight-20) + this.origEvent.clientY;\n            this.panel.style.top = top +\"px\";\n        }\n    }\n\n    /**\n     * Method hides menu\n     */\n    this.hide = () => {\n        if (this.panel) {\n            this.panel.style.display = 'none';\n        }\n    }\n\n    /**\n     * Method used to dynamically add item to menu\n     * @param id {string} Unique ID of item\n     * @param title {string} Text of menu item\n     * @param image {string} URL of menu item image (optional)\n     */\n    this.addItem = (id,title,image=null) => {\n        const item = {id,title};\n        if (image) {\n            item.image = image;\n        }\n        this.items.push(item);\n    }\n\n    /**\n     * Method used to remove menu item\n     * @param id {string} ID of item to remove\n     */\n    this.removeItem = (id) => {\n        const index = this.items.findIndex(item => item.id === id)\n        if (index !== -1) {\n            this.items.splice(index, 1);\n        }\n    }\n\n    /**\n     * Method used to return HTML node of menu item by ID\n     * @param id {string} ID of menu item\n     * @returns {HTMLDivElement} DIV html element of menu item\n     */\n    this.findItemById = (id) => Array.from(this.panel.querySelectorAll(\"div\")).find(item => item.id === id);\n\n    /**\n     * Method used to set unique ID of this menu panel.\n     * @param id {string} ID to set\n     */\n    this.setId = (id) => this.panel.id = id;\n\n    /**\n     * @ignore\n     * Uniform method that used to add event handler of specified type to this object.\n     * @param eventName {string} Name of event\n     * @param handler {function} Function that used as an event handler\n     * @returns {function} Pointer to added event handler. Should be used to remove event listener later.\n     */\n    this.addEventListener = (eventName,handler) => {\n        if (typeof(this.subscriptions[eventName]) === \"undefined\") {\n            this.subscriptions[eventName] = [];\n        }\n        const listener = EventsManager.subscribe(eventName, (event) => {\n            if (event.owner === this) {\n                handler(event)\n            }\n        });\n        this.subscriptions[eventName].push(listener);\n        return listener;\n    }\n\n    /**\n     * @ignore\n     * Uniform method that used to remove event handler, that previously added\n     * to this object.\n     * @param eventName {string} Name of event to remove listener from\n     * @param listener {function} Pointer to event listener, that added previously.\n     * It was returned from [addEventListener](#ResizeBox+addEventListener) method.\n     */\n    this.removeEventListener = (eventName,listener) => {\n        if (this.subscriptions[eventName] && typeof(this.subscriptions[eventName]) !== \"undefined\") {\n            this.subscriptions[eventName].splice(this.subscriptions[eventName].indexOf(listener), 1);\n        }\n        EventsManager.unsubscribe(eventName,listener)\n    }\n\n    /**\n     * Method used to subscribe to menu item event.\n     * @param eventName {string} Name of event to subscribe (click, mouseover, mouseout or other)\n     * @param handler {function} Handler function that will execute on event. Function receives `event` argument\n     * which is a standard MouseEvent with all properties and in addition, contains the following important fields:\n     * `itemId` - ID of menu item that triggered this event, `cursorX` - X position of mouse cursor on container in a\n     * moment the menu appeared, `cursorY` - Y position of mouse cursor on container in a moment the menu appeared.\n     * @returns {function} Returns a created listener object which can be used later to unsubscribe from this event\n     */\n    this.on = (eventName,handler) => {\n        return this.addEventListener(eventName, handler)\n    }\n\n    /**\n     * Method used to unsubscribe from menu item event\n     * @param eventName {string} name of event to unsubscribe, (click, mouseover, mouseout or other)\n     * @param handler {function} event handler to remove from subscriptions, that previously returned by `on` function\n     */\n    this.off = (eventName,handler) => {\n        this.removeEventListener(eventName, handler);\n    }\n\n    /**\n     * Method used to unsubscribe from all events, previously subscribed using `on` or `addEventListener`\n     * methods\n     */\n    this.removeAllEventListeners = () => {\n        for (let eventName in this.subscriptions) {\n            for (let handler of this.subscriptions[eventName]) {\n                EventsManager.unsubscribe(eventName,handler);\n            }\n        }\n        if (this.container) {\n            this.container.removeEventListener(this.event, this.listener);\n        }\n        this.subscriptions = {};\n        if (!this.panel) {\n            return\n        }\n        for (let listener in this.listeners) {\n            const [name,id] = listener.split(\"_\");\n            const div = this.panel.querySelector(\"#\"+id);\n            if (div) {\n                div.removeEventListener(name, this.listeners[listener]);\n            }\n        }\n    }\n\n    /**\n     * Method used to destroy menu: removes all subscriptions\n     * and menu panel element from DOM.\n     */\n    this.destroy = () => {\n        this.removeAllEventListeners();\n        this.items = [];\n        this.container = null;\n        try {\n            document.body.removeChild(this.panel);\n        } catch (err) {}\n        if (this.panel) {\n            this.panel.innerHTML = \"\";\n        }\n        this.panel = null;\n        EventsManager.emit(MenuEvents.DESTROY,this,{owner:this});\n    }\n}\n\n/**\n * Enumeration of menu events\n * @enum\n */\nexport const MenuEvents = {\n    CREATE: \"create\",\n    DESTROY: \"destroy\",\n    SHOW: \"show\"\n}\n\nexport default Menu;\n","import EventsManager from \"./EventsManager.js\";\nimport Menu, {MenuEvents} from \"./Menu.js\";\n\n/**\n * Factory class for menus. Used to construct new context menus.\n * @constructor\n */\nfunction Menus() {\n\n    /**\n     * Collection of all created menus\n     * @type {array}\n     */\n    this.menus = [];\n\n    /**\n     * Method used to create new context menu\n     * @param items {array} Items to include to menu. Each item is an object with fields:\n     * `id` - ID of menu item, `title` - text of menu item, `image` - URL of image of menu item (optional)\n     * @param container {HTMLElement} HTML element to which this menu belongs\n     * @param eventName {string} Name of event which should be triggered on `container` to display this menu. By\n     * default `contextmenu`, so, menu will appear when right mouse click on it. Could be any other mouse event\n     * like `click`, `mouseover`, `mousedown` or others.\n     * @returns {Menu} Constructed [Menu](#Menu) object.\n     */\n    this.create = (items,container,eventName=\"contextmenu\",options={}) => {\n        return new Menu(items,container,eventName,options).init();\n    }\n\n    EventsManager.subscribe(MenuEvents.CREATE, (event) => {\n        if (this.menus.indexOf(event.target) === -1) {\n            this.menus.push(event.target);\n            event.target.id = this.menus.length;\n        }\n    })\n\n    EventsManager.subscribe(MenuEvents.DESTROY, (event) => {\n        if (this.menus.indexOf(event.target) !== -1) {\n            this.menus.splice(this.menus.indexOf(event.target),1);\n        }\n    })\n\n    EventsManager.subscribe(MenuEvents.SHOW, (event) => {\n        this.menus.forEach(menu => {\n            if (menu !== event.target) {\n                menu.hide()\n            }\n        })\n    })\n\n    document.addEventListener(\"mouseup\", (event) => {\n        if (event.button!==2) {\n            this.menus.forEach(menu => menu.hide())\n        }\n    })\n}\n\nexport default new Menus();\n","import Menus from \"./Menus.js\";\ntry {\n    window.Menus = Menus;\n} catch {}\n\nexport {Menus};\n","export const rotate_tl = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA0AAAANCAYAAABy6+R8AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAB3RJTUUH5gkIECcZZuWhdAAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAABaSURBVCjPlZBBEsAgCAMT/v/n7akzWAFtTo5mQ8SAJtkGcL4LXcg211A2L+eq3jc5C/AGTUBZ7wYAHH+B4yIAv8a8dkvilLz9qXuYKseU2E7qDFODqIwTIEkPSldAAa0WlbUAAAAASUVORK5CYII=\";\nexport const rotate_tr = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA0AAAANCAYAAABy6+R8AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAB3RJTUUH5gkIECgYlnqNLQAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAABZSURBVCjPlZFBCgAxCANN/v/n2VOhiFU3N4U4GgXELUkAikbOhlhIh1QZXkR3hGc/IsaVMtHT0RXR3e5jescIqBpy05T/tInffw2AvEkr972N+a69+U8e8AGOtEABr4X+4AAAAABJRU5ErkJggg==\";\nexport const rotate_br= \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA0AAAANCAYAAABy6+R8AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAB3RJTUUH5gkIECkWaNmRawAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAABjSURBVCjPlZBRDsAgCENbsnt6/1N0P2ocijASEy08iqC1BknhASCvsSeOQXImJXHcrQL4t1UAr4fjReDmdCsc/5LEZ7NOwOlUKVy3RwC/AAAwL2TAZ3t+xFszOxVl7lbtvsYLOtlZCOj2NccAAAAASUVORK5CYII=\";\nexport const rotate_bl = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA0AAAANCAYAAABy6+R8AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAB3RJTUUH5gkIECoXNPPyPgAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAABaSURBVCjPlVFBEgAhCAL+/2f21I5jqcXFGRMSpG1EkLRtooEyIdaRlAc7orqBsg+gVKy8yTYn49vqMb0pgCUuPOBP93Sniaxb8/FdL6mt/rZe5SMKXQWRf/4AYrs6C0ViuwUAAAAASUVORK5CYII=\";\nexport const resize_cb = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA0AAAANCAYAAABy6+R8AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAB3RJTUUH5gkIEDsHep3BSgAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAAA8SURBVCjPY2DADf7jkmAkQgMjMZr+EzKckVgnIatlJFIDinqynMfEQAYgSxNV/ERy6JEdT0SlCAZy0h4AXLILDAEWNOwAAAAASUVORK5CYII=\";\nexport const resize_ct = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA0AAAANCAYAAABy6+R8AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAB3RJTUUH5gkIEDMMJZaSygAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAAA/SURBVCjPY2DADf7jkmAkQgMjMZr+EzKckVgnIatlJFIDinqynMfEQAYgSxNV/ERy6JEdT0SlCJxAWZoFp1MBY8cLTv/x72kAAAAASUVORK5CYII=\";\nexport const resize_lb = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA0AAAANCAYAAABy6+R8AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAB3RJTUUH5gkIEQARsznxFAAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAABBSURBVCjPtZAxDgAgCAOvxP9/GTfjolISOxIK7UFDOszz5gnzGADRiReNeMuUVQPAcJbdTtrhqILY/aTvyG04T00vswcW6BsN2AAAAABJRU5ErkJggg==\";\nexport const resize_lc = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA0AAAANCAYAAABy6+R8AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAB3RJTUUH5gkIEQEbSvcpSwAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAAA3SURBVCjPY2AYSPCfAJ+BiZACbOKMRGjAUM9Igga4RkYSNTCICjCTbxPJfsIWSv+JECM9nugHAG40DyW1OoLPAAAAAElFTkSuQmCC\";\nexport const resize_lt = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA0AAAANCAYAAABy6+R8AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAB3RJTUUH5gkIEDIpd4l3zAAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAAA+SURBVCjPY2AgAzBC6f9EqIEDJiINJUkTAzma/pNr0390NguRLvqPyyZGXB4nKnQIRQETiYZRP8j/M1AbAADcMAcWozKAnAAAAABJRU5ErkJggg==\";\nexport const resize_rb = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA0AAAANCAYAAABy6+R8AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAB3RJTUUH5gkIEDYr/evT5AAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAAA+SURBVCjPY2AgAzBC6f9EqIEDJiINJUkTAzma/pNr0390NguRLvqPyyZGXB4nKnQIRQETiYZRP8j/M1AbAADcMAcWozKAnAAAAABJRU5ErkJggg==\";\nexport const resize_rc = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA0AAAANCAYAAABy6+R8AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAB3RJTUUH5gkIEDUsSKIVhAAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAAA0SURBVCjPY2AYSPCfAJ+BiZACbOKMRGjAUM9Igga4RkYSNTBQZBPJfsIWSv+JECM9nugHADv6Dv2P6G4ZAAAAAElFTkSuQmCC\";\nexport const resize_rt = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA0AAAANCAYAAABy6+R8AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAB3RJTUUH5gkIEDQQftZYQgAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAABBSURBVCjPtZAxDgAgCAOvxP9/GTfjolISOxIK7UFDOszz5gnzGADRiReNeMuUVQPAcJbdTtrhqILY/aTvyG04T00vswcW6BsN2AAAAABJRU5ErkJggg==\";\nexport const add = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAQAAABKfvVzAAAAAmJLR0QA/vCI/CkAAAAJcEhZcwAADdYAAA3WAZBveZwAAAAJdnBBZwAAABgAAAAYAHhMpaYAAAEDSURBVDjLzZPNSsQwEIC/CUWtQlnZi14EYb36Jj6DT+ZT+BSevImHPYggKLpo2bW1Ze14yJjFtKEed3poMpmvzZcf2LqQfkolZFV0FFDhkMI6JR99JAbczTlP/tGZung86yN7Spn+4ABw0PH5DyCoOoSvYOg00s9C+YSpL8oLGgMmnOILF2r68qvKibvWXd9hbsCZ/ajpLniULnKQO82tubb3vY3Uw9IrvhOmCaDFJYC2DyjLt1vNQGjzI5v7+1wrBWTN0uQ3R0OFfQRwz7PjS8td8UAHKFW0rCDqt0ud1mEfKlZ+bYYdNtGQjAFgh6L+M9sRQKev5Yu1F4zfh7ELtIXxA+JiW9aVMPJ4AAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDE3LTExLTIwVDEwOjE1OjExLTAwOjAwfzVXkwAAACV0RVh0ZGF0ZTptb2RpZnkAMjAxNy0xMS0yMFQxMDoxNToxMS0wMDowMA5o7y8AAAAZdEVYdFNvZnR3YXJlAHd3dy5pbmtzY2FwZS5vcmeb7jwaAAAAAElFTkSuQmCC\";\nexport const del = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABmJLR0QA/gD+AP7rGNSCAAAACXBIWXMAAA3WAAAN1gGQb3mcAAAACXZwQWcAAAAYAAAAGAB4TKWmAAACn0lEQVRIx+2U30tTYRzGn/fsPdOmNkWDsEDnOiFCbv4KhPJCFAvDtBuRyL/A64TwQkGaCt7pVYqimHhTJAVhuYsRE5zipLuZeQKNsMQdN1vbzvbtwg2Oa5s/uvWBl3Px8P18OO/7ngNc5H9DROw8XTxCumEiygJwjYh4kp7HuqzTiJLBc8aslr5+vbiy43SWaiVExHecztJ+vbgyZrX0EVHOqSVx+ERFee8wR3hcBNky+VpcEofbMvnauAga5ghPVJT3ppKwJIKsqRrr0/3P68+KdeAMgBIFfgjc/cT+6TEATNffmbkaVa1GASAAcgRq3i3L806Xe4gxdqjl8QS4ACBPDPibpIwjOAAUAOBR1fqy8e4MAFwXVGuuZlLi4ErA3wTgBREFGGPRdG+gCytKy3JDTdfvrxv12s4bOXrm6o7PGEok++2PrhHRaJxnjEXSblFMog/7lea1xn8liTGUSPaKD64RMdv4jjEWOvEMtJKIX2lev1fTFdhKLrlkkuyW964RXQo4kOY7ABBVNj0e+eDwMudAsiUfHF5WNj0eANFUkFRbxPdWl268elA3Wyyq1nwx+fBeGJDD3P3oraMjv6r2C2NMPVFARLq91SXpTUvdrEmvWgv0SJtfIWArxN0P5x0d+VW1G2kPOXZNC6dMma+LebD6SgI8o+imHQCC3zzHzuRnCJDVjJXOrT9tAL5rr+mxM4gV+w3dPY7CbCEkciC+DGbJXjS3PFo0tzxqMEt2bVeYLYQaunscAPa18KSJ/SrMyuSgTa4WgnIlaLtVWlR93jYi0hORXvV527ZbpUW5EiRXC0FlctBGROaz/o/Mvumhgd32soU4XNPrVZ+3bbe9bME3PTRwJniCxERE97VwrSTWmc4MTxSdp7vIqfMXBoR6XMSZc1QAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTctMTEtMjBUMTA6MTU6MTEtMDA6MDB/NVeTAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE3LTExLTIwVDEwOjE1OjExLTAwOjAwDmjvLwAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAASUVORK5CYII=\";\nexport const save = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAQAAABKfvVzAAAAAmJLR0QA/vCI/CkAAAAJcEhZcwAADdYAAA3WAZBveZwAAAAJdnBBZwAAABgAAAAYAHhMpaYAAAG6SURBVDjLlZK/TxNhGMc/z117FgWbNulITGMYTMvAaHAyhMTAIoOmcdD/wMWERdO4E8If4OJASBgcGcA4QRgx4YcLA4aUYDTRCoX2fj0OvTu441rwuem+7/N5n/f7PA/8ZwholiHuYCCXdMWnxYk4KYwWSws0+JX4GqUFLaqRVmHYWFUfTZ6I4U9ynKyRAUztoNsfq6f4gWrsDI6+VMGMPTMCwIHqGt+xA9Wq3uNFuukIoIUtduiYFs51QDIcwMSKrHn4otcBebJ4QfofmnghYKcANlCQxaj505xcAL0qGM1lFEXwwsH2B/zi0/DXXbps2k0YtDBxAbxvPbtUL7/Xi8HVy90ntXdwVUUgHKGADufedrJUsGKWd2857aXMXLAy4j7nUOxuhdabvfmR86/x0gPO7AFn3lYkCJaqON31HqVCNpZvMkCDA3kVtfUD5/yVYwFQ48qaZShO1VeqbEbKwyfbK+/kx5VtDO4TLO/Rs7FPpVCZ+bm8Za5LpwcAKuTajycebBQAxn9/3st9oSPaEwAVbjcnx+/vDlZON/bza5yJ0j9UNH9Um3h9VNO7/a6OIwWd0sIN09PiH5BSrD/OwMFRAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDE3LTExLTIwVDEwOjE1OjExLTAwOjAwfzVXkwAAACV0RVh0ZGF0ZTptb2RpZnkAMjAxNy0xMS0yMFQxMDoxNToxMS0wMDowMA5o7y8AAAAZdEVYdFNvZnR3YXJlAHd3dy5pbmtzY2FwZS5vcmeb7jwaAAAAAElFTkSuQmCC\";\nexport const svg = \"data:image/png;base64,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\";\nexport const png = \"data:image/png;base64,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\";\nexport const json = \"\";\nexport const copy = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAQAAABKfvVzAAAAAmJLR0QA/vCI/CkAAAAJcEhZcwAADdYAAA3WAZBveZwAAAAJdnBBZwAAABgAAAAYAHhMpaYAAAFdSURBVDjLzZO/TsJQFMZ/t1QsmthEjQkmLoZJA7ODq/EdHBx9BcTEmMjCxsA7+Ao+gFOdCImOuoAs/qtIldL2OECxLY1EJ88Zbu6933e+c/988MtQ8akotOQaQqAklSAaS5hkEgQfmzcVTImJEjPfoMNjIjv5hpiiEgqiyJLXLiVAEpWU0oJ9HpQHoEeaWWFZPpGbiy17QlK35vaBqBAXaWajzp3sYWFJUQzRx2lIEQtLNmVMGQ0ZzPYuXQQX6OON5EGgjxstHkrp8k4A8c1xpBJgAMAwhTBMJ7jT1X5WGP5nBQ1dvve1mQq1wjGEX02rFX5S8HPOh16pVOYjiAHNnIeXTuidtc/XnOv4ERa8ky42fkpL9dXyfTnLXAzf54UmvdBCCkB01hcPHZ0djHh15QVHdHBV5BYAfOzq06npXMXhhl995TkKnxhINEqUyE49WYtW3JxRx82w/x/jC67KmykWiVPXAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDE3LTExLTIwVDEwOjE1OjExLTAwOjAwfzVXkwAAACV0RVh0ZGF0ZTptb2RpZnkAMjAxNy0xMS0yMFQxMDoxNToxMS0wMDowMA5o7y8AAAAZdEVYdFNvZnR3YXJlAHd3dy5pbmtzY2FwZS5vcmeb7jwaAAAAAElFTkSuQmCC\";\nexport const group = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABmJLR0QA/gD+AP7rGNSCAAAACXBIWXMAAA3WAAAN1gGQb3mcAAAACXZwQWcAAAAYAAAAGAB4TKWmAAACQElEQVRIx9WUz2sTURDHPzMvIb3VgyJKW/DXSXoKtSJIbaxtgi3of+BfIYKXgOAfUCh6zFFR9Ca1tomXigf7P/SQqo2giIrNpvvGw+7GStIlG/HgLI8dHvPmOzPvw4P/3SRx1hurde/9bL8g7z1mhveGWeQj0liq3CgNrLS28cKy2JNnj2yQvLnE6XQ6AHz/8Q3vPd6HhMk/3CcMw2j5fU5NnCMI2gMV3hUIggCAdrDHy9U1zDzeopF4b5g3jJCZKzN/xA8h0Ga2NAMIZoYRz91b3JmP4ttZBeIDPgzZWK8DgghEgzbMADNKc6W/6yD0nqtzJUQEVY2FonXQ2lkFkgNOlXq9gYoiqqgIiCJETM+XF7oFrTxYtjNnT6ci3NOBc45yuYxTh3MOVYeqxt0QJYjjp6cuUSwWe6p++vzxbE8HiYCosv5qI0rqFKeOxeuLqHOICHbgkr98/czH1k4qwj2XLMD8wjWcy5FzDudyICDxZ/FdBEHAm81Nms1mKsI9HRw/djL10hyuGz81fYHJyfOpCHcFDNu8c/f2RUveHTMS38xcNPookXlPYWSErXdbtHZ3UxHuCtyr3r9crd4qbCcb27+rHp848XNp8SYfdndQVUSEkUKBsbFxRo+MpiKcO7Bv1Wptr99YVh4uUywWab4/SqPxGhVFnaPV+nQowv0EDrVOp4Oqks/nqVQqAyGcSWAYhLMJDIHwUB1kQTiTQBrC0RtkRAhH+7l87m1yVgYRAOQwhPtZrVZrk7z0/9p+AWdQwNFPdOB+AAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDA5LTEyLTAxVDAyOjIyOjM1KzAxOjAwqBTIawAAACV0RVh0ZGF0ZTptb2RpZnkAMjAwOS0xMi0wMVQwMjoyMjozNSswMTowMNlJcNcAAAAZdEVYdFNvZnR3YXJlAHd3dy5pbmtzY2FwZS5vcmeb7jwaAAAAE3RFWHRUaXRsZQBPcHRpY2FsIERyaXZlPme6DAAAAABJRU5ErkJggg==\";\nexport const ungroup = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3WAAAN1gGQb3mcAAAAB3RJTUUH5goLBzIP6fiS+gAAAoFJREFUSMfVVk1rE2EQft55EyKeFU0PlcR6koIa+0FBa2NtEmyL9uLBIoHi0YvFogghIIjoTbx4MldB8BRUTJNeqh7MwT+gPaSpKdjak2bTnfGw3SVhP5p4EFxYmJf5eGbmfXZmgf/9UbZQqrwtM/OElxEzQ0TALBCxZChVmclcSe4HEGoLMjEwv+AoYvV6oOOr1y87kvkajYotxzc2lAug1Wp1BPi5swWTGcwmTHMXpmlaL+8i1n8ChtHsqkUOgGEYHYpisQgWqyXMAmGBwMT4hXFP+64AYvU66o0aFICx08OOUbj6EcICZgYzW/ZNw7ct3gBNKyM2TSyXyjjfZrRcKkMEgAiSk8m/rwAATGZcnEyi/UZSqRSU6kyw2SuA7aCJUC5XQE8eQRGBlMLoqbMdTt8AzAF4k7uH4wNxiAiKLOJFYVcFWmuk02lo0tBag0jjx+07ntmNDI0hkUgEUtgFoIhQer8MIgJpgiaNMz7lb+9s4fvmeiCFXZesAEylLkHrEEJaQ+sQGj4AH1ZXUavVAinsquDI4b6u58zQyDAGB096UtgFIJDVu/eXRsWeOyKw5VuA9gKofq5is9EIpLAD8CD/8Fw+n42s7Z1zz9/9snUvbmYxM30VG411EBGUUjgQieD6fNYJdPBL1ZPCobaEJJ8v/LYPuWjUURztiyKRSKBWP4RKZQWkCKQ14m3OK+UVTKVT/hUEPa1WC0SEcDiMTCbjUHh7ccmxmZmdtb6BIAC/2fLYMMSTws+eYvryNEhr1PqPOXGMhRu9VRBEYShAoXOM9NyiXinsC+A3coMobK1RAa7N7e0NRkipT66dvN/ubqcw1oKNC4VCE4D8k7+KP78ve+ZyfaadAAAAAElFTkSuQmCC\";\nexport const move_to_top = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAB3RJTUUH5godFRotCxUC6QAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAAPfSURBVEjHtVS/TyNHGH27Ozv+sRj/CDYuQCJSdBRp6CkjLlWkFFGUUCJLSUkBhfMPUCJEQZciihwqpEsTiQasSBQnIaUgd2ALkC4sxpzDcuZ8O+udbzaF2cXEwF2QstLTzOx+s2/mfe/7tHL5h+DCceC6LgxDh5QSvpSQkiB9CQrXJCGlBEmCvF734m7e+f5N3LtOB2+v3oAFgUKhMIpM7iPkRvKQvoQkgiQCSQWp+uakQEpCSgW6jpFEIFK9A4VzUjiuv8Afz38H0zQNhmHA5ByxWByGIWFIgkEEYgRDKRhSgRiBUY/QkApECqyPhIUkSoGRgsnj0HUDzDCM128uHTiOA/uvV70bRBKEp7+RRRJBSgJRD354Yyl7e1Uv3vn7NXzPBQPwaYAAQRBAKdVDoG7mdyAI5xSuCUrRQBwC/P+PNj8//02tVoNt2/B9H57nodvtwvM8CCHgui5SqVQskUjUbdve6d+8tLQEAFq5XA5WVlYKZ2dnn6+vr8vp6Wk+NTX1cmFh4TlLJpO/WJaFoaEhSCnBOY+IOOfgnCOdTiORSDyzbfvLfoJyuQxcC9FsNr9utVqrnueh3W6j1Wr9trW19RWbnJxELBZDPp/vWe/a277vRxgZGUEqlcLe3t6dMqytra3t7u5+v7GxAcdxsL29Dc/zPhsfHz9i+Xz+qRACuq5DKRW5IySSUqJYLPJ0Ov3qPp3r9fonjuMgHo8jFovBNE0IIfjR0dEoq1arODw8RKPRABFF+ocQQiCVSiEej9+byEaj8asQ4m0ulwPn/AvG2C6Al81mM8Ysy9pMJpOwLAtEBNM0I3DOYZomMpkMksnkMwC3cjA7OwsAWqVSWQWwOjMzM3R1ddXUdX21Wq3+DACMMQZN0wa93lcXhmGAc37fBSK3CyGSjDENQBTMiOip53lwXRdKKXS73Vsyua4L13W5aZoDOahUKreZgkAL7R8RTExMQNM0FAqFyD39CZZSIp/PI5VKYWdn5z8XGmu325uXl5e4uLgYsKfv++h2uyAidDqdgRx8EMHJyQmOj49xenp6y0VCiGjMZDKwLOtRrYIJIb4NW0JIIIS4BcZYTClVfxTB8vLy+vuCzs/PAQBPnjzRAAS1Wu3DCRYXF/P7+/uwbRtEFDW78PSu6yKbzeqWZbm1Wq390M+CYLA/M03T/tQ0Df+Gruv9Y1bX9R8BfPcQgVJqkKBYLOY7nQ4Mw4hcFNZCiGubfnxwcPCgHGNjYzqABICor7BMJrOey+XQ7XajGghJwjoYHR0dGh4e3nyf3tls9h2AnwC8eJTlSqWSViqV7vw2Nzen3bX+BxxQD5I249kcAAAAAElFTkSuQmCC\";\nexport const move_to_bottom = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAB3RJTUUH5godFRgEe5H4BwAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAARuSURBVEjHtVRNaFRXFP7u+08mkxknYyxGU6QLEQwuko2LFkRw0UXAhWipWJql4LIEdCtuulfpYlZCbBdt0YKWLixIS2mLhVStEtJGOpSYZGbMOPPm3fvuOaeLyRsnpkY3PXC479537v3e+b77PYW+qFQqO0XkwdLS0s7V1dXrV69e/QCviNnZ2VPMPBfHMdI07aW1FlprRFGEYrEIr39To9EAM6NaraJarWK7ePjwIZgZnU4HWmsYY6C17qWIwPf9zQDtdhvMjHq9jpWVlW0BBgcHPWaG4zjwfR/GGPi+jzAMobUGM8N13c0ASikopeC6LlzX3RZgamqqxcytJEliIhJrLay1YGakaQrP85DL5TYDZCEieF2cOXPmJjPvSpJEAMBxHGQjEaFYLKJQKGwGEJHe4UqpbQFOnjw5yczntNZGay1aayRJ0tMiTVMQ0X938CZdDA8PH2Tm00mSIAgChGGIMAxhjIExBkQEpdRWgOzLX9dBoVCoE1HL87w4CAIxxiCKoh6AUgqe520V+U34B4BWq3WTiHbFcSwZNZkHjDFg5q0d9GvwOqCxsbFJZj4Xx7FJ01TSNIUxpmc413URRRG8SqWiZmZmBAAmJyfje/fuyQY9tv/A8+fPq0uXLvVQa7XaQWY+nTm5X1xjDESkS9HMzIxcu3ZteHV1VW7cuLGnVCo5Gy3mLly4MCgiOcdxmhcvXtT9gNVqtZ75oP8WZRRllHkb3H+aJMnHy8vL6/fv3y9Vq1UMDAy8v7i4uDQ+Pp6Loug0gK/6Ae7evXsTwC4A23LpAcDIyMg79Xrdb7Va5cePH6PRaMjQ0FBYLBZ3TkxMoFQqlV7eeOXKlUlmPpckibHWirUWRARmBhEhiqIXRisUCl/k8/nd+/fvP7CwsIC1tTVEUYTR0VHkcrnb5XJ5/mWAR48eHch80P83zdJxnK7It27dUocPH/7szp07T8Iw/LpWq0VBEKjx8XEcPXr0geM4x0+cOJFcvnxZnT17tkfH/Py8IaIe7y+ntbYrdMbhkSNHvp2bm5s6duzYrxMTE1Gz2by9b9++49PT00l2i/s7OHTokEtEaLfbm66ntRbGGARBgHw+jy12/eGn395d+uvPsmV//qMPpxdfJd4vv9eGvvum8l6z2bRaa7E2RWpT2NTCaI1CcRh794xBzc5+cmq9sQLdWVeA5fra02dkyfrh4IDnh3lrSawlWCIQEawlMLPTieOk8az+HHBAxCBLIOJunQD1RhPWAh4gc4HHCAYsIp+xI1fubiABMYPIhSUFYgdEbnedGFQI8NboMIjlxRoxLAmYBStrz/Dk72V4Qga7d3Tw9kgbe8sEKx5EXAg8MAIwPIg4EHgQuOCNFHHB4kFUVtsdRVyI8vDjz3/g8y+/h+e6PpqdAEtPA6y3GcQKxAAxg0VAbMGswALwxjsWgFiBGWBRvWeS7ihwsLD4D7RO4SnHu95KPDSbAWpNhqUX2d86sYCJkWbz3vpGrZXenBlYq69DmxT/e/wL/opRMma51lkAAAAASUVORK5CYII=\";\nexport const horizontal = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAAYCAYAAAARfGZ1AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAB3RJTUUH5godFR8VXmBOMgAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAAItSURBVEjH7ZS9SitBFMd/M9nZddeYysYnCKQQsbTwMRQEbS1TpEsl+BIWwcLGMpXahBSCrVpY+ggJWiyus9mZc4uwMblJ7kW44TYeGM58nPnPf84XrFDUw8PDeKIUSqmvg6n1Iv03252dHfQqmf+Afw9caz0TtLlMUAqt9ffAtdZEUUSlUiEMw6XAYRiitZ7oP4KXF2q1Gi8vL7TbbVnGLggC4jim2WzKzc2NGGMwxsz9VJfG1WoVgG63K5eXl/L+/g6AMYYwDGeGMYYgCNjY2KDT6XB6eiqvr6+EYUilUvkikSQJxhienp7o9/tirSVJEoIg4P7+Hu89IjLRIjIhk6Yp1WqV4XBIs9mUvb09Wq2WSpJk7I1er8fd3Z0Mh0OcczjnKIqCoijw3lMUxWRvWk/blXtZlqG15uTkhLOzM6XLL/4LERG01qyvr4+ZPz4+EkURz8/P9Ho9sdby9vaGtZbj42MlIgAz7jHGUKvVuLi4kMFggLWWNE3Z39+n1WqptbU1Go0GQZZljEYjtre3qdfr6vb2Vvr9PlmWsbu7i/d+rimVPr+6uiJNUzY3Nzk/P1eNRgPnHHmej+0AiqIgTVOiKOLg4EBtbW1xfX0t5VnJfjrVnHMMBgMODw85OjpSIjIBXdpyy8Kw1hLHMdbameKZLrSPjw/iOMY5N0dgYcv13vP5+YnWmjzPJ5d+D1ye5xhjyPMc7/3CAC9Nk2lfL8uMRQ//9PP/C75S+QX3zx/c9r2O6AAAAABJRU5ErkJggg==\";\nexport const vertical = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAXCAYAAAARIY8tAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAB3RJTUUH5godFR8FQ9deVgAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAAJgSURBVEjHtZW9TutAEIW/2V175QSQIvESUIUiEhQ0gISAJ0C8AM/AA1AlbwANBQUtDRIFEgWiTIEoqCkoKAIyRrZ37Vs5yr0Xx7k/jORmd2fPnOOZs/DNIQDD4bDxYBiGXFxclO12m729PcmyrDGn2+1iZqlCa02SJJydnaGUYnNzkyAI8N435iqAsixrvwpgMBiURVGQ5zmDwaDUWjNLrmqqwBjD09MTd3d3RFFEq9Xi9vaWx8dHjDH/xkBEEBH6/X7ZarXQWqO1Zm5ujn6/X1b7jQzqDmituby8LF9eXrDWYozBGIO1ltfXV87Pz0ut9d9JpJSiKAqurq5YWlqi0+mMARYXF1leXubm5obPz0+Uqle6VsSKwenpqRhjuL6+5uTkpAQ4PDyUXq+H954kSZjWsqa67CuANE3x3hMEAXEcU3XO+/s7cRzjnMM592V+I0C1XlXnnBsD5HmOc45Zhs3MPPIi47acpvkfMZhkIiJjBpOt+d8YKKW+h0F12SSDSVZNTMw0zcMwRER+YyAiKKUIwxCALMsoiqLeru/v77+sXGvN0dFRORqNmJ+fZ2FhAYDRaMTHxwftdpvj42OphvLXWF1drbcK7z0iwsHBgURRRBiGP1lFFEXs7++LtRbvfa1VTP3JeZ7T6/V4fn7m4eFhvN7pdFhbW2N9fZ23t7dmN62LoihIkoTt7W2x1o7d1FrL7u6uJElSq/3MD06WZYRhyMbGhlQAW1tbYq0lTdPGB6exTcuyJEkSVlZWGA6HGGPodrvEcdxY/cyD5pwjz3N2dnYkCALSNMU5N9Og/QC/FsDpo71BjQAAAABJRU5ErkJggg==\";\nexport const to_path = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAB3RJTUUH5gsEBhoGqbjXJQAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAAH3SURBVDjLhZGxSxthGMZ/392l+b6E4IUQjENRQulWKXUwcwJZ8idk0D2IiIMdm03o0MnJ1aXQRSHF+AcEkiWEQFECwSXoZsPlcrnz9OsQsbWk12d83/f78T3PIzzPYzab0Ww2db/fx3EcTk4+cX+/hGEYSKm5vPSFlCyUcByHo6MjnclkKBaLIp1Os7xs662t72xufmB3d4Xr65lIpRYDrFarpaWUVKtVIYQAwDAEGxtvGY1+IMQKUbK63S7lcvn5MYBSmoODN/j+6/mR9W+AMR6PyWazL4bDoS+urgKxvV1nOPwplIoAJBIJJpPJi6FSYNuaVCrENP1IC0Y+n6ff7+tFS9M0CcMwOoNisShWV20dBFIDJJNwezsTlgUPDw9YUQEAhm3bBIGkVvvK4WGLIADHcQEIw/C/AOF5HkpJ3Wg4DAYD9vffU6t9ZDq9e8pD8WdDAFJK1tbWqFQqQnieRy4n9Xg8X6ZScHMzE6YJe3t7ul6vi1gs9gLgui69Xk+3220smHte9L1YLIZlWai/elRKUSqVRKPR0JEGk8kkruuSSCSeMoFcTmp3HhHx+BeMKEA+n2cwGDxX/PgIQQCnp3fs7HzD9+PRgEKhwPn5OaPR6Nm71pqLiybr6+9+txClTqejz87OmE6nmOYrjo8/4/vzUJeW4BekTMTiOlyMpQAAAABJRU5ErkJggg==\";\nexport const to_shapes = \"data:image/png;base64,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\";\nexport const base64_export = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAKzSURBVEiJtZTbbtpAEIa/9XqdcAEXEQoHoQhkBVXKde7yEH2Kvg9v0su+CFKFAnYSSDlUqQISyBh7etOlNnbP6kgje9fjmf//Z2eViPA/zc0ulFJngPePOfciEh1XIoKIMBwO322321kcx/Ivvt1uZ8Ph8J3Nq0QEpVRls9mMtdatNE2zjH4LclZmx3FIkuRTtVr1RWRnJTrzPK+13++PSZ+fn5nNZtRqNdbrNa1Wi06nA0Acx4xGIxaLBXd3d3jed1WTJMHzvBZwBuwcC9ZSsj4ej7m5uaHf72OMYTweH5EaY/B9P4f89H9AAeQKWPRKKaIowvM8FosFzWaTJElIkqSQ8FROpVRpAecUgfX5fM7l5WXpt5+5zW17oE4RiQgvLy/UarWCBD+Q5PRZlCgbYIwhDEPa7Ta2+Y7j/Ap1oQc5BlnzfZ+Hhwcmkwnr9Rrf91FKsdvtCMOQw+GAiDAajdBa0+12qVQqBQa2uc31ev0pSZLc2f+bORARtNbUarWWiMwtAydN08Kp+JN7KivRt2H9cZOVUhwOB+7v71kul9ze3nJ+fn5MtlqtmE6nVKtVNpsN7XabRqPx6znImtaaXq9XyiIMQ/r9Pr7vo7UmCIIyNvkCVqLf8f1+j+u6LJdLGo0GURTlvn+T6O8LWF+tVlxcXBT2swWOTS6Touyc2/3X11eq1WppXHaSjwxKNCy8W3Ndl+l0SrPZJI5jjDFlceWDJiJEUcTT0xNWtslkgtaaTqdDpVLh6uqKx8dHgiBgs9nQ7XbLroxcgTQIgs+9Xq8O4Hkevu8DcH19nYOVpin1ep16vV7YtxYEwWfg+zAA88Fg8CEMwy+O46C1xnVdXNfFGIMxBs/zcm73bZzWGsdxCMPwy2Aw+ADMc9IopW6At8CbTOE/tRT4CLwXkWGuwP+yr0z0vLd4EzkyAAAAAElFTkSuQmCC\";\nexport const zoom_in = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAQAAABKfvVzAAAAAmJLR0QA/vCI/CkAAAAJcEhZcwAADdYAAA3WAZBveZwAAAAJdnBBZwAAABgAAAAYAHhMpaYAAAIPSURBVDjLtZLLTxNRFMa/O52ZPsYqtCQgI6WhQCRBCwm+GqguTBOJIXHpxoV7+QOIJYgSEg0mdmliAltNSGShCza2IiEQqcuKGmamWF4akxbL9HlctKClBbvQb3Vzc37nfOcB/G+xgx/EgQEglq8CIANEWGABkEQSaZY7shiJJLvGhRAUKEKodZxkEo8MH/UKQai2oGfKM2ULQhWCo95yhO07bzBNks3/6m4UOwCOPWi630/xrds10YrGyNzhx/LYMHWF3VCghN3UNebHcts9MpdGcsX8ktoqR4YWkLCLUKHaRSSGFuWI1g4rcX8CfNGYOWVtWcE3bhp5bAPNT8HNDrZosU6YSifJ7z9SG7sArQPIArQJ1OQ2daN+0HwBIOgnVa0Z7MPrjHDOAyy9EbMdedVRr0EHlfXA8ti5pqbsFy67ZxwhpJF2hM6+7LuYsp//hETpzvcspZ4szDuXfL2ZuTmaB5Dpvb7ow1b310NPg4wfbwz0rHSLP2s14IcjLUFD1rn69vmpNaZXAAA6kbkacD2TlXqgff1WzKdPShM9vDDxcPD9b6T0+Hi0wYVaANtQ8D13ptMbaeTrHj+6E2Zl89qDODKQobAsMq3ddPoR4F8ELpGxQoUK+PGNgb6mz3V84+zIlS8sWxzr4WLxhpl30dMxbjUpVVUBAMi625+3SNOIM/p7dAERyURVpP43+gWF+ca8/eA5yQAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAxNy0xMS0yMFQxMDoxNToxMS0wMDowMH81V5MAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMTctMTEtMjBUMTA6MTU6MTEtMDA6MDAOaO8vAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAAABJRU5ErkJggg==\";\nexport const zoom_out = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAQAAABKfvVzAAAAAmJLR0QA/vCI/CkAAAAJcEhZcwAADdYAAA3WAZBveZwAAAAJdnBBZwAAABgAAAAYAHhMpaYAAAH1SURBVDjLtZLNaxNRFMXPm7yZfBGtMWhM/AjEig12UailsRhciJ9Q7MKFmy6617/AAa2VglLBbAShEBdFUFAQBMFVKhZRW3faiNJkWpNSESS16SRtclzEJqaJMQt9y/vO797DPRf4309sLlCBAEBRagGgBRoccADIIYeCKDYdRo3+4Kg6iSSS6uT+UfqpNZUPR9Q4Uu54X6wv5o4jpcaHI/WIqDj32mJ0X36qv8ciAO+10MhZZpeG2uYbGqO9Q8fMdZ0hSgoKSoZGdMy0X6W9kVyhx3HPN8FeykpNstc3Yb3PHVR+18pfxux5VzCBWZGoen0WDhqZTthqN1npKPMZE8SH6leR6VWrudlNGSDMXSljH1y8i43AFFgHAl4DJlgHiBJ/nE7d6eg5/3ocKygBUOA8PFTY3vMGy7WZb1jK3341FXh78sja1GMsA3CFz02fwlLXlz+eBq2Jgf7uj13aSpsBfN9bcMLAemDuxYPdC8JsAADcunY8Ghz3J3cCBzKD6RNmzDnWLdWxG5emq0jt8Um0I4htAL4iiW/FzkORWZ/03Lp58Z2o21c1RAst5bBoW7gQ0BGVD6NhWhtMaIBvWew/uueTR/qeXzn2WawDSnNAZL1PXs4fTCtzOWdLEwCArtUzJYfzEbKCf1eXEY02ttD637yfWKq5q2bQBKcAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTctMTEtMjBUMTA6MTU6MTEtMDA6MDB/NVeTAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE3LTExLTIwVDEwOjE1OjExLTAwOjAwDmjvLwAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAASUVORK5CYII=\";\nexport const reset_zoom = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAQAAABKfvVzAAAAAmJLR0QA/vCI/CkAAAAJcEhZcwAADdYAAA3WAZBveZwAAAAJdnBBZwAAABgAAAAYAHhMpaYAAAIBSURBVDjLtZLLaxNRFMa/O5lXZhi1aag1sRocUxSsUKjFhhpciI8uCoIupODCvf4FxketFJQKZq3QLIqg4ELQjZtO1eLC1o2L1gdNZmoqFSmkNZ1ckxwXCW3TjDULPZsDl+93z8f5DvC/i21+IAEMALFyAwD5IEODBiCPPDgrbTmMZAqbw9IE0khLE/uHKUzylvLBuGQhE7BiqVgqYCEjWYPxeoStOW9VRymQeHHVwQoY9KG2W32UW7y0w/E0Rv6DCUzfvka9HdfhwKF2OjyUwHT0Jvm95AIFtVRojHooig8YxzjtI4WOhsaUR9RCwkatUDXmLximjVks8wfg4ADKmDFtbkCt3eQaLRYWXJSwJD2vAgBlVxV3s5sKQHB3Zey9MACUqoAAw4m02HBBdQArY+VMhjd3n4cGERwcIrQj53hz9ycs12YuVnvh/tvJyLtTvcXXFk0CUGMDU6ex2Pn1j6dByuzZ/q6PnfLPJhtY2sN12ChG5l493j3PXA8AoO2/TiTNh+H0TqB94WL2pDuqj3SJ0sidK1PrSO3xiYjCRBOA70jjR6njUHwmJAbv3b38ntXtaz1EH/kqYZE6fyGSQFJ8kuwhxWOCB77tW/+xts9BMfTyxvEvrLghOO9iudZnb5wDWWEurzc0AQDIWO0ra/pT5Bj9XV1BZFKpga//Tf0Gp9/DBQB2y1wAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTctMTEtMjBUMTA6MTU6MTEtMDA6MDB/NVeTAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE3LTExLTIwVDEwOjE1OjExLTAwOjAwDmjvLwAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAASUVORK5CYII=\";\n","import {Menus} from \"../../context_menu/src/index.js\";\nimport {del,horizontal,vertical} from \"../../assets/graphics.js\";\nimport EventsManager from \"../events/EventsManager.js\";\nimport {PointEvents, PointMoveDirections} from \"./SmartPoint.js\";\n\n/**\n * Helper class that used to manage SmartPoint context menu\n * that appear on right mouse click\n * Should not be instantiated directly. SmartPoint automatically calls it\n * when needed\n * @param point {SmartPoint} The point object to manage menu for\n * @constructor\n */\nexport default function SmartPointContextMenu(point) {\n    /**\n     * The point object to manage menu for\n     * @type {SmartPoint}\n     */\n    this.point = point;\n\n    /**\n     * @ignore\n     * Context menu object instance\n     * @type {object}\n     */\n    this.contextMenu = null;\n\n    /**\n     * @ignore\n     * Method executed to check if context menu should be initialized\n     * or destroyed depending on options of the point\n     */\n    this.updateContextMenu = () => {\n        if (this.contextMenu) {\n            this.contextMenu.destroy();\n            this.contextMenu = null;\n        }\n        this.initMenu();\n        this.point.contextMenu = this.contextMenu;\n    }\n\n    /**\n     * @ignore\n     * Initializes context menu. Creates context menu and binds event\n     * listeners to it\n     */\n    this.initMenu = () => {\n        if (this.point.element) {\n            this.contextMenu = Menus.create([\n                {\n                    id: \"i\" + this.point.guid + \"_drag_horizontal\",\n                    title: this.point.dragHorizontal ? \"Disable move horizontally\" : \"Enable move horizontally\",\n                    image: horizontal\n                },\n                {\n                    id: \"i\" + this.point.guid + \"_drag_vertical\",\n                    title: this.point.dragVertical ? \"Disable move vertically\" : \"Enable move vertically\",\n                    image: vertical\n                }\n            ], this.point.element);\n            if (this.point.options.canDelete) {\n                this.contextMenu.addItem(\"i\" + this.point.guid + \"_delete\", \"Delete point\", del);\n            }\n            this._setEventListeners();\n        }\n    }\n\n    /**\n     * @ignore\n     * Method used to set up handler functions for context menu items\n     */\n    this._setEventListeners = () => {\n        this.contextMenu.on(\"click\",(event) => {\n            switch (event.itemId) {\n                case \"i\"+point.guid+\"_delete\":\n                    EventsManager.emit(PointEvents.POINT_DELETE_REQUEST,this.point);\n                    break;\n                case \"i\"+point.guid+\"_drag_horizontal\":\n                    this.onDragHorizontalClick(event)\n                    break;\n                case \"i\"+point.guid+\"_drag_vertical\":\n                    this.onDragVerticalClick(event)\n                    break;\n            }\n        })\n    }\n\n    /**\n     * @ignore\n     * Method runs when select \"Move horizontally\" from point context menu\n     * @param _event\n     */\n    this.onDragHorizontalClick = (_event) => {\n        this.point.dragHorizontal = !this.point.dragHorizontal;\n        if (this.point.dragHorizontal) {\n            this.point.dragVertical = false;\n        }\n        this.updatePointDragMode();\n    }\n\n    /**\n     * @ignore\n     * Method runs when select \"Move vertically\" from point context menu\n     * @param _event\n     */\n    this.onDragVerticalClick = (_event) => {\n        this.point.dragVertical = !this.point.dragVertical;\n        if (this.point.dragVertical) {\n            this.point.dragHorizontal = false;\n        }\n        this.updatePointDragMode();\n    }\n\n    /**\n     * @ignore\n     * Method updates point movement directions depending on context menu setup\n     */\n    this.updatePointDragMode = () => {\n        this.contextMenu.items.find(item=>item.id===\"i\"+this.point.guid+\"_drag_horizontal\").title = \"Enable move horizontally\";\n        this.contextMenu.items.find(item=>item.id===\"i\"+this.point.guid+\"_drag_vertical\").title = \"Enable move vertically\";\n        if (this.point.dragHorizontal) {\n            this.point.setOptions({moveDirections:[PointMoveDirections.LEFT,PointMoveDirections.RIGHT]})\n            this.contextMenu.items.find(item=>item.id===\"i\"+this.point.guid+\"_drag_horizontal\").title = \"Disable move horizontally\";\n        } else if (this.point.dragVertical) {\n            this.point.setOptions({moveDirections:[PointMoveDirections.TOP,PointMoveDirections.BOTTOM]})\n            this.contextMenu.items.find(item=>item.id===\"i\"+this.point.guid+\"_drag_vertical\").title = \"Disable move vertically\";\n        } else {\n            this.point.setOptions({moveDirections:\n                [PointMoveDirections.TOP,PointMoveDirections.BOTTOM,PointMoveDirections.LEFT,PointMoveDirections.RIGHT]}\n            )\n        }\n    }\n\n}\n","import SmartShapeManager,{ContainerEvents} from \"../SmartShapeManager/SmartShapeManager.js\";\nimport {\n    CSStoJsStyleName, distance,\n    getOffset,\n    getRotatedCoords,\n    mergeObjects,\n    notNull,\n    pauseEvent,\n    readJSON,\n    uuid\n} from \"../utils\";\nimport EventsManager from \"../events/EventsManager.js\";\nimport {createEvent} from \"../events/functions.js\";\nimport SmartPointContextMenu from \"./SmartPointContextMenu.js\";\n\n/**\n * Class that represents a single point on the screen.\n * Can be created directly using class constructor, but more often they added by using `addPoint`, `addPoints`\n * methods of [SmartShape](#SmartShape) class or interactively using SmartShape context menu.\n * @returns {object} SmartPoint object that should be initialized by `init` method.\n * @constructor\n */\nfunction SmartPoint() {\n    /**\n     * Point HTML element options. Defines look and behavior of point. Has the following parameters.\n     * @param id {string} Id of point HTML element. Default empty.\n     * @param width {number} Width of point in pixels. Default: `10`.\n     * @param height {number} Height of point in pixels. Default `10`.\n     * @param classes {string} CSS class or classes of point, delimited by comma. Default empty.\n     * @param style {object} CSS styles, that override classes. Must be provided as an object. Default see in code.\n     * (The same as [\"style\" HTML attribute](https://www.w3schools.com/jsref/prop_html_style.asp))\n     * @param canDrag {boolean} Is it allowed to drag this point by mouse to change it positions. Default `true`\n     * @param canDelete {boolean} Is it allowed to delete this point by right mouse click. Default `true`.\n     * @param zIndex {number} Order of element in a stack of HTML elements\n     * (https://www.w3schools.com/cssref/pr_pos_z-index.asp). Elements if higher z-index value placed on top.\n     * @param bounds {object} Bounds for point movement. If setup, then it's impossible to drag point beyond\n     * bounds. It must be an object of the following format: `{left:number,top:number,right:number,bottom:number}`.\n     * If created using `SmartShape`, then it automatically set this object to the dimensions of shape's container.\n     * @param moveDirections {array}. Defines in which directions point can move. Can contain\n     * values from [PointMoveDirections](#PointMoveDirections) enumeration. By default, all directions allowed. Default\n     * value is:\n     * `[PointMoveDirections.LEFT,PointMoveDirections.TOP,PointMoveDirections.RIGHT, PointMoveDirections.BOTTOM]`.\n     * To restrict movement in any direction, need to remove some directions from this array.\n     * @param visible {boolean} Point is visible or not. By default, `true`.\n     * @param forceDisplay {boolean} If this option enabled, than this point displayed all the time, even if shape\n     * is not in SCALE or ROTATE mode. By default, if the shape is in DEFAULT mode, then points not displayed on it.\n     * @param createDOMElement {boolean} Should HTML element for this point created by default. \"false\" by default\n     * @type {{}}\n     */\n    this.options = {\n        id:\"\",\n        width:10,\n        height:10,\n        classes: \"\",\n        style: {\n            \"border-width\":\"1px\",\n            \"border-style\":\"solid\",\n            \"border-color\":\"black\",\n            \"border-radius\": \"25px\",\n            \"cursor\":'pointer',\n            \"background-color\": \"red\",\n        },\n        canDrag: true,\n        canDelete: false,\n        zIndex:1000,\n        bounds:{},\n        moveDirections: [\n            PointMoveDirections.LEFT,\n            PointMoveDirections.TOP,\n            PointMoveDirections.RIGHT,\n            PointMoveDirections.BOTTOM\n        ],\n        visible: true,\n        hidden:false,\n        forceDisplay: false,\n        createDOMElement:false\n    };\n\n    /**\n     * X coordinate of point, relative to a corner of shape's container\n     * @type {number}\n     */\n    this.x = 0;\n\n    /**\n     * Y coordinate of point, relative to a corner of shape's container\n     * @type {number}\n     */\n    this.y = 0;\n\n    /**\n     * HTML DOM node of element, which used to display the point. This is styled DIV element.\n     * @type {HTMLElement}\n     */\n    this.element = null;\n\n    /**\n     * Internal global unique identifier of point. Generated automatically.\n     * @type {string}\n     */\n    this.guid = uuid();\n\n    /**\n     * @ignore\n     * List of subscribers, that subscribed to events, emitted by\n     * this point. This is an object, that consists of array\n     * of event handlers of each event. Each handler is a function\n     * that called when event of specified type emitted by\n     * this shape\n     * @type {object}\n     */\n    this.subscriptions = {}\n\n\n    /**\n     * @ignore\n     * Drag horizontal mode. If enabled, then point can be\n     * dragged only horizontally using UI\n     * @type {boolean}\n     */\n    this.dragHorizontal = false;\n\n    /**\n     * @ignore\n     * Drag vertical mode. If enabled, then point can be\n     * dragged only vertically using UI\n     * @type {boolean}\n     */\n    this.dragVertical = false;\n\n    /**\n     * Initializes new point and displays it on the screen.\n     * @param x {number} X coordinate of point relative to shape's container left\n     * @param y {number} Y coordinate of point relative to shape's container top\n     * @param options {object} Point options, described [above](#SmartPoint+options). If not specified,\n     * then [SmartShape.options.pointOptions](#SmartShape+options) used or global default options for point.\n     * @returns {object} constructed SmartPoint object\n     */\n    this.init = (x,y,options = null) => {\n        this.x = parseInt(x);\n        this.y = parseInt(y);\n        this.setOptions(mergeObjects({},options));\n        this.setEventListeners();\n        EventsManager.emit(PointEvents.POINT_ADDED,this);\n        return this;\n    }\n\n    /**\n     * Method used to set specified options to point.\n     * @param options {object} Point options object, described [above](#SmartPoint+options).\n     */\n    this.setOptions = (options) => {\n        if (options && typeof(options) === \"object\") {\n            if (notNull(options.moveDirections) && typeof(options.moveDirections) === \"object\") {\n                this.options.moveDirections = [];\n            }\n            this.options = mergeObjects(this.options,options);\n        }\n        Object.assign(this, new SmartPointContextMenu(this));\n        if (!this.element) {\n            if ((this.options.createDOMElement && this.options.canDrag) || this.options.forceDisplay) {\n                this.element = this.createPointUI();\n                this.setDOMEventListeners();\n                this.updateContextMenu();\n                EventsManager.emit(PointEvents.POINT_ADDED,this);\n            }\n        } else {\n            if ((!this.options.createDOMElement || !this.options.canDrag) && !this.options.forceDisplay) {\n                try {\n                    this.element.parentNode.removeChild(this.element);\n                    this.element = null;\n                } catch {}\n            }\n        }\n        if (this.options.id && this.element) {\n            this.element.id = this.options.id;\n        }\n    }\n\n    /**\n     * @ignore\n     * Internal method that constructs HTML element of point, applies current options to it\n     * @returns {object} HTML element of points\n     */\n    this.createPointUI = () => {\n        const element = document.createElement(\"div\")\n        if (!this.options.canDrag) {\n            return element;\n        }\n        return this.setPointStyles(element);\n    }\n\n    /**\n     * @ignore\n     * Internal method that applies styles from `options` to point's HTML element and returns modified element\n     * @param element {HTMLDivElement} Input HTML element\n     * @returns {HTMLDivElement} HTML element with applied styles\n     */\n    this.setPointStyles = (element=null) => {\n        if (!this.element) {\n            this.element = document.createElement(\"div\");\n            this.setDOMEventListeners();\n            Object.assign(this,new SmartPointContextMenu(this));\n        }\n        if (element == null) {\n            element = this.element;\n        }\n        if (this.options.id) {\n            this.element.id = this.options.id;\n            element.id = this.options.id\n        }\n        element.className = this.options.classes;\n\n        element.style = this.options.style;\n        if (typeof(this.options.style) === \"object\") {\n            for (let cssName in this.options.style) {\n                element.style[CSStoJsStyleName(cssName)] = this.options.style[cssName]\n            }\n        }\n        element.style.width = this.options.width+\"px\";\n        element.style.height = this.options.height+\"px\";\n        element.style.left = (this.x-parseInt(this.options.width/2))+\"px\";\n        element.style.top = (this.y-parseInt(this.options.height/2))+\"px\";\n        element.style.zIndex = this.options.zIndex;\n        if (!this.options.canDrag || !this.options.visible || this.options.hidden) {\n            element.style.display = 'none';\n        } else {\n            element.style.display = '';\n        }\n        element.style.position = 'absolute';\n        return element\n    }\n\n    /**\n     * Method used to redraw the point. Usually used after change point position on the screen.\n     */\n    this.redraw = () => {\n        if ((this.options.canDrag && this.options.createDOMElement) || this.options.forceDisplay) {\n            this.element = this.setPointStyles();\n        }\n    }\n\n    /**\n     * Method used to display point if it has hidden\n     */\n    this.show = () => {\n        this.setOptions({visible:true});\n        this.redraw();\n    }\n\n    /**\n     * Method used to hide point\n     */\n    this.hide = () => {\n        this.setOptions({visible:false});\n        this.redraw();\n    }\n\n    /**\n     * @ignore\n     * Method used to rotate this point by specified angle around specified center\n     * @param angle {number} Angle in degrees\n     * @param centerX {number} X coordinate of center\n     * @param centerY {number} Y coordinate of center\n     */\n    this.rotateBy = (angle,centerX,centerY) => {\n        const [x,y] = getRotatedCoords(angle, this.x,this.y, centerX,centerY);\n        this.x = x;\n        this.y = y;\n    }\n\n    /**\n     * @ignore\n     * Internal method used to attach HTML event listeners to point.\n     */\n    this.setEventListeners = () => {\n        EventsManager.subscribe(ContainerEvents.CONTAINER_BOUNDS_CHANGED,this.onBoundsChange);\n    }\n\n    this.setDOMEventListeners = () => {\n        if (!this.element) {\n            return\n        }\n        this.element.addEventListener(\"mouseup\",this.mouseup);\n        this.element.addEventListener(\"mousedown\", this.mousedown);\n        this.element.addEventListener(\"mouseover\", this.mouseover);\n        this.element.addEventListener(\"mouseout\", this.mouseout);\n        this.element.addEventListener(\"click\", this.click);\n        this.element.addEventListener(\"dblclick\", this.doubleclick);\n        this.element.addEventListener(\"mousemove\", this.mousemove);\n    }\n\n    /**\n     * @ignore\n     * onMouseDown event handler, triggered when user press mouse button on point's DIV element.\n     * @param event {MouseEvent} Event object\n     */\n    this.mousedown = (event) => {\n        EventsManager.emit(PointEvents.POINT_MOUSE_DOWN,this,createEvent(event));\n        if (event.buttons === 1 && this.options.canDrag) {\n            EventsManager.emit(PointEvents.POINT_DRAG_START,this,createEvent(event));\n            pauseEvent(event);\n        }\n    }\n\n    /**\n     * @ignore\n     * onMouseMove event handler, triggered when user moves mouse over point's DIV element.\n     * @param event {MouseEvent} Event object\n     */\n    this.mousemove = (event) => {\n        EventsManager.emit(PointEvents.POINT_MOUSE_MOVE,this,createEvent(event))\n        if (event.buttons !== 1 || !this.options.canDrag || !SmartShapeManager.draggedShape ||\n            SmartShapeManager.draggedShape.draggedPoint !== this) {\n            return\n        }\n        const oldX = this.x;\n        const oldY = this.y;\n        const offset = getOffset(this.element.parentNode,true);\n        if (!this.checkFitBounds(this.x + event.movementX, this.y + event.movementY)) {\n            EventsManager.emit(PointEvents.POINT_DRAG_MOVE,this,createEvent(event,{oldX,oldY}));\n            return;\n        }\n        let newX = event.clientX + window.scrollX - offset.left - this.options.width/2;\n        let newY = event.clientY + window.scrollY - offset.top - this.options.height/2;\n        [newX,newY] = this.applyMoveRestrictions(newX,newY,oldX,oldY);\n        this.x = newX;\n        this.y = newY;\n        this.element.style.left = (this.x)+\"px\";\n        this.element.style.top = (this.y)+\"px\";\n        EventsManager.emit(PointEvents.POINT_DRAG_MOVE,this, createEvent(event,{oldX,oldY}));\n    }\n\n    /**\n     * @ignore\n     * onMouseOver event handler, triggered when mouse cursor enters point's DIV element.\n     * @param event {MouseEvent} Event object\n     */\n    this.mouseover = (event) => {\n        EventsManager.emit(PointEvents.POINT_MOUSE_OVER,this,createEvent(event));\n    }\n\n    /**\n     * @ignore\n     * onMouseOut event handler, triggered when mouse cursor leaves point's DIV element.\n     * @param event {MouseEvent} Event object\n     */\n    this.mouseout = (event) => {\n        EventsManager.emit(PointEvents.POINT_MOUSE_OUT,this,createEvent(event));\n    }\n\n    /**\n     * @ignore\n     * onClick event handler, triggered when user clicks on point's DIV element.\n     * @param event {MouseEvent} Event object\n     */\n    this.click = (event) => {\n        EventsManager.emit(PointEvents.POINT_MOUSE_CLICK,this,createEvent(event));\n    }\n\n    /**\n     * @ignore\n     * onClick event handler, triggered when user double-clicks on point's DIV element.\n     * @param event {MouseEvent} Event object\n     */\n    this.doubleclick = (event) => {\n        EventsManager.emit(PointEvents.POINT_MOUSE_DOUBLE_CLICK,this,createEvent(event));\n    }\n\n    /**\n     * @ignore\n     * Method checks if specified coordinate does not go beyond bounds\n     * @param x {number} X coordinate\n     * @param y {number} Y coordinate\n     * @returns {boolean} True if x,y fit bounds and false if not\n     */\n    this.checkFitBounds = (x,y) => {\n        return !(this.options.bounds.left !== -1 && x < this.options.bounds.left ||\n            this.options.bounds.right !== -1 && x > this.options.bounds.right ||\n            this.options.bounds.top !== -1 && y < this.options.bounds.top ||\n            this.options.bounds.bottom !== -1 && y > this.options.bounds.bottom);\n    }\n\n    /**\n     * @ignore\n     * Method that check movement restrictions based on directions, to which point moved\n     * from old position to new. Returns new coordinates, after apply movement restrictions\n     * @param newX - X after move\n     * @param newY - Y after move\n     * @param oldX - X before move\n     * @param oldY - Y before move\n     * @returns {array} [x,y] array of coordinates after check movement restrictions\n     */\n    this.applyMoveRestrictions = (newX,newY,oldX,oldY) => {\n        if (newY>oldY && this.options.moveDirections.indexOf(PointMoveDirections.BOTTOM) === -1) {\n            newY = oldY;\n        }\n        if (newY<oldY && this.options.moveDirections.indexOf(PointMoveDirections.TOP) === -1) {\n            newY = oldY;\n        }\n        if (newX>oldX && this.options.moveDirections.indexOf(PointMoveDirections.RIGHT) === -1) {\n            newX = oldX;\n        }\n        if (newX<oldX && this.options.moveDirections.indexOf(PointMoveDirections.LEFT) === -1) {\n            newX = oldX;\n        }\n        if (newX>this.options.bounds.right && this.options.bounds.right !== -1) {\n            newX = this.options.bounds.right;\n        }\n        if (newY>this.options.bounds.bottom && this.options.bounds.bottom !== -1) {\n            newY = this.options.bounds.bottom;\n        }\n        if (newX<this.options.bounds.left && this.options.bounds.left !== -1) {\n            newX = this.options.bounds.left;\n        }\n        if (newY<this.options.bounds.top && this.options.bounds.top !== -1) {\n            newY = this.options.bounds.top;\n        }\n        return [newX,newY];\n    }\n\n    /**\n     * @ignore\n     * onMouseUp event handler, triggered when user releases mouse button on point DIV element.\n     * @param event {MouseEvent} Event object\n     */\n    this.mouseup = (event) => {\n        EventsManager.emit(PointEvents.POINT_MOUSE_UP, this, createEvent(event));\n        if (event.button !==2) {\n            EventsManager.emit(PointEvents.POINT_DRAG_END,this, createEvent(event));\n        }\n    }\n\n    /**\n     * @ignore\n     * The handler, that reacts on container dimensions change event.\n     * @param event - custom event object, which contains new bounds in `event.bounds` field\n     * and array of points, which this change could affect in `event.points` field.\n     */\n    this.onBoundsChange = (event) => {\n        if (event.points.find(item => item === this)) {\n            this.options.bounds = event.bounds;\n        }\n    }\n\n    /**\n     * Method used to serialize point to JSON string\n     * @returns {string} JSON string with serialized point object\n     */\n    this.toJSON = () => {\n        return JSON.stringify(this.getJSON());\n    }\n\n    /**\n     * @ignore\n     * Internal method returns point as a JSON object\n     * @returns {object} JSON object with point parameters\n     */\n    this.getJSON = () => {\n        return {\n            x: this.x,\n            y: this.y,\n            options: mergeObjects({},this.options),\n        }\n    }\n\n    /**\n     * Method used to construct point object from JSON string representation,\n     * received by using `toJSON()` method.\n     * @param json {string} JSON-serialized point object as an object or as a string\n     * @returns {SmartPoint} constructed point or null in case of error\n     */\n    this.fromJSON = (json) => {\n        let jsonObj = json;\n        if (typeof(jsonObj) === \"string\") {\n            jsonObj = readJSON(json);\n        }\n        if (!jsonObj) {\n            return null;\n        }\n        this.x = jsonObj.x;\n        this.y = jsonObj.y;\n        let isNew = false;\n        if (!this.element) {\n            isNew = true;\n            this.element = document.createElement(\"div\");\n        }\n        this.setOptions(jsonObj.options);\n        if (isNew) {\n            EventsManager.emit(PointEvents.POINT_ADDED,this);\n        }\n        return this;\n    }\n\n    /**\n     * Method used to destroy the point. Removes event listeners from point element and\n     * raises the `point_destroyed` event. This event then intercepted by owner shape. Then owner shape\n     * removes this point from shape's points array.\n     */\n    this.destroy = () => {\n        if (this.element) {\n            this.element.removeEventListener(\"mouseup\", this.mouseup);\n            this.element.removeEventListener(\"mousedown\", this.mousedown);\n            this.element.removeEventListener(\"mouseover\", this.mouseover);\n            this.element.removeEventListener(\"mouseout\", this.mouseout);\n            this.element.removeEventListener(\"click\", this.click);\n            this.element.removeEventListener(\"dblclick\", this.doubleclick);\n            this.element.removeEventListener(\"mousemove\", this.mousemove);\n        }\n        EventsManager.unsubscribe(ContainerEvents.CONTAINER_BOUNDS_CHANGED,this.onBoundsChange);\n        EventsManager.emit(PointEvents.POINT_DESTROYED,this);\n        for (let eventName in this.subscriptions) {\n            const handlers = this.subscriptions[eventName];\n            handlers.forEach(handler => EventsManager.unsubscribe(eventName,handler));\n            this.subscriptions[eventName] = [];\n        }\n    }\n\n    /**\n     * Uniform method that used to add event handler of specified type to this object.\n     * SmartPoint can emit events, defined in [PointEvents](#PointEvents) enumeration. So, you can\n     * listen any of these events.\n     * @param eventName {string} - Name of event. Use one of names, defined in [PointEvents](#PointEvents)\n     * @param handler {function} - Function that used as an event handler\n     * @returns {function} - Pointer to added event handler. Should be used to remove event listener later.\n     */\n    this.addEventListener = (eventName,handler) => {\n        if (typeof(this.subscriptions[eventName]) === \"undefined\") {\n            this.subscriptions[eventName] = [];\n        }\n        const listener = EventsManager.subscribe(eventName, (event) => {\n            if (event.target && event.target.guid === this.guid) {\n                handler(event)\n            }\n        });\n        this.subscriptions[eventName].push(listener);\n        return listener;\n    }\n\n    /**\n     * Uniform method that used to remove event handler, that previously added\n     * to this object.\n     * @param eventName {string} Name of event to remove listener from\n     * @param listener {function} Pointer to event listener, that added previously.\n     * It was returned from [addEventListener](#ResizeBox+addEventListener) method.\n     */\n    this.removeEventListener = (eventName,listener) => {\n        if (this.subscriptions[eventName] && typeof(this.subscriptions[eventName]) !== \"undefined\") {\n            this.subscriptions[eventName].splice(this.subscriptions[eventName].indexOf(listener), 1);\n        }\n        EventsManager.unsubscribe(eventName,listener)\n    }\n\n    /**\n     * Method returns a distance from this point to other specified point\n     * @param point {SmartPoint} Distant point\n     * @returns {number} Distance from this point to specified point\n     */\n    this.distance = (point) => {\n        return distance(this.x,this.y,point.x,point.y)\n    }\n\n    return this;\n}\n\n/**\n * Enumeration of event names, that can be emitted by [SmartPoint](#SmartPoint) object.\n * @param create {PointEvents.POINT_ADDED} Emitted when point created. Event contains SmartPoint object in `target` field\n * @param drag_start {MouseEvent} Emitted when user press mouse button on point before start dragging it.\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) mousedown object\n * @param drag {MouseEvent} Emitted when user drags point by a mouse.\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) mousemove object\n * and two additional fields: `oldX` and `oldY` coordinates, which was before event start.\n * @param drag_end {MouseEvent} Emitted when user releases mouse button after pressing it on point\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) mouseup object\n * @param mousedown {MouseEvent} Emitted when user presses mouse button on point\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) mousedown object\n * @param mouseup {MouseEvent} Emitted when user releases mouse button on point\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) mouseup object\n * @param mouseover {MouseEvent} Emitted when mouse cursor goes inside point\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) mouseover object\n * @param mousemove {MouseEvent} Emitted when mouse cursor moves on top of point\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) mouseover object\n * @param mouseout {MouseEvent} Emitted when mouse cursor goes away from point\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) mouseout object\n * @param click {MouseEvent} Emitted when click on point\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) click object\n * @param dblclick {MouseEvent} Emitted when double-click on point\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) dblclick object\n * @param destroy {PointEvents.POINT_DESTROYED} Emitted when point destroyed (by pressing right mouse button on it or\n * programmatically using `destroy` method)\n * @enum {string}\n */\nexport const PointEvents = {\n    POINT_ADDED: \"create\",\n    POINT_DESTROYED: \"destroy\",\n    POINT_DRAG_START: \"move_start\",\n    POINT_DRAG_MOVE: \"move\",\n    POINT_DRAG_END: \"move_end\",\n    POINT_MOUSE_DOWN: \"mousedown\",\n    POINT_MOUSE_MOVE: \"mousemove\",\n    POINT_MOUSE_UP: \"mouseup\",\n    POINT_MOUSE_OVER: \"mouseover\",\n    POINT_MOUSE_OUT: \"mouseout\",\n    POINT_MOUSE_CLICK: \"click\",\n    POINT_MOUSE_DOUBLE_CLICK: \"dblclick\",\n    POINT_DELETE_REQUEST: \"point_delete_request\"\n};\n\n/**\n * Enumeration that defines point move directions. Values from this enumeration should be used\n * in point option `moveDirections` to specify in which directions point can be moved.\n * Members of enumeration: `LEFT`, `TOP`, `RIGHT`, `BOTTOM`\n * @enum {int}\n */\nexport const PointMoveDirections = {\n    TOP: 0,\n    LEFT: 1,\n    RIGHT: 2,\n    BOTTOM: 3\n}\n\nexport default SmartPoint;\n","import EventsManager from \"../events/EventsManager.js\";\nimport {ShapeEvents} from \"../SmartShape/SmartShapeEventListener.js\";\nimport {PointEvents} from \"../SmartPoint/SmartPoint.js\";\nimport {distance, radians_to_degrees} from \"../utils\";\nimport {createEvent, getMouseCursorPos} from \"../events/functions.js\";\n\n/**\n * Internal helper class, that contains all event listening logic for the RotateBox.\n * This class should not be used directly. Each RotateBox creates an instance of\n * this class automatically during init process\n * @param rotateBox {RotateBox} Link to owner Shape instance\n * @constructor\n */\nfunction RotateBoxEventListener(rotateBox) {\n\n    /**\n     * @ignore\n     * Underlying rotateBox that managed by this event listener\n     * @type {RotateBox}\n     */\n    this.rotateBox = rotateBox;\n\n    /**\n     * @ignore\n     * List of subscribers, that subscribed to events, emitted by\n     * this RotateBox. This is an object, that consists of array\n     * of event handlers of each event. Each handler is a function\n     * that called when event of specified type emitted by\n     * this RotateBox\n     * @type {object}\n     */\n    this.subscriptions = {\n        \"rotate\": []\n    }\n\n    /**\n     * @ignore\n     * Initial rotation angle when user presses one of rotation buttons\n     * @type {number}\n     */\n    this.initialAngle = 0;\n\n    /**\n     * @ignore\n     * Rotation angle from previous rotate event. Used to measure difference\n     * between previous rotate event and current rotation event.\n     * @type {number}\n     */\n    this.previousAngle = 0;\n\n    this.shapeEventListeners = {};\n\n    /**\n     * @ignore\n     * Initializes and starts this event listener\n     * @returns {RotateBoxEventListener}\n     */\n    this.run = () => {\n        this.setEventListeners();\n        return this;\n    }\n\n    /**\n     * @ignore\n     * Setup event handlers for different events, to which rotate box should react.\n     */\n    this.setEventListeners = () => {\n        this.interceptEventsFromShape();\n        this.rotateBox.shape.points.forEach(point => {\n            point.mousemove = this.mousemove;\n            point.mouseDownListener = point.addEventListener(PointEvents.POINT_DRAG_START, (event) => {\n                this.onPointMouseDown(event);\n                    EventsManager.emit(ShapeEvents.POINT_DRAG_START,this.rotateBox,{point:point})\n\n            });\n            point.mouseUpListener = point.addEventListener(PointEvents.POINT_DRAG_END, (event) => {\n                this.onPointMouseUp(event);\n                    EventsManager.emit(ShapeEvents.POINT_DRAG_END,this.rotateBox,{point:point})\n            });\n        });\n    }\n\n    /**\n     * @ignore\n     * Method intercepts all mouse events from underlying shape\n     * and re-emits them like they come from RotateBox\n     */\n    this.interceptEventsFromShape = () => {\n        ShapeEvents.getShapeMouseEvents().forEach(item => {\n            this.shapeEventListeners[item.name] = this.rotateBox.shape.addEventListener(item.name,(event) => {\n                if (item.key === \"SHAPE_MOVE_END\") {\n                    this.previousAngle = 0;\n                }\n                EventsManager.emit(item.name,this.rotateBox,event);\n            });\n        })\n    }\n\n    /**\n     * @ignore\n     * onMouseMove event handler, triggered when user moves mouse over the shape or container element.\n     * @param event {MouseEvent} Event object\n     */\n    this.mousemove = (event) => {\n        if (event.buttons !== 1) {\n            EventsManager.emit(ShapeEvents.SHAPE_MOUSE_MOVE,this.rotateBox.shape,\n                createEvent(event,{clientX:event.clientX,clientY:event.clientY})\n            );\n            return\n        }\n        const [clientX,clientY] = getMouseCursorPos(event,this.rotateBox.shape.root);\n        const [centerX,centerY] = this.rotateBox.shape.getCenter();\n        let angle = this.calcAngle(clientX,clientY,centerX,centerY);\n        if (angle === null) {\n            return;\n        }\n        let angleDiff = angle;\n        if (this.previousAngle) {\n            angleDiff -= this.previousAngle;\n        }\n        this.previousAngle = angle;\n        EventsManager.emit(RotateBoxEvents.ROTATE_BOX_ROTATE,this.rotateBox,{angle:angleDiff});\n    }\n\n    /**\n     * @ignore\n     * Method used to calculate rotation angle based on coordinates of point to which\n     * user dragged the mouse cursor and center to rotate the point around\n     * @param clientX {number} X coordinate of current mouse cursor position\n     * @param clientY {number} Y coordinate of current mouse cursor position\n     * @param centerX {number} X coordinate of center (shape center)\n     * @param centerY {number} Y coordinate of center (shape center)\n     * @returns {null|number} Rotation angle in degrees or null if impossible to calculate it\n     */\n    this.calcAngle = (clientX,clientY,centerX,centerY) => {\n        const hypotenuse = this.calcHypotenuse(clientX,clientY,centerX,centerY);\n        if (hypotenuse <= 0) {\n            return null;\n        }\n        const cathetus = this.calcCathetus(clientX,clientY,centerX,centerY);\n        const startAngle = this.calcStartAngle(clientX,clientY,centerX,centerY);\n        return Math.round(radians_to_degrees(Math.asin(cathetus/hypotenuse)) + startAngle + this.initialAngle);\n    }\n\n    /**\n     * @ignore\n     * Method used to calculate distance from point of mouse cursor to center of a shape,\n     * which is a hypotenuse of triangle, used to calculate sine of rotation angle\n     * https://code.germanov.dev/smart_shape/assets/sin-cos-tan.svg\n     * @param clientX {number} X coordinate of current mouse cursor position\n     * @param clientY {number} Y coordinate of current mouse cursor position\n     * @param centerX {number} X coordinate of center (shape center)\n     * @param centerY {number} Y coordinate of center (shape center)\n     * @returns {number} Length of hypotenuse\n     */\n    this.calcHypotenuse = (clientX,clientY,centerX,centerY) => {\n        return distance(clientX,clientY,centerX,centerY);\n    }\n\n    /**\n     * @ignore\n     * Method used to determine the size of opposite cathetus of triangle,\n     * that can be created from (clientX,clientY) mouse cursor point\n     * to (centerX,centerY) point of shape center. The distance, that need\n     * to calculate depends on quarter of coordinate plane with center in (centerX,centerY)\n     * in which the point (clientX,clientY) located.\n     * https://code.germanov.dev/smart_shape/assets/quarters.jpeg\n     * Cathetus used to calculate sine of rotation angle by formula, specified here:\n     * https://code.germanov.dev/smart_shape/assets/sin-cos-tan.svg\n     * @param clientX {number} X coordinate of current mouse cursor position\n     * @param clientY {number} Y coordinate of current mouse cursor position\n     * @param centerX {number} X coordinate of center (shape center)\n     * @param centerY {number} Y coordinate of center (shape center)\n     * @returns {number}\n     */\n    this.calcCathetus = (clientX,clientY,centerX,centerY) => {\n        if (clientX <= centerX && clientY <= centerY) {\n            return distance(clientX,clientY,clientX,centerY)\n        }\n        if (clientX >= centerX && clientY <= centerY) {\n            return distance(clientX,clientY,centerX,clientY);\n        }\n        if (clientX >= centerX && clientY >= centerY) {\n            return distance(clientX,clientY,clientX,centerY);\n        }\n        if (clientX <= centerX && clientY >= centerY) {\n            return distance(clientX,clientY,centerX,clientY);\n        }\n    }\n\n    /**\n     * @ignore\n     * Method used to determine the angle which need to subtract,\n     * depending on quarter of coordinate plane  with center in\n     * (centerX,centerY) point of shape center, when move the point\n     * (clientX,clientY) clockwise:\n     * https://code.germanov.dev/smart_shape/assets/sin-cos-tan.svg\n     * @param clientX {number} X coordinate of current mouse cursor position\n     * @param clientY {number} Y coordinate of current mouse cursor position\n     * @param centerX {number} X coordinate of center (shape center)\n     * @param centerY {number} Y coordinate of center (shape center)\n     * @returns {number} Angle in degrees\n     */\n    this.calcStartAngle = (clientX,clientY,centerX,centerY) => {\n        if (clientX <= centerX && clientY <= centerY) { // II\n            return 0;\n        }\n        if (clientX >= centerX && clientY <= centerY) { // I\n            return 90;\n        }\n        if (clientX >= centerX && clientY >= centerY) { // IV\n            return 180;\n        }\n        if (clientX <= centerX && clientY >= centerY) { /// III\n            return 270\n        }\n    }\n\n    /**\n     * @ignore\n     * onMouseDown event for marker points\n     * @param event {MouseEvent} Standard Mouse event object\n     */\n    this.onPointMouseDown = (event) => {\n        switch (event.target) {\n            case this.rotateBox.left_top:\n                this.initialAngle = -45;\n                break;\n            case this.rotateBox.right_top:\n                this.initialAngle = -135;\n                break;\n            case this.rotateBox.right_bottom:\n                this.initialAngle = -225;\n                break;\n            case this.rotateBox.left_bottom:\n                this.initialAngle = -315;\n                break;\n        }\n        this.rotateBox.shape.points.forEach(point => point.setOptions({visible:false}));\n    }\n\n    /**\n     * @ignore\n     * onMouseUp event for marker points\n     * @param _event {MouseEvent} Standard Mouse event object\n     */\n    this.onPointMouseUp = (event) => {\n        this.rotateBox.shape.points.forEach(point => {\n            point.setOptions({visible:true});\n            point.redraw();\n        });\n    }\n\n    /**\n     * @ignore\n     * Uniform method that used to add event handler of specified type to this object.\n     * RotateBox can emit events, defined in [RotateBoxEvents](#RotabeBoxEvents) enumeration. So, you can\n     * listen any of these events.\n     * @param eventName {string} - Name of event. Use one of name, defined in [RotateBoxEvents](#RotateBoxEvents)\n     * @param handler {function} - Function that used as an event handler\n     * @returns {function} - Pointer to added event handler. Should be used to remove event listener later.\n     */\n    this.addEventListener = (eventName,handler) => {\n        if (typeof(this.subscriptions[eventName]) === \"undefined\") {\n            this.subscriptions[eventName] = [];\n        }\n        const listener = EventsManager.subscribe(eventName, (event) => {\n            if (event.target && event.target.shape && event.target.shape.guid === this.rotateBox.shape.guid) {\n                handler(event)\n            }\n        });\n        this.subscriptions[eventName].push(listener);\n        return listener;\n    }\n\n    /**\n     * @ignore\n     * Uniform method that used to remove event handler, that previously added\n     * to this object.\n     * @param eventName {RotateBoxEvents|string} Name of event to remove listener from\n     * @param listener {function} Pointer to event listener, that added previously.\n     * It was returned from [addEventListener](#RotateBox+addEventListener) method.\n     */\n    this.removeEventListener = (eventName,listener) => {\n        if (this.subscriptions[eventName] && typeof(this.subscriptions[eventName]) !== \"undefined\") {\n            this.subscriptions[eventName].splice(this.subscriptions[eventName].indexOf(listener), 1);\n        }\n        EventsManager.unsubscribe(eventName,listener)\n    }\n\n    /**\n     * @ignore\n     * Method used to destroy the object. Removes all event subscriptions.\n     */\n    this.destroy = () => {\n        for (let eventName in this.subscriptions) {\n            const handlers = this.subscriptions[eventName];\n            handlers.forEach(handler => EventsManager.unsubscribe(eventName,handler));\n            this.subscriptions[eventName] = [];\n        }\n        Object.keys(this.shapeEventListeners).forEach(\n            key => {\n                this.rotateBox.removeEventListener(key, this.shapeEventListeners[key])\n            }\n        )\n        this.rotateBox.shape.points.forEach(point => {\n            point.removeEventListener(PointEvents.POINT_DRAG_START, point.mouseDownListener);\n            point.removeEventListener(PointEvents.POINT_DRAG_END, point.mouseUpListener);\n        });\n    }\n}\n\n/**\n * Enumeration that defines events, that RotateBox can emit.\n * @param rotate {RotateBoxEvents.ROTATE_BOX_ROTATE} Emitted when user rotate the shape by dragging one of marker points.\n * The event object of this type contains `angle` option, which is an angle of rotation in degrees.\n * @param create {ShapeEvents.SHAPE_CREATE} Emitted right after shape is created and initialized.\n * Event object contains created shape [SmartShape](#SmartShape) object in a `target` field\n * @param move_start {MouseEvent} Emitted when user presses left mouse button on shape to start dragging.\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) mousedown object with additional\n * field `pos`, which is a position of shape when movement started.\n * Position is an object with following fields \"left,top,right,bottom,width,height\"\n * @param move {MouseEvent} Emitted when user drags shape.\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) mousemove object, but also\n * includes additional properties `oldPos` - shape position before previous movement. `newPos` - shape position after\n * previous movement. Position is an object with following fields \"left,top,right,bottom,width,height\"\n * @param move_end {MouseEvent} Emitted when user releases mouse button to stop drag the shape.\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) mouseup object with additional\n * field `pos`, which is a position of shape when movement started.\n * Position is an object with following fields \"left,top,right,bottom,width,height\"\n * @param mousemove {MouseEvent} Emitted when user moves mouse over shape\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) mousemove object\n * @param mouseover {MouseEvent} Emitted when mouse cursor goes inside shape\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) mouseover object\n * @param mouseout {MouseEvent} Emitted when mouse cursor goes away from shape\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) mouseout object\n * @param click {MouseEvent} Emitted when click on shape\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) click object\n * @param dblclick {MouseEvent} Emitted when double-click on shape\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) dblclick object\n * @param point_drag_start {MouseEvent} Emitted when user starts dragging one of shape's point. Event Includes `point` field.\n * It is a [SmartPoint](#SmartPoint) object.\n * @param point_drag_move {MouseEvent} Emitted when user dragging one of shape's point. Event Includes `point` field.\n * It is a [SmartPoint](#SmartPoint) object.\n * @param point_drag_end {MouseEvent} Emitted when user finishes dragging one of shape's point. Event Includes `point` field.\n * It is a [SmartPoint](#SmartPoint) object.\n * @param destroy {ShapeEvents.SHAPE_DESTROY} Emitted right before shape is destroyed\n * Event object contains created shape [SmartShape](#SmartShape) object in a `target` field\n * @enum {string}\n */\nexport const RotateBoxEvents = {\n    ROTATE_BOX_ROTATE: \"rotate\"\n};\n\nexport default RotateBoxEventListener;\n","import EventsManager from \"../events/EventsManager.js\";\nimport {PointEvents} from \"../SmartPoint/SmartPoint.js\";\nimport {ShapeEvents} from \"../SmartShape/SmartShapeEventListener.js\";\nimport {uuid} from \"../utils\";\nimport {createEvent} from \"../events/functions.js\";\n\n/**\n * Internal helper class, that contains all event listening logic for the ResizeBox.\n * This class should not be used directly. Each ResizeBox creates an instance of\n * this class automatically during init process\n * @param resizeBox {ResizeBox} Link to owner Shape instance\n * @constructor\n */\nfunction ResizeBoxEventListener(resizeBox) {\n\n    /**\n     * @ignore\n     * Underlying resizeBox that managed by this event listener\n     * @type {ResizeBox}\n     */\n    this.resizeBox = resizeBox;\n\n    /**\n     * @ignore\n     * List of subscribers, that subscribed to events, emitted by\n     * this ResizeBox. This is an object, that consists of array\n     * of event handlers of each event. Each handler is a function\n     * that called when event of specified type emitted by\n     * this ResizeBox\n     * @type {object}\n     */\n    this.subscriptions = {\n        \"resize\": []\n    }\n\n    this.guid = uuid();\n\n    this.shapeEventListeners = {};\n\n    /**\n     * @ignore\n     * Initializes and starts this event listener\n     * @returns {ResizeBoxEventListener}\n     */\n    this.run = () => {\n        this.setEventListeners();\n        return this;\n    }\n\n    /**\n     * @ignore\n     * Setup event handlers for different events, to this resize box\n     * should react.\n     */\n    this.setEventListeners = () => {\n        EventsManager.subscribe(PointEvents.POINT_DRAG_MOVE, this.onPointDragMove);\n        EventsManager.subscribe(PointEvents.POINT_DRAG_END, this.onPointDragMove);\n        ShapeEvents.getShapeMouseEvents().forEach(item => {\n            this.shapeEventListeners[item.name] = this.resizeBox.shape.addEventListener(item.name,(event) => {\n                EventsManager.emit(item.name,this.resizeBox,event);\n            });\n        })\n    }\n\n    /**\n     * @ignore\n     * Event handler, that used to react to events, when user drag marker points of\n     * ResizeBox.\n     * This handler used to automatically adjusts coordinates of other marker points,\n     * based on changes from current point, that generated this event.\n     * Also, this method emits \"resize\" event, that can be intercepted by other\n     * objects, subscribed to ResizeBox events. For example, [SmartShape](#SmartShape)\n     * reacts on it to scale itself when dimensions of ResizeBox changed.\n     * @param event {object} Event object, that contains pointer to [SmartPoint](#SmartPoint) that\n     * emitted it.\n     */\n    this.onPointDragMove = (event) => {\n        if (!this.resizeBox.shape.isShapePoint(event.target)) {\n            return\n        }\n        switch (event.target) {\n            case this.resizeBox.left_top:\n                this.onLeftTopDragMove(event);\n                break;\n            case this.resizeBox.center_top:\n                this.onCenterTopDragMove(event);\n                break;\n            case this.resizeBox.right_top:\n                this.onRightTopDragMove(event);\n                break;\n            case this.resizeBox.right_center:\n                this.onRightCenterDragMove(event);\n                break;\n            case this.resizeBox.right_bottom:\n                this.onRightBottomDragMove(event);\n                break;\n            case this.resizeBox.center_bottom:\n                this.onCenterBottomDragMove(event);\n                break;\n            case this.resizeBox.left_bottom:\n                this.onLeftBottomDragMove(event);\n                break;\n            case this.resizeBox.left_center:\n                this.onLeftCenterDragMove(event);\n                break;\n        }\n        this.resizeBox.adjustCenters();\n        this.resizeBox.setPointsMoveBounds();\n        const oldPos = this.resizeBox.getPosition();\n        this.resizeBox.calcPosition();\n        const newPos = this.resizeBox.getPosition();\n        this.resizeBox.redraw();\n        EventsManager.emit(ShapeEvents.POINT_DRAG_END,this.resizeBox,createEvent(event,{point:event.target}));\n        EventsManager.emit(ResizeBoxEvents.RESIZE_BOX_RESIZE,this.resizeBox,createEvent(event,{oldPos,newPos}));\n    }\n\n    /**\n     * @ignore\n     * Event handler that triggered when change position of left top marker point.\n     * @param event {object} Event object, that contains pointer to [SmartPoint](#SmartPoint) that\n     * emitted it.\n     */\n    this.onLeftTopDragMove = (event) => {\n        this.resizeBox.left_center.x = event.target.x;\n        this.resizeBox.left_bottom.x = event.target.x;\n        this.resizeBox.center_top.y = event.target.y;\n        this.resizeBox.right_top.y = event.target.y;\n    }\n\n    /**\n     * @ignore\n     * Event handler that triggered when change position of center top marker point.\n     * @param event {object} Event object, that contains pointer to [SmartPoint](#SmartPoint) that\n     * emitted it.\n     */\n    this.onCenterTopDragMove = (event) => {\n        this.resizeBox.left_top.y = event.target.y;\n        this.resizeBox.right_top.y = event.target.y;\n    }\n\n    /**\n     * @ignore\n     * Event handler that triggered when change position of right top marker point.\n     * @param event {object} Event object, that contains pointer to [SmartPoint](#SmartPoint) that\n     * emitted it.\n     */\n    this.onRightTopDragMove = (event) => {\n        this.resizeBox.left_top.y = event.target.y;\n        this.resizeBox.center_top.y = event.target.y;\n        this.resizeBox.right_center.x = event.target.x;\n        this.resizeBox.right_bottom.x = event.target.x;\n    }\n\n    /**\n     * @ignore\n     * Event handler that triggered when change position of right center marker point.\n     * @param event {object} Event object, that contains pointer to [SmartPoint](#SmartPoint) that\n     * emitted it.\n     */\n    this.onRightCenterDragMove = (event) => {\n        this.resizeBox.right_top.x = event.target.x;\n        this.resizeBox.right_bottom.x = event.target.x;\n    }\n\n    /**\n     * @ignore\n     * Event handler that triggered when change position of right bottom marker point.\n     * @param event {object} Event object, that contains pointer to [SmartPoint](#SmartPoint) that\n     * emitted it.\n     */\n    this.onRightBottomDragMove = (event) => {\n        this.resizeBox.right_top.x = event.target.x;\n        this.resizeBox.right_center.x = event.target.x;\n        this.resizeBox.left_bottom.y = event.target.y;\n        this.resizeBox.center_bottom.y = event.target.y;\n    }\n\n    /**\n     * @ignore\n     * Event handler that triggered when change position of center bottom marker point.\n     * @param event {object} Event object, that contains pointer to [SmartPoint](#SmartPoint) that\n     * emitted it.\n     */\n    this.onCenterBottomDragMove = (event) => {\n        this.resizeBox.left_bottom.y = event.target.y;\n        this.resizeBox.right_bottom.y = event.target.y;\n    }\n\n    /**\n     * @ignore\n     * Event handler that triggered when change position of left bottom marker point.\n     * @param event {object} Event object, that contains pointer to [SmartPoint](#SmartPoint) that\n     * emitted it.\n     */\n    this.onLeftBottomDragMove = (event) => {\n        this.resizeBox.center_bottom.y = event.target.y;\n        this.resizeBox.right_bottom.y = event.target.y;\n        this.resizeBox.left_center.x = event.target.x;\n        this.resizeBox.left_top.x = event.target.x;\n    }\n\n    /**\n     * @ignore\n     * Event handler that triggered when change position of left center marker point.\n     * @param event {object} Event object, that contains pointer to [SmartPoint](#SmartPoint) that\n     * emitted it.\n     */\n    this.onLeftCenterDragMove = (event) => {\n        this.resizeBox.left_bottom.x = event.target.x;\n        this.resizeBox.left_top.x = event.target.x;\n    }\n\n    /**\n     * @ignore\n     * Uniform method that used to add event handler of specified type to this object.\n     * ResizeBox can emit events, defined in [ResizeBoxEvents](#ResizeBoxEvents) enumeration. So, you can\n     * listen any of these events.\n     * @param eventName {string} - Name of event. Use one of names, defined in [ResizeBoxEvents](#ResizeBoxEvents)\n     * @param handler {function} - Function that used as an event handler\n     * @returns {function} - Pointer to added event handler. Should be used to remove event listener later.\n     */\n    this.addEventListener = (eventName,handler) => {\n        if (typeof(this.subscriptions[eventName]) === \"undefined\") {\n            this.subscriptions[eventName] = [];\n        }\n        const listener = EventsManager.subscribe(eventName, (event) => {\n            if (event.target && event.target.guid && event.target.guid === this.resizeBox.guid) {\n                handler(event)\n            }\n        });\n        this.subscriptions[eventName].push(listener);\n        return listener;\n    }\n\n    /**\n     * @ignore\n     * Uniform method that used to remove event handler, that previously added\n     * to this object.\n     * @param eventName {ResizeBoxEvents|string} Name of event to remove listener from\n     * @param listener {function} Pointer to event listener, that added previously.\n     * It was returned from [addEventListener](#ResizeBox+addEventListener) method.\n     */\n    this.removeEventListener = (eventName,listener) => {\n        if (this.subscriptions[eventName] && typeof(this.subscriptions[eventName]) !== \"undefined\") {\n            this.subscriptions[eventName].splice(this.subscriptions[eventName].indexOf(listener), 1);\n        }\n        EventsManager.unsubscribe(eventName,listener)\n    }\n\n    /**\n     * @ignore\n     * Method used to destroy the object. Removes all event subscriptions.\n     */\n    this.destroy = () => {\n        for (let eventName in this.subscriptions) {\n            const handlers = this.subscriptions[eventName];\n            handlers.forEach(handler => EventsManager.unsubscribe(eventName,handler));\n            this.subscriptions[eventName] = [];\n        }\n        Object.keys(this.shapeEventListeners).forEach(\n            key => {\n                this.resizeBox.removeEventListener(key, this.shapeEventListeners[key])\n            }\n        )\n        EventsManager.unsubscribe(PointEvents.POINT_DRAG_MOVE,this.onPointDragMove);\n        EventsManager.unsubscribe(PointEvents.POINT_DRAG_END,this.onPointDragMove);\n    }\n}\n\nexport default ResizeBoxEventListener;\n\n/**\n * Enumeration that defines events, that ResizeBox can emit.\n * @param resize {ResizeBoxEvents.RESIZE_BOX_RESIZE} Emitted when user resized the shape by dragging one of marker points.\n * Event object includes fields `oldPos` and\n * `newPos` which are positions of shape before and after resizing.\n * Position is an object with following fields \"left,top,right,bottom,width,height\"\n * @param create {ShapeEvents.SHAPE_CREATE} Emitted right after shape is created and initialized.\n * Event object contains created shape [SmartShape](#SmartShape) object in a `target` field\n * @param move_start {MouseEvent} Emitted when user presses left mouse button on shape to start dragging.\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) mousedown object with additional\n * field `pos`, which is a position of shape when movement started.\n * Position is an object with following fields \"left,top,right,bottom,width,height\"\n * @param move {MouseEvent} Emitted when user drags shape.\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) mousemove object, but also\n * includes additional properties `oldPos` - shape position before previous movement. `newPos` - shape position after\n * previous movement. Position is an object with following fields \"left,top,right,bottom,width,height\"\n * @param move_end {MouseEvent}  Emitted when user releases mouse button to stop drag the shape.\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) mouseup object with additional\n * field `pos`, which is a position of shape when movement started.\n * Position is an object with following fields \"left,top,right,bottom,width,height\"\n * @param mousemove {MouseEvent} Emitted when user moves mouse over shape\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) mousemove object\n * @param mouseover {MouseEvent} Emitted when mouse cursor goes inside shape\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) mouseover object\n * @param mouseout {MouseEvent} Emitted when mouse cursor goes away from shape\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) mouseout object\n * @param click {MouseEvent} Emitted when click on shape\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) click object\n * @param dblclick {MouseEvent} Emitted when double-click on shape\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) dblclick object\n * @param point_drag_start {MouseEvent} Emitted when user starts dragging one of shape's point. Event Includes `point` field.\n * It is a [SmartPoint](#SmartPoint) object.\n * @param point_drag_move {MouseEvent} Emitted when user dragging one of shape's point. Event Includes `point` field.\n * It is a [SmartPoint](#SmartPoint) object.\n * @param point_drag_end {MouseEvent} Emitted when user finishes dragging one of shape's point. Event Includes `point` field.\n * It is a [SmartPoint](#SmartPoint) object.\n * @param destroy {ShapeEvents.SHAPE_DESTROY} Emitted right before shape is destroyed\n * Event object contains created shape [SmartShape](#SmartShape) object in a `target` field\n * @enum {string}\n */\nexport const ResizeBoxEvents = {\n    RESIZE_BOX_RESIZE: \"resize\"\n};\n","import SmartShapeManager from \"../SmartShapeManager/SmartShapeManager.js\";\nimport EventsManager from \"../events/EventsManager.js\";\nimport {getOffset, pauseEvent} from \"../utils\";\nimport {PointEvents} from \"../SmartPoint/SmartPoint.js\";\nimport {RotateBoxEvents} from \"../RotateBox/RotateBoxEventListener.js\";\nimport {ResizeBoxEvents} from \"../ResizeBox/ResizeBoxEventListener.js\";\nimport {createEvent} from \"../events/functions.js\";\n\n/**\n * Internal helper class, that contains all event listening logic for the shape.\n * This class should not be used directly. Each shape creates an instance of\n * this class automatically during init process\n * @param shape {SmartShape} Link to owner Shape instance\n * @constructor\n */\nfunction SmartShapeEventListener(shape) {\n\n    /**\n     * @ignore\n     * Link to owner shape instance\n     * @type {SmartShape}\n     */\n    this.shape = shape;\n\n    /**\n     * @ignore\n     * List of subscribers, that subscribed to events, emitted by\n     * this shape. This is an object, that consists of array\n     * of event handlers of each event. Each handler is a function\n     * that called when event of specified type emitted by\n     * this shape\n     * @type {object}\n     */\n    this.subscriptions = {\n        \"CONTAINER_BOUNDS_CHANGED\": []\n    }\n\n    /**\n     * @ignore\n     * Method binds events to the shape and returns itself\n     * @returns {SmartShapeEventListener}\n     */\n    this.run = () => {\n        this.shape = shape;\n        this.setEventListeners();\n        return this;\n    }\n\n    /**\n     * @ignore\n     * Internal method that installs HTML DOM event listeners to the shape, and it's container\n     */\n    this.setEventListeners = () => {\n        EventsManager.subscribe(PointEvents.POINT_DESTROYED, this.onPointDestroyed);\n        EventsManager.subscribe(PointEvents.POINT_ADDED, this.onPointAdded);\n        EventsManager.subscribe(PointEvents.POINT_DRAG_MOVE, this.onPointDragMove);\n        EventsManager.subscribe(PointEvents.POINT_DELETE_REQUEST, this.onPointDeleteRequest);\n        EventsManager.subscribe(ShapeEvents.SHAPE_ADD_CHILD,() => {\n            this.shape.redraw();\n        })\n    }\n\n    this.setSvgEventListeners = () => {\n        this.svg_mouseover = this.shape.svg.addEventListener(\"mouseover\", (event) => {\n            SmartShapeManager.mouseover(createEvent(event,{target:this.shape}));\n        });\n        this.svg_mouseout = this.shape.svg.addEventListener(\"mouseout\", (event) => {\n            SmartShapeManager.mouseout(createEvent(event,{target:this.shape}));\n        });\n        this.svg_mouseenter = this.shape.svg.addEventListener(\"mouseenter\", (event) => {\n            SmartShapeManager.mouseenter(createEvent(event,{target:this.shape}));\n        });\n        this.svg_mousedown = this.shape.svg.addEventListener(\"mousedown\", (event) => {\n            SmartShapeManager.mousedown(createEvent(event,{target:this.shape}));\n        });\n        this.svg_click = this.shape.svg.addEventListener(\"click\", (event) => {\n           SmartShapeManager.click(createEvent(event,{target:this.shape}));\n        });\n        this.svg_dblclick = this.shape.svg.addEventListener(\"dblclick\", (event) => {\n            SmartShapeManager.doubleclick(createEvent(event,{target:this.shape}))\n        });\n        this.svg_wheel = this.shape.svg.addEventListener(\"wheel\", (event) => {\n            this.wheel(event);\n        })\n    }\n\n    this.removeSvgEventListeners = () => {\n        this.shape.svg.removeEventListener(\"mouseover\", this.svg_mouseover);\n        this.shape.svg.removeEventListener(\"mouseout\", this.svg_mouseout);\n        this.shape.svg.removeEventListener(\"mouseenter\", this.svg_mouseenter);\n        this.shape.svg.removeEventListener(\"mousedown\",this.svg_mousedown);\n        this.shape.svg.removeEventListener(\"click\",this.svg_click);\n        this.shape.svg.removeEventListener(\"dblclick\",this.svg_dblclick);\n        this.shape.svg.removeEventListener(\"wheel\",this.svg_wheel);\n    }\n    /**\n     * @ignore\n     * Method adds event listeners to ResizeBox, connected to it to react on them. So, the shape can change itself\n     * when some event comes from ResizeBox: when user resizes ResizeBox, it emits \"resize\" event. Then the shape\n     * receives this event in this method and scales the shape according to new coordinates\n     * of the resize box\n     * Also, shape intercepts other events of ResizeBox, connected to it like \"mouseover\",\n     * \"mousemove\" or \"click\".\n     */\n    this.addResizeEventListener = () => {\n        if (!this.shape.resizeBox) {\n            return;\n        }\n        this.resizeBoxListener = this.shape.resizeBox.addEventListener(ResizeBoxEvents.RESIZE_BOX_RESIZE, this.onResize);\n        this.resizeMouseDownEventListener = this.shape.resizeBox.addEventListener(ShapeEvents.SHAPE_MOVE_START, this.mousedown);\n        this.resizeMouseMoveEventListener = this.shape.resizeBox.addEventListener(ShapeEvents.SHAPE_MOUSE_MOVE, this.mousemove);\n        this.resizeClickEventListener = this.shape.resizeBox.addEventListener(ShapeEvents.SHAPE_MOUSE_CLICK, this.click);\n        this.resizeDblClickEventListener = this.shape.resizeBox.addEventListener(ShapeEvents.SHAPE_MOUSE_DOUBLE_CLICK, this.svg_dblclick);\n        this.resizeMouseDownEventListener = this.shape.resizeBox.addEventListener(ShapeEvents.SHAPE_MOUSE_DOWN, this.svg_mousedown);\n        this.resizeMouseOverEventListener = this.shape.resizeBox.addEventListener(ShapeEvents.SHAPE_MOUSE_OVER, this.svg_mouseover);\n        this.resizeMouseOutEventListener = this.shape.resizeBox.addEventListener(ShapeEvents.SHAPE_MOUSE_OUT, this.svg_mouseout);\n        this.resizeMouseUpEventListener = this.shape.resizeBox.addEventListener(ShapeEvents.SHAPE_MOUSE_UP, (event) => {\n            EventsManager.emit(ShapeEvents.SHAPE_MOUSE_UP,this.shape,createEvent(event))\n        });\n        this.resizeBoxContextMenuEventListener = this.shape.resizeBox.shape.svg.addEventListener(\"contextmenu\", (event) => {\n            if (this.shape.contextMenu) {\n                this.shape.contextMenu.onEvent(event);\n            }\n        })\n        this.resizeBoxWheelEventListener = this.shape.resizeBox.shape.svg.addEventListener(\"wheel\", (event) => {\n            this.wheel(event);\n        })\n    }\n\n    /**\n     * @ignore\n     * Method adds event listeners to RotateBox, connected to it to react on them. So, the shape can change itself\n     * when some event comes from RotateBox: when user rotates RotateBox, it emits \"rotate\" event and the shape\n     * intercepts this event in this method. The `event` object, that RotateBox emits contains `angle` parameter\n     * that can be used. As a reaction to the event, listening function rotates the shape according to the angle,\n     * received from the event of rotate box.\n     * Also, shape intercepts other events of RotateBox, connected to it, like \"mouseover\",\n     * \"mousemove\" or \"click\".\n     */\n    this.addRotateEventListener = () => {\n        if (!this.shape.rotateBox) {\n            return;\n        }\n        this.rotateBoxListener = this.shape.rotateBox.addEventListener(RotateBoxEvents.ROTATE_BOX_ROTATE, this.onRotate);\n        this.rotateMouseDownEventListener = this.shape.rotateBox.addEventListener(ShapeEvents.SHAPE_MOVE_START, this.mousedown);\n        this.rotateMouseMoveEventListener = this.shape.rotateBox.addEventListener(ShapeEvents.SHAPE_MOUSE_MOVE, this.mousemove);\n        this.rotateClickEventListener = this.shape.rotateBox.addEventListener(ShapeEvents.SHAPE_MOUSE_CLICK, this.click)\n        this.rotateDblClickEventListener = this.shape.rotateBox.addEventListener(ShapeEvents.SHAPE_MOUSE_DOUBLE_CLICK, this.svg_dblclick);\n        this.rotateMouseDownEventListener = this.shape.rotateBox.addEventListener(ShapeEvents.SHAPE_MOUSE_DOWN, this.svg_mousedown);\n        this.rotateMouseUpEventListener = this.shape.rotateBox.addEventListener(ShapeEvents.SHAPE_MOUSE_UP, (event) => {\n            EventsManager.emit(ShapeEvents.SHAPE_MOUSE_UP,this.shape,createEvent(event))\n        });\n        this.rotateMouseOverEventListener = this.shape.rotateBox.addEventListener(ShapeEvents.SHAPE_MOUSE_OVER, this.svg_mouseover);\n        this.rotateMouseOutEventListener = this.shape.rotateBox.addEventListener(ShapeEvents.SHAPE_MOUSE_OUT, this.svg_mouseout);\n        this.rotatePointDragStartEventListener = this.shape.rotateBox.addEventListener(ShapeEvents.POINT_DRAG_START, (_event) => {\n            this.shape.initCenter = this.shape.getCenter(this.shape.options.groupChildShapes);\n        })\n        this.rotatePointDragEndEventListener = this.shape.rotateBox.addEventListener(ShapeEvents.POINT_DRAG_END, (_event) => {\n            this.shape.initCenter = null;\n            this.shape.points.filter(point=>point.options).forEach(point=> {\n                if (!point.options.hidden && point.element) {\n                    point.element.style.display = '';\n                }\n            })\n        })\n        this.rotateBoxContextMenuEventListener = this.shape.rotateBox.shape.svg.addEventListener(\"contextmenu\", (event) => {\n            if (this.shape.contextMenu) {\n                this.shape.contextMenu.onEvent(event);\n            }\n        })\n        this.rotateBoxWheelEventListener = this.shape.rotateBox.shape.svg.addEventListener(\"wheel\", (event) => {\n            this.wheel(event);\n        })\n    }\n\n    this.onResize = (event) => {\n        const parent = this.shape.getRootParent(true);\n        if (parent) {\n            EventsManager.emit(ResizeBoxEvents.RESIZE_BOX_RESIZE,parent.resizeBox,createEvent(event,\n                {newPos:event.newPos,oldPos:event.oldPos})\n            );\n            return\n        }\n        if (event.buttons && this.shape.options.simpleMode) {\n            return\n        }\n        const diffX = event.newPos.left - event.oldPos.left;\n        const diffY = event.newPos.top - event.oldPos.top;\n        this.shape.moveBy(diffX,diffY,false);\n        const [pointWidth,pointHeight] = this.shape.getMaxPointSize();\n        this.shape.scaleTo(event.newPos.width-(pointWidth)*2,event.newPos.height-(pointHeight)*2);\n        this.shape.redraw();\n        EventsManager.emit(ResizeBoxEvents.RESIZE_BOX_RESIZE,this.shape,event);\n    }\n\n    this.onRotate = (event) => {\n        const parent = this.shape.getRootParent(true);\n        if (parent) {\n            EventsManager.emit(RotateBoxEvents.ROTATE_BOX_ROTATE,parent.rotateBox,{angle:event.angle});\n            return\n        }\n        this.shape.rotateBy(event.angle);\n        this.shape.redraw()\n        EventsManager.emit(RotateBoxEvents.ROTATE_BOX_ROTATE,this.shape,event);\n    }\n\n    /**\n     * @ignore\n     * onMouseDown event handler, triggered when user presses mouse button on the shape or on container element.\n     * @param event {MouseEvent} Event object\n     */\n    this.mousedown = (event) => {\n        pauseEvent(event);\n        EventsManager.emit(ShapeEvents.SHAPE_MOUSE_DOWN,this.shape,createEvent(event));\n        setTimeout(() => {\n            EventsManager.emit(ShapeEvents.SHAPE_MOVE_START,\n                this.shape, createEvent(event,{pos:this.shape.getPosition(this.shape.options.groupChildShapes)}))\n        },100);\n    }\n\n    /**\n     * @ignore\n     * onMouseMove event handler, triggered when user moves mouse over the shape or container element.\n     * @param event {MouseEvent} Event object\n     */\n    this.mousemove = (event) => {\n        if (!this.shape.draggedPoint) {\n            EventsManager.emit(ShapeEvents.SHAPE_MOUSE_MOVE, this.shape, createEvent(event));\n        }\n        if (event.buttons !== 1) {\n            return\n        }\n        if (this.shape.draggedPoint) {\n            EventsManager.emit(ShapeEvents.POINT_DRAG_MOVE,this.shape,{point:this.shape.draggedPoint});\n            this.shape.draggedPoint.mousemove(event);\n            return\n        }\n        if (!this.shape.options.canDragShape) {\n            return\n        }\n        const [stepX, stepY] = this.calcMovementOffset(event);\n        if (stepX === null || stepY === null) {\n            return\n        }\n        const oldPos = this.shape.getPosition(this.shape.options.groupChildShapes);\n        this.shape.moveBy(stepX,stepY,true,this.shape.options.simpleMode);\n        if (!this.shape.options.simpleMode) {\n            this.shape.redraw();\n        }\n        const newPos = this.shape.getPosition(this.shape.options.groupChildShapes);\n        EventsManager.emit(ShapeEvents.SHAPE_MOVE,this.shape,createEvent(event,{oldPos,newPos}));\n    }\n\n    /**\n     * @ignore\n     * onMouseEnter event handler, triggered when mouse cursor enters shape's container element\n     * @param event {MouseEvent} Event object\n     */\n    this.mouseenter = (event) => {\n        EventsManager.emit(ShapeEvents.SHAPE_MOUSE_ENTER, this.shape, createEvent(event));\n    }\n\n    /**\n     * @ignore\n     * onMouseOver event handler, triggered when user moves mouse over the shape.\n     * @param event {MouseEvent} Event object\n     */\n    this.mouseover = (event) => {\n        if (SmartShapeManager.draggedShape === this.shape) {\n            return\n        }\n        EventsManager.emit(ShapeEvents.SHAPE_MOUSE_OVER,this.shape,createEvent(event));\n    }\n\n    /**\n     * @ignore\n     * onMouseOut event handler, triggered when user moves mouse away from shape.\n     * @param event {MouseEvent} Event object\n     */\n    this.mouseout = (event) => {\n        EventsManager.emit(ShapeEvents.SHAPE_MOUSE_OUT,this.shape,createEvent(event));\n    }\n\n    /**\n     * @ignore\n     * onClick event handler, triggered when user clicks on shape\n     * @param event {MouseEvent} Event object\n     */\n    this.click = (event) => {\n        EventsManager.emit(ShapeEvents.SHAPE_MOUSE_CLICK, this.shape, createEvent(event));\n    }\n\n    /**\n     * @ignore\n     * onDblClick event handler, triggered when user double-clicks on shape\n     * @param event {MouseEvent} Event object\n     */\n    this.doubleclick = (event) => {\n        EventsManager.emit(ShapeEvents.SHAPE_MOUSE_DOUBLE_CLICK, this.shape, createEvent(event));\n    }\n\n    /**\n     * @ignore\n     * Mouse wheel event handler. Zooms in or out the shape if it zoomable\n     * @param event {MouseEvent} Event object\n     */\n    this.wheel = (event) => {\n        if (this.shape.options.zoomable && this.shape.options.id.search(\"_resizebox\") === -1 &&\n            this.shape.options.id.search(\"_rotatebox\") === -1) {\n            if (event.deltaY < 0) {\n                this.shape.zoomBy(1+this.shape.options.zoomStep);\n            } else {\n                this.shape.zoomBy(1-this.shape.options.zoomStep);\n            }\n            this.shape.redraw();\n        }\n    }\n\n    /**\n     * @ignore\n     * Internal method that used to calculate to which amount of pixels the shape should be moved when dragging it,\n     * depending on position of mouse cursor and bounds of container element.\n     * @param event {MouseEvent} event object\n     * @returns {array} Returns object with [x,y] coordinates or [null,null]\n     * if impossible to move (out of container bounds)\n     */\n    this.calcMovementOffset = (event) => {\n        this.shape.calcPosition();\n        const pos = this.shape.getPosition(this.shape.options.groupChildShapes);\n        let stepX = event.movementX;\n        let stepY = event.movementY;\n        let clientX = event.clientX+window.scrollX;\n        let clientY = event.clientY+window.scrollY;\n        const newX = pos.left + stepX;\n        const newY = pos.top + stepY;\n        const offset = getOffset(this.shape.root, true);\n        const bounds = this.shape.getBounds();\n        if (newX < bounds.left || newX+pos.width > bounds.right) {\n            stepX = 0;\n        }\n        if (newY < bounds.top || newY+pos.height > bounds.bottom) {\n            stepY = 0;\n        }\n        if (clientX<newX+offset.left) {\n            stepX = clientX - (newX+offset.left);\n        }\n        if (clientY<newY+offset.top) {\n            stepY = clientY - (newY+offset.top);\n        }\n        if (clientX>newX+pos.width+offset.left) {\n            stepX = clientX -  (pos.width+offset.left+pos.left);\n        }\n        if (clientY>newY+pos.height+offset.right) {\n            stepY = clientY -  (pos.height+offset.top+pos.top);\n        }\n        return [stepX, stepY];\n    }\n\n    /**\n     * @ignore\n     * Internal method, that triggered when new point added\n     * @param event Custom event object\n     */\n    this.onPointAdded = (event) => {\n        if (!this.shape.isShapePoint(event.target)) {\n            return\n        }\n        if (event.target.element) {\n            try {\n                this.shape.root.appendChild(event.target.element)\n            } catch (err) {}\n        }\n        EventsManager.emit(ShapeEvents.POINT_ADDED,this.shape,{point:event.target});\n    }\n\n\n    /**\n     * @ignore\n     * Internal method, that triggered when user drags the point\n     * @param event Custom event object. Contains SmartPoint object as an `event.target`,\n     * `event.oldX` and `event.oldY` as a previous point coordinates before previous drag event.\n     */\n    this.onPointDragMove = (event) => {\n        if (this.shape.isShapePoint(event.target)) {\n            this.shape.updatePosition(event.target.x,event.target.y);\n            this.shape.redraw();\n        }\n    }\n\n    /**\n     * @ignore\n     * Internal method, that triggered when point is destroyed\n     * @param event Custom event object. Contains SmartPoint object as an event.target\n     **/\n    this.onPointDestroyed = (event) => {\n        if (!this.shape.isShapePoint(event.target)) {\n            return\n        }\n        this.shape.points.splice(this.shape.points.indexOf(event.target), 1);\n        try {\n            this.shape.root.removeChild(event.target.element);\n            this.shape.redraw()\n        } catch (err) {}\n        EventsManager.emit(ShapeEvents.POINT_DESTROYED,this.shape,{point:event.target});\n    }\n\n    /**\n     * @ignore\n     * Internal method that triggered when request to delete point of shape arroved\n     * @param event Custom event object. Contains SmartPoint object as an event.target\n     */\n    this.onPointDeleteRequest = (event) => {\n        if (!this.shape.isShapePoint(event.target)) {\n            return\n        }\n        this.shape.deletePoint(event.target.x,event.target.y);\n    }\n\n    /**\n     * @ignore\n     * Uniform method that used to add event handler of specified type to this object.\n     * @param eventName {string} Name of event\n     * @param handler {function} Function that used as an event handler\n     * @returns {function} Pointer to added event handler. Should be used to remove event listener later.\n     */\n    this.addEventListener = (eventName,handler) => {\n        if (typeof(this.subscriptions[eventName]) === \"undefined\") {\n            this.subscriptions[eventName] = [];\n        }\n        const listener = EventsManager.subscribe(eventName, (event) => {\n            if (event.target && event.target.guid === this.shape.guid) {\n                handler(event)\n            }\n        });\n        this.subscriptions[eventName].push(listener);\n        return listener;\n    }\n\n    /**\n     * @ignore\n     * Uniform method that used to remove event handler, that previously added\n     * to this object.\n     * @param eventName {string} Name of event to remove listener from\n     * @param listener {function} Pointer to event listener, that added previously.\n     * It was returned from [addEventListener](#ResizeBox+addEventListener) method.\n     */\n    this.removeEventListener = (eventName,listener) => {\n        if (this.subscriptions[eventName] && typeof(this.subscriptions[eventName]) !== \"undefined\") {\n            this.subscriptions[eventName].splice(this.subscriptions[eventName].indexOf(listener), 1);\n        }\n        EventsManager.unsubscribe(eventName,listener)\n    }\n\n    /**\n     * @ignore\n     * Used to remove all event listeners when destroy the object\n     */\n    this.destroy = () => {\n        EventsManager.unsubscribe(PointEvents.POINT_ADDED, this.onPointAdded);\n        EventsManager.unsubscribe(PointEvents.POINT_DRAG_MOVE, this.onPointDragMove);\n        EventsManager.unsubscribe(PointEvents.POINT_DESTROYED, this.onPointDestroyed);\n        EventsManager.unsubscribe(PointEvents.POINT_DELETE_REQUEST, this.onPointDeleteRequest);\n        if (this.shape.resizeBox) {\n            this.shape.resizeBox.removeEventListener(ResizeBoxEvents.RESIZE_BOX_RESIZE,this.resizeBoxListener);\n            this.shape.resizeBox.removeEventListener(ShapeEvents.SHAPE_MOUSE_CLICK,this.resizeClickEventListener);\n            this.shape.resizeBox.removeEventListener(ShapeEvents.SHAPE_MOUSE_MOVE,this.resizeMouseMoveEventListener);\n            this.shape.resizeBox.removeEventListener(ShapeEvents.SHAPE_MOVE_START,this.resizeMouseDownEventListener);\n            this.shape.resizeBox.removeEventListener(ShapeEvents.SHAPE_MOUSE_UP,this.resizeMouseUpEventListener);\n            this.shape.resizeBox.removeEventListener(ShapeEvents.SHAPE_MOUSE_DOUBLE_CLICK,this.resizeDblClickEventListener);\n            this.shape.resizeBox.removeEventListener(ShapeEvents.SHAPE_MOUSE_OVER,this.resizeMouseOverEventListener);\n            this.shape.resizeBox.removeEventListener(ShapeEvents.SHAPE_MOUSE_OUT,this.resizeMouseOutEventListener);\n            this.shape.resizeBox.removeEventListener(\"contextmenu\",this.resizeBoxContextMenuEventListener);\n            this.shape.resizeBox.removeEventListener(\"wheel\", this.resizeBoxWheelEventListener);\n        }\n        if (this.shape.rotateBox) {\n            this.shape.rotateBox.removeEventListener(RotateBoxEvents.ROTATE_BOX_ROTATE,this.rotateBoxListener);\n            this.shape.rotateBox.removeEventListener(ShapeEvents.SHAPE_MOUSE_CLICK,this.rotateClickEventListener);\n            this.shape.rotateBox.removeEventListener(ShapeEvents.SHAPE_MOUSE_MOVE,this.rotateMouseMoveEventListener);\n            this.shape.rotateBox.removeEventListener(ShapeEvents.SHAPE_MOVE_START,this.rotateMouseDownEventListener);\n            this.shape.rotateBox.removeEventListener(ShapeEvents.SHAPE_MOVE_START,this.rotatePointDragStartEventListener);\n            this.shape.rotateBox.removeEventListener(ShapeEvents.SHAPE_MOVE_START,this.rotatePointDragEndEventListener);\n            this.shape.rotateBox.removeEventListener(ShapeEvents.SHAPE_MOUSE_UP,this.rotateMouseUpEventListener);\n            this.shape.rotateBox.removeEventListener(ShapeEvents.SHAPE_MOUSE_DOUBLE_CLICK,this.rotateDblClickEventListener);\n            this.shape.rotateBox.removeEventListener(ShapeEvents.SHAPE_MOUSE_OVER,this.rotateMouseOverEventListener);\n            this.shape.rotateBox.removeEventListener(ShapeEvents.SHAPE_MOUSE_OUT,this.rotateMouseOutEventListener);\n            this.shape.rotateBox.removeEventListener(\"contextmenu\",this.rotateBoxContextMenuEventListener);\n            this.shape.rotateBox.removeEventListener(\"wheel\", this.rotateBoxWheelEventListener);\n        }\n        for (let eventName in this.subscriptions) {\n            const handlers = this.subscriptions[eventName];\n            handlers.forEach(handler => EventsManager.unsubscribe(eventName,handler));\n            this.subscriptions[eventName] = [];\n        }\n    }\n}\n\n/**\n * Enumeration of event names, that can be emitted by [SmartShape](#SmartShape) object.\n * @param create {ShapeEvents.SHAPE_CREATE} Emitted right after shape is created and initialized.\n * Event object contains created shape [SmartShape](#SmartShape) object in a `target` field\n * @param move_start {MouseEvent} Emitted when user presses left mouse button on shape to start dragging.\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) mousedown object with additional\n * field `pos`, which is a position of shape when movement started.\n * Position is an object with following fields \"left,top,right,bottom,width,height\"\n * @param move {MouseEvent} Emitted when user drags shape.\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) mousemove object, but also\n * includes additional properties `oldPos` - shape position before previous movement. `newPos` - shape position after\n * previous movement. Position is an object with following fields \"left,top,right,bottom,width,height\"\n * @param move_end {MouseEvent} Emitted when user releases mouse button to stop drag the shape.\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) mouseup object with additional\n * field `pos`, which is a position of shape when movement started.\n * Position is an object with following fields \"left,top,right,bottom,width,height\"\n * @param mousemove {MouseEvent} Emitted when user moves mouse over shape\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) mousemove object\n * @param mouseover {MouseEvent} Emitted when mouse cursor goes inside shape\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) mouseover object\n * @param mouseout {MouseEvent} Emitted when mouse cursor goes away from shape\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) mouseout object\n * @param click {MouseEvent} Emitted when click on shape\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) click object\n * @param dblclick {MouseEvent} Emitted when double-click on shape\n * Standard [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) dblclick object\n * @param resize {ResizeBoxEvents.RESIZE_BOX_RESIZE} Emitted when user resized the shape using resize box. Event object includes fields `oldPos` and\n * `newPos` which are positions of shape before and after resizing.\n * Position is an object with following fields \"left,top,right,bottom,width,height\"\n * @param rotate {RotateBoxEvents.ROTATE_BOX_ROTATE} Emitted when user rotated the shape using rotate box Event object includes the `angle` field,\n * which is a rotation angle.\n * Position is an object with following fields \"left,top,right,bottom,width,height\"\n * @param point_drag_start {MouseEvent} Emitted when user starts dragging one of shape's point. Event Includes `point` field.\n * It is a [SmartPoint](#SmartPoint) object.\n * @param point_drag_move {MouseEvent} Emitted when user dragging one of shape's point. Event Includes `point` field.\n * It is a [SmartPoint](#SmartPoint) object.\n * @param point_drag_end {MouseEvent} Emitted when user finishes dragging one of shape's point. Event Includes `point` field.\n * It is a [SmartPoint](#SmartPoint) object.\n * @param point_added {MouseEvent} Emitted when new point added to the shape\n * @param point_removed {MouseEvent} Emitted when point removed from the shape\n * @param destroy {ShapeEvents.SHAPE_DESTROY} Emitted right before shape is destroyed\n * @param add_child {ShapeEvents.SHAPE_ADD_CHILD} New child shape added to this shape. Event object contains a\n * `child` field which is a SmartShape object of added child.\n * @param remove_child {ShapeEvents.SHAPE_REMOVE_CHILD} Child shape removed from this shape. Event object contains a\n * `child` field which is a SmartShape object of removed child.\n * @param shape_activated {ShapeEvents.SHAPE_ACTIVATED} Shape activated\n * @enum {string}\n */\nexport const ShapeEvents = {\n    SHAPE_CREATE: \"create\",\n    SHAPE_MOVE_START: \"move_start\",\n    SHAPE_MOVE: \"move\",\n    SHAPE_MOVE_END: \"move_end\",\n    SHAPE_MOUSE_MOVE: \"mousemove\",\n    SHAPE_MOUSE_ENTER: \"mouseenter\",\n    SHAPE_MOUSE_OVER: \"mouseover\",\n    SHAPE_MOUSE_OUT: \"mouseout\",\n    SHAPE_MOUSE_DOWN: \"mousedown\",\n    SHAPE_MOUSE_UP: \"mouseup\",\n    SHAPE_MOUSE_CLICK: \"click\",\n    SHAPE_MOUSE_DOUBLE_CLICK: \"dblclick\",\n    SHAPE_DESTROY: \"destroy\",\n    SHAPE_SHOW: \"show\",\n    SHAPE_HIDE: \"hide\",\n    POINT_ADDED: \"point_added\",\n    POINT_DESTROYED: \"point_destroyed\",\n    POINT_DRAG_START: \"point_drag_start\",\n    POINT_DRAG_MOVE: \"point_drag_move\",\n    POINT_DRAG_END: \"point_drag_end\",\n    SHAPE_RESIZE: \"resize\",\n    SHAPE_ROTATE: \"rotate\",\n    SHAPE_ADD_CHILD: \"add_child\",\n    SHAPE_REMOVE_CHILD: \"remove_child\",\n    SHAPE_ACTIVATED: \"shape_activated\",\n    /**\n     * Method returns an object of all ShapeEvents that\n     * related to mouse.*\n     * @returns {array} Array of objects in a format \"key:,name:\"\n     */\n    getShapeMouseEvents: () => {\n        return Object.keys(ShapeEvents)\n            .filter(key=> {\n                return [\"SHAPE_CREATE\",\"SHAPE_DESTROY\",\"SHAPE_RESIZE\",\"SHAPE_ROTATE\"].indexOf(key) === -1 &&\n                    typeof(ShapeEvents[key])!== \"function\"\n            }).map(key => {return {key:key,name:ShapeEvents[key]} })\n    }\n}\n\nexport default SmartShapeEventListener;\n","import {EventsManager, ShapeEvents,SmartShapeManager,SmartShapeDisplayMode} from \"../index.js\";\nimport {blobToDataURL, dataURLtoBlob, notNull, timeout} from \"../utils\";\nimport {applyAspectRatio} from \"../utils/geometry.js\";\n\n/**\n * Internal helper class that used to draw shape.\n * Should not be used directly. SmartShape objects execute methods\n * of this object when need to draw shapes.\n * @constructor\n */\nfunction SmartShapeDrawHelper() {\n\n    /**\n     * @ignore\n     * Method that implements drawing for provided shape.\n     * @param shape {SmartShape} Shape object to draw\n     */\n    this.draw = (shape) => {\n        const parent = shape.getParent();\n        if (!parent || parent.guid === shape.guid || !parent.options.groupChildShapes) {\n            if (shape.svg) {\n                try {\n                    shape.eventListener.removeSvgEventListeners();\n                    shape.svg.innerHTML = \"\";\n                } catch (err) {\n                }\n            } else if (shape.points.length) {\n                shape.svg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n                shape.svg.ondragstart = function () {\n                    return false;\n                }\n                if (shape.options.visible) {\n                    EventsManager.emit(ShapeEvents.SHAPE_SHOW, shape);\n                }\n                shape.eventListener.setSvgEventListeners();\n                shape.svg.id = shape.options.id;\n                shape.svg.setAttribute(\"guid\", shape.guid);\n                shape.root.appendChild(shape.svg);\n            }\n            if (shape.svg && typeof(shape.svg.appendChild) === \"function\") {\n                const defs = document.createElementNS(shape.svg.namespaceURI, \"defs\");\n                shape.svg.appendChild(defs);\n            }\n        } else {\n            shape.svg = null;\n            const svg = document.querySelector(\"svg[guid='\"+shape.guid+\"']\");\n            if (svg) {\n                svg.parentNode.removeChild(svg);\n            }\n            shape.resizeBox && shape.resizeBox.hide();\n            shape.rotateBox && shape.rotateBox.hide();\n        }\n        if (shape.points.length < 1) {\n            return\n        }\n        if (shape.options.hasContextMenu && shape.shapeMenu && !shape.shapeMenu.contextMenu) {\n            shape.shapeMenu.updateContextMenu();\n        }\n        this.updateOptions(shape);\n        if (!parent || !parent.options.displayAsPath) {\n            this.drawPolygon(shape);\n            if (shape.svg && shape.options.id.search(\"_resizebox\") === -1 && shape.options.id.search(\"_rotatebox\") === -1) {\n                setTimeout(() => {\n                    this.setupZIndex(shape);\n                },0);\n            }\n        } else if (parent && parent.options.displayAsPath && parent.guid !== shape.guid) {\n            this.draw(parent);\n        }\n        EventsManager.emit(\"show_finish\",shape);\n    }\n\n    /**\n     * @ignore\n     * Method updates options of shape and it points\n     * (including child or other associated shapes)\n     * on drawing phase\n     * @param shape {SmartShape} Shape object\n     */\n    this.updateOptions = (shape) => {\n        shape.calcPosition();\n        const parent = shape.getRootParent();\n        if (shape.svg && (!parent || !parent.options.groupChildShapes) && typeof(shape.svg.appendChild) === \"function\") {\n            if (typeof (shape.options.visible) !== \"undefined\") {\n                if (shape.svg.style.display !== shape.options.visible) {\n                    if (shape.options.visible) {\n                        EventsManager.emit(ShapeEvents.SHAPE_SHOW, shape);\n                        shape.getChildren(true).forEach(child => EventsManager.emit(ShapeEvents.SHAPE_SHOW,child))\n                    } else {\n                        EventsManager.emit(ShapeEvents.SHAPE_HIDE, shape);\n                        shape.getChildren(true).forEach(child => EventsManager.emit(ShapeEvents.SHAPE_HIDE,child));\n                    }\n                }\n                shape.svg.style.display = shape.options.visible ? '' : 'none';\n            }\n            shape.svg.id = shape.options.id;\n            shape.svg.setAttribute(\"guid\", shape.guid);\n            let pos\n            if (shape.options.groupChildShapes) {\n                pos = shape.getPosition(true);\n            } else {\n                pos = shape.getPosition();\n            }\n            shape.svg.style.position = 'absolute';\n            shape.svg.style.cursor = 'default';\n            shape.svg.style.left = pos.left + \"px\";\n            shape.svg.style.top = pos.top + \"px\";\n            shape.svg.setAttribute(\"width\", pos.width);\n            shape.svg.setAttribute(\"height\", pos.height);\n            shape.svg.style.zIndex = shape.options.zIndex;\n        } else if (parent && parent.svg) {\n            const polygon = parent.svg.querySelector(\"#p\"+shape.guid+\"_polygon\");\n            if (polygon) {\n                polygon.style.zIndex = shape.options.zIndex;\n            }\n        }\n        if (!parent || !parent.options.displayAsPath) {\n            this.setupShapeFill(shape);\n            this.createSVGFilters(shape);\n            shape.options.canScale && this.redrawResizeBox(parent && parent.options.groupChildShapes ? parent : shape);\n            shape.options.canRotate && this.redrawRotateBox(parent && parent.options.groupChildShapes ? parent : shape);\n        }\n        if (shape.options.pointOptions.canDrag) {\n            this.updatePoints(shape, parent);\n        }\n    }\n\n    /**\n     * @ignore\n     * Method updates points after redraw shape\n     * @param shape {SmartShape} Shape that need to update\n     * @param parent {SmartShape} Root parent of this shape or null\n     */\n    this.updatePoints = async(shape,parent) => {\n        if (shape.points[0] && !shape.points[0].element) {\n            await timeout(1);\n        }\n        shape.points.filter(point => point.element).forEach(point => {\n            if (point.element.parentNode !== shape.root) {\n                shape.root.appendChild(point.element);\n            }\n            point.options.zIndex = shape.options.zIndex + 2;\n            if (!shape.options.visible) {\n                point.options.visible = false;\n            }\n            point.redraw();\n            if (shape.options.displayMode === SmartShapeDisplayMode.DEFAULT && !point.options.forceDisplay) {\n                if (!parent || parent.options.displayMode === SmartShapeDisplayMode.DEFAULT) {\n                    point.element.style.display = 'none';\n                }\n            }\n        });\n    }\n\n    /**\n     * @ignore\n     * Method that used to construct actual shape SVG polygon during shape redraw process\n     * @param shape {SmartShape} Shape object to which polygon should be appended\n     * @returns {object} SVG <polygon> object\n     */\n    this.drawPolygon = (shape,svg=null) => {\n        if (!svg) {\n            svg = this.getShapeSvg(shape);\n        }\n        if (!svg || typeof(svg.appendChild) !== \"function\") {\n            return\n        }\n        let polygon = svg.querySelector(\"#p\"+shape.guid+\"_polygon\");\n        if (!polygon) {\n            polygon = document.createElementNS(\"http://www.w3.org/2000/svg\",\"path\");\n            if (svg) {\n                svg.appendChild(polygon)\n            }\n        }\n        polygon.setAttribute(\"d\",this.getPolygonPath(shape));\n        polygon.setAttribute(\"fill-rule\",\"evenodd\");\n        polygon.setAttribute(\"shape_id\", shape.options.id);\n        polygon.setAttribute(\"shape_guid\",shape.guid);\n        polygon.id = \"p\"+shape.guid+\"_polygon\";\n        this.setupPolygonFill(shape,polygon);\n        this.setupPolygonStyles(shape,polygon);\n        if (svg.querySelector(\"#f\"+shape.guid+\"_filter\")) {\n            polygon.style.filter ='url(\"#f'+shape.guid+'_filter\")';\n        }\n        polygon.style.zIndex = shape.options.zIndex;\n        shape.polygon = polygon;\n    }\n\n    /**\n     * @ignore\n     * Returns a path string for \"d\" attribute of <path> tag for specified shape\n     * @param shape {SmartShape} Shape to return path to\n     * @returns {string}\n     */\n    this.getPolygonPath = (shape) => {\n        const parent = shape.getParent();\n        if (parent && parent.options.groupChildShapes) {\n            const pos = parent.getPosition(parent.options.groupChildShapes);\n            let path = this.getPolygonPathForShape(shape,pos,this.getMaxStrokeWidth(parent));\n            if (shape.options.displayAsPath && shape.options.groupChildShapes) {\n                shape.getChildren().forEach(child => {\n                    child.calcPosition();\n                    path += this.getPolygonPathForShape(child, pos, this.getMaxStrokeWidth(child));\n                })\n            }\n            return path;\n        } else {\n            const pos = shape.getPosition(shape.options.groupChildShapes);\n            let path = this.getPolygonPathForShape(shape,pos,this.getMaxStrokeWidth(shape));\n            if (shape.options.displayAsPath && shape.options.groupChildShapes) {\n                shape.getChildren().forEach(child => {\n                    child.calcPosition();\n                    path += this.getPolygonPathForShape(child,pos,this.getMaxStrokeWidth(child));\n                })\n                const svg = this.getShapeSvg(shape);\n                svg.setAttribute(\"width\",pos.width);\n                svg.setAttribute(\"height\",pos.height);\n                this.createSVGFilters(shape);\n            }\n            return path\n        }\n    }\n\n    /**\n     * @ignore\n     * Returns path string for specified shape, taking to account the 'stroke-width' SVG argument\n     * @param shape {SmartShape} Shape to get polygon for\n     * @param pos {object} Dimensions of shape. Object with fields `left`,`top`,`bottom`,`right`\n     * @param size {number} The size of stroke, used to draw this shape\n     * @returns {string} Path of points for polygon\n     */\n    this.getPolygonPathForShape = (shape,pos,size) => {\n        return \"M \"+shape.points\n            .map(point => {\n                let x = point.x - pos.left;\n                let y = point.y - pos.top;\n                if (x<=0) {\n                    x += size\n                } else if (point.x>=pos.right) {\n                    x -= size;\n                }\n                if (y<=0) {\n                    y += size\n                } else if (point.y>=pos.bottom) {\n                    y -= size;\n                }\n                return \"\"+x+\",\"+y\n            })\n            .join(\" \")+\" Z\";\n    }\n    /**\n     * @ignore\n     * If shape scaling feature is enabled, this method\n     * redraws [ResizeBox](#ResizeBox) around it after redrawing the shape\n     * @param shape {SmartShape} Shape object\n     */\n    this.redrawResizeBox = (shape) => {\n        if (shape.options.displayMode !== SmartShapeDisplayMode.SCALE || !shape.options.canScale) {\n            if (shape.resizeBox) {\n                shape.resizeBox.hide();\n            }\n            return\n        }\n        if (!shape.resizeBox) {\n            shape.setupResizeBox();\n            if (shape.resizeBox) {\n                shape.resizeBox.shape.points.forEach(point => {\n                    point.options.zIndex = shape.options.zIndex + 2;\n                    point.element.style.zIndex = shape.options.zIndex + 2;\n                })\n            }\n            return\n        }\n        const bounds = shape.getResizeBoxBounds();\n        if (shape.options.displayMode === SmartShapeDisplayMode.SCALE) {\n            shape.resizeBox.options.shapeOptions.visible = shape.options.visible;\n        }\n        shape.resizeBox.left = bounds.left;\n        shape.resizeBox.top = bounds.top;\n        shape.resizeBox.width = bounds.width;\n        shape.resizeBox.height = bounds.height;\n        shape.resizeBox.options.zIndex = shape.options.zIndex+1;\n        shape.resizeBox.redraw();\n        shape.resizeBox.shape.points.forEach(point => {\n            point.options.zIndex = shape.options.zIndex+2;\n            point.element.style.zIndex = shape.options.zIndex+2;\n        })\n    }\n\n    /**\n     * @ignore\n     * If shape rotation feature is enabled, this method\n     * redraws [RotateBox](#RotateBox) around it after redrawing the shape\n     * @param shape {SmartShape} Shape object\n     */\n    this.redrawRotateBox = (shape) => {\n        if (shape.options.displayMode !== SmartShapeDisplayMode.ROTATE || !shape.options.canRotate) {\n            if (shape.rotateBox) {\n                shape.rotateBox.hide();\n            }\n            return\n        }\n        if (!shape.rotateBox) {\n            shape.setupRotateBox();\n            if (shape.rotateBox) {\n                shape.rotateBox.shape.points.forEach(point => {\n                    point.options.zIndex = shape.options.zIndex + 2;\n                    point.element.style.zIndex = shape.options.zIndex + 2;\n                })\n            }\n            return\n        }\n        const bounds = shape.getResizeBoxBounds();\n        if (shape.options.displayMode === SmartShapeDisplayMode.ROTATE) {\n            shape.rotateBox.options.shapeOptions.visible = shape.options.visible;\n        } else {\n            shape.rotateBox.options.shapeOptions.visible = false;\n        }\n        shape.rotateBox.left = bounds.left;\n        shape.rotateBox.top = bounds.top;\n        shape.rotateBox.width = bounds.width;\n        shape.rotateBox.height = bounds.height;\n        shape.rotateBox.options.zIndex = shape.options.zIndex+1;\n        shape.rotateBox.redraw();\n        shape.rotateBox.shape.points.forEach(point => {\n            point.options.zIndex = shape.options.zIndex+2;\n            point.element.style.zIndex = shape.options.zIndex+2;\n        })\n    }\n\n    /**\n     * @ignore\n     * Used to setup fill of shape depending on provided options: color fill, gradient fill or image fill\n     * @param shape {SmartShape} Shape for which gradient should be created\n     */\n    this.setupShapeFill = (shape) => {\n        const fill = shape.options.style.fill || 'none';\n        if (fill === \"#image\" && shape.options.fillImage && typeof(shape.options.fillImage) === \"object\") {\n            this.createImageFill(shape);\n        } else if (fill === \"#gradient\" && shape.options.fillGradient && typeof(shape.options.fillGradient) === \"object\" &&\n            [\"linear\",\"radial\"].indexOf(shape.options.fillGradient.type) !== -1) {\n            this.createGradient(shape);\n        }\n    }\n\n    /**\n     * @ignore\n     * Method, used to create gradient fill for shape, if `options.fillGradient` specified.\n     * Triggered automatically when redraw the shape. Should not be called directly.\n     * @param shape {SmartShape} Shape for which gradient should be created\n     * equal to `linear` or `radial`. Accepts all options, that SVG linear gradient or SVG radial gradient accept.\n     * @returns {HTMLOrSVGElement} SVG element that defines gradient: either `linearGradient` or\n     * `radialGradient`. See: https://developer.mozilla.org/en-US/docs/Web/SVG/Element/linearGradient\n     */\n    this.createGradient = (shape) => {\n        const gradientOptions = shape.options.fillGradient;\n        const svg = this.getShapeSvg(shape);\n        let gradient = svg.querySelector(\"#g\"+shape.guid+\"_gradient\");\n        let gradientTag = gradientOptions.type === \"linear\" ? \"linearGradient\" : \"radialGradient\";\n        if (gradient) {\n            if (gradient.tagName.toLowerCase() !== gradientTag.toLowerCase()) {\n                gradient.parentNode.removeChild(gradient);\n            }\n        } else {\n            gradient = document.createElementNS(svg.namespaceURI,gradientTag);\n            if (svg) {\n                svg.querySelector('defs').appendChild(gradient);\n            }\n        }\n        gradient.innerHTML = \"\";\n        gradient.id = \"g\"+shape.guid+\"_gradient\";\n        let foundSteps = false;\n        for (let index in gradientOptions) {\n            if (index === \"type\") { continue }\n            if (index === \"steps\") {\n                foundSteps = true;\n                continue;\n            }\n            gradient.setAttribute(index,gradientOptions[index])\n        }\n        if (!foundSteps) {\n            return gradient;\n        }\n        for (let step of gradientOptions.steps) {\n            const stepNode = document.createElementNS(svg.namespaceURI,\"stop\");\n            if (notNull(step.stopColor)) {\n                stepNode.setAttribute(\"offset\", step.offset);\n            }\n            if (notNull(step.stopColor)) {\n                stepNode.setAttribute(\"stop-color\", step.stopColor);\n            }\n            if (notNull(step.stopOpacity)) {\n                stepNode.setAttribute(\"stop-opacity\", step.stopOpacity);\n            }\n            gradient.appendChild(stepNode);\n        }\n        return gradient;\n    }\n\n    /**\n     * @ignore\n     * Method used to construct SVG pattern to fill the shape with an image. Consists of\n     * `pattern` SVG node:\n     * https://developer.mozilla.org/en-US/docs/Web/SVG/Element/pattern.\n     * and `image` SVG node inside it.\n     * https://developer.mozilla.org/en-US/docs/Web/SVG/Element/image\n     * Triggered automatically when redraw the shape, if `options.fillImage` specified.\n     * Should not be called directly.\n     * @param shape {object} Shape for which image fill should be created\n     * @returns {HTMLOrSVGElement} Constructed `pattern` SVG tag or null, in case of errors\n     */\n    this.createImageFill = (shape) => {\n        const imageFillOptions = shape.options.fillImage;\n        if (!imageFillOptions.href || !imageFillOptions.width || !imageFillOptions.height) {\n            console.error(\"Image HREF, width and height must be specified for Image Fill\");\n            return null;\n        }\n        const svg = this.getShapeSvg(shape);\n        let pattern = svg.querySelector(\"p\"+shape.guid+\"_pattern\");\n        if (!pattern) {\n            pattern = document.createElementNS(svg.namespaceURI, \"pattern\");\n            pattern.setAttribute(\"id\",\"p\"+shape.guid+\"_pattern\");\n            pattern.setAttribute(\"patternUnits\",\"userSpaceOnUse\");\n            if (svg) {\n                svg.querySelector(\"defs\").appendChild(pattern);\n            }\n        }\n        for (let index in imageFillOptions) {\n            if (index === \"href\") {\n                continue;\n            }\n            pattern.setAttribute(index,imageFillOptions[index])\n        }\n        let image = pattern.querySelector(\"image\");\n        if (!image) {\n            image = document.createElementNS(svg.namespaceURI, \"image\");\n            pattern.appendChild(image);\n        }\n        if (imageFillOptions.href) {\n            image.setAttribute(\"href\", imageFillOptions.href);\n        }\n        image.setAttribute(\"width\",imageFillOptions.width);\n        image.setAttribute(\"height\",imageFillOptions.height);\n        return pattern;\n    }\n\n    /**\n     * @ignore\n     * Method used to apply SVG filter to the shape, if `filters` options specified in\n     * options of SmartShape.\n     * @param shape {SmartShape} shape object to apply filter to\n     * @returns {SVGFilterElement} Constructed filter element with set of filters\n     */\n    this.createSVGFilters = (shape) => {\n        if (!shape.options.filters || typeof(shape.options.filters) !== \"object\" || !Object.keys(shape.options.filters).length) {\n            return\n        }\n        const svg = this.getShapeSvg(shape);\n        let filters = svg.querySelector(\"#f\"+shape.guid+\"_filter\");\n        if (!filters) {\n            filters = document.createElementNS(svg.namespaceURI,\"filter\");\n            if (svg) {\n               svg.querySelector(\"defs\").append(filters);\n            }\n        }\n        filters.setAttribute(\"id\",\"f\"+shape.guid+\"_filter\");\n        filters.innerHTML = \"\";\n        for (let filterName in shape.options.filters) {\n            const filter = this.createSVGFilter(shape,filterName,shape.options.filters[filterName]);\n            if (filter) {\n                filters.appendChild(filter);\n            }\n        }\n    }\n\n    /**\n     * @ignore\n     * Method constructs individual SVG filter tag with specified name and options\n     * that will be added to the <filter> tag of shape's SVG.\n     * @param shape {SmartShape} shape object to apply filter ot\n     * @param filterName {string} name of SVG filter (feDropShadow, feGaussianBlur etc.)\n     * @param filterOptions {object} attributes of filter (any attributes that appropriate SVG filter tag accepts)\n     * @returns {SVGElement} Constructed filter element\n     */\n    this.createSVGFilter = (shape,filterName,filterOptions) => {\n        if (!shape.svg) {\n            return null;\n        }\n        const filter = document.createElementNS(shape.svg.namespaceURI,filterName);\n        const svg = this.getShapeSvg(shape);\n        const pos = shape.getPosition(shape.options.groupChildShapes);\n        for (let attribute in filterOptions) {\n            filter.setAttribute(attribute,filterOptions[attribute].toString());\n            if (attribute === \"dx\") {\n                svg.setAttribute(\"width\",(pos.width + parseInt(filterOptions[\"dx\"])*2).toString());\n            }\n            if (attribute === \"dy\") {\n                svg.setAttribute(\"height\",(pos.height + parseInt(filterOptions[\"dy\"])*2).toString());\n            }\n        }\n        return filter;\n    }\n\n    /**\n     * @ignore\n     * Method used to set up fill params of shape polygon\n     * @param shape {SmartShape} Shape object\n     * @param polygon {SVGPolygonElement} Polygon element to setup\n     */\n    this.setupPolygonFill = (shape, polygon) => {\n        const fill = shape.options.style.fill || \"none\";\n        if (fill === \"#image\" && shape.options.fillImage && typeof(shape.options.fillImage) === \"object\") {\n            polygon.setAttribute(\"fill\",'url(\"#p'+shape.guid+'_pattern'+'\")');\n        }  else if (fill === \"#gradient\" && shape.options.fillGradient && typeof(shape.options.fillGradient) === \"object\" &&\n            [\"linear\",\"radial\"].indexOf(shape.options.fillGradient.type) !== -1) {\n            polygon.setAttribute(\"fill\",'url(\"#g'+shape.guid+'_gradient'+'\")');\n        }\n    }\n\n    /**\n     * @ignore\n     * Method used to apply provided CSS classes and styles to SVG polygon\n     * @param shape {SmartShape} Shape object\n     * @param polygon {SVGPolygonElement} Polygon element to se tup\n     */\n    this.setupPolygonStyles = (shape, polygon) => {\n        if (shape.options.classes) {\n            polygon.setAttribute(\"class\",shape.options.classes);\n        }\n        if (!notNull(shape.options.style) || typeof(shape.options.style) !== \"object\") {\n            return;\n        }\n        for (let cssName in shape.options.style) {\n            polygon.style[cssName] = shape.options.style[cssName]\n        }\n    }\n\n    /**\n     * @ignore\n     * Method used to return shape as an SVG string.\n     * @param shape {SmartShape} Shape object\n     * @param includeChildren {boolean|null} Should include children of this shape to output.\n     * 'null' by default. In this case value of shape.options.groupChildShapes will be used\n     * @returns {string} String body of SVG document\n     */\n    this.toSvg = (shape,includeChildren=null) => {\n        const div = document.createElement(\"div\");\n        const svg = this.getSvg(shape,includeChildren);\n        div.appendChild(svg);\n        return '<?xml version=\"1.0\" encoding=\"UTF-8\"?>'+div.innerHTML.replace(/&quot;/g,\"'\");\n    }\n\n    /**\n     * @ignore\n     * Method used to return shape as an SVG document.\n     * @param shape {SmartShape} Shape object\n     * @param includeChildren {boolean|null} Should include children of this shape to output.\n     * 'null' by default. In this case value of shape.options.groupChildShapes will be used\n     * @returns {string} String body of SVG document\n     */\n    this.getSvg = (shape,includeChildren) => {\n        let groupChanged = false;\n        let pathChanged = false;\n        let svg = shape.svg;\n        if (!svg) {\n            const parent = shape.getParent();\n            if (parent) {\n                svg = parent.svg;\n            }\n        }\n        if (!svg) {\n            return\n        }\n        svg = svg.cloneNode(true);\n        if (includeChildren) {\n            shape = shape.getParent() || shape;\n            if (!shape.options.groupChildShapes) {\n                shape.options.groupChildShapes = true;\n                groupChanged = true;\n            }\n            if (!shape.options.displayAsPath) {\n                shape.getChildren(true).forEach(child => {\n                    this.drawPolygon(child, svg);\n                })\n            }\n            this.drawPolygon(shape,svg);\n            let paths = Array.from(svg.querySelectorAll(\"path\"));\n            paths.sort((p1,p2) => parseInt(p1.style.zIndex)-parseInt(p2.style.zIndex));\n            const defs = svg.querySelector(\"defs\");\n            svg.innerHTML = \"\";\n            svg.appendChild(defs);\n            paths.forEach(path=>svg.appendChild(path));\n        }\n        svg.removeAttribute(\"style\");\n        svg.removeAttribute(\"width\");\n        svg.removeAttribute(\"height\");\n        svg.removeAttribute(\"id\");\n        svg.removeAttribute(\"guid\");\n        const pos = shape.getPosition(includeChildren === null ? shape.options.groupChildShapes : includeChildren);\n        svg.setAttribute(\"xmlns\",\"http://www.w3.org/2000/svg\")\n        const zoom = shape.options.zoomLevel || 1;\n        const viewBox = \"0 0 \" + pos.width/zoom + \" \" + pos.height/zoom;\n        svg.setAttribute(\"viewBox\",viewBox);\n        if (groupChanged) {\n            shape.options.groupChildShapes = false;\n        }\n        if (pathChanged) {\n            shape.options.displayAsPath = false;\n        }\n        if (shape.options.zoomLevel !== 1) {\n            svg.querySelectorAll(\"path\").forEach(path => {\n                let result = \"\";\n                const d = path.getAttribute(\"d\").split(\" \")\n                for (let item of d) {\n                    if (item.search(\",\") === -1) {\n                        result += item + \" \"\n                    } else {\n                        const parts = item.split(\",\");\n                        result += (parseFloat(parts[0])/zoom)+\",\"+(parseFloat(parts[1])/zoom)+\" \"\n                    }\n                }\n                path.setAttribute(\"d\",result);\n            })\n        }\n        return svg;\n    }\n\n    /**\n     * @ignore\n     * Method returns maximal stroke width of this shape or its children\n     * @param shape {SmartShape} Shape to return stroke width for\n     * @returns {number|*}\n     */\n    this.getMaxStrokeWidth = (shape) => {\n        const svg = this.getShapeSvg(shape);\n        if (!svg) {\n            return 0;\n        }\n        let width = parseInt(shape.options.style[\"stroke-width\"]);\n        if (isNaN(width)) {\n            width = 0;\n        }\n        if (!shape.options.groupChildShapes) {\n            return width;\n        }\n        return shape.getChildren(true)\n                .map(child => isNaN(parseInt(child.options.style[\"stroke-width\"])) ? 0 : parseInt(child.options.style[\"stroke-width\"]))\n                .reduce((w1,w2) => w1 > w2 ? w1 : w2,width)\n    }\n\n    /**\n     * @ignore\n     * Method exports shape and all its children as a PNG image\n     * @param {SmartShape} shape Shape object to export\n     * @param {PngExportTypes} type Format of returned result - `dataurl` or `blob`. By default `dataurl`\n     * @param {number|null} width Width of image. If not specified, then calculate based on height or current\n     * width of shape\n     * @param {number|null} height Height of image. If not specified, then calculate based on width or current\n     * height of shape\n     * @param includeChildren {boolean} Should include children of this shape to output.\n     * 'null' by default. In this case value of shape.options.groupChildShapes will be used*\n     * @return {Promise} Promise that resolves either to DataURL string or to BLOB object, depending on value of\n     * `type` argument\n     */\n    this.toPng = (shape,type= PngExportTypes.DATAURL,width=null,height=null, includeChildren=null) => {\n        return new Promise(async(resolve) => {\n            shape.calcPosition();\n            const zoom = shape.options.zoomLevel || 1;\n            const pos = shape.getPosition(includeChildren || shape.options.groupChildShapes);\n            [width, height] = applyAspectRatio(width, height, pos.width/zoom, pos.height/zoom);\n            const svgObj = this.getSvg(shape,includeChildren);\n            svgObj.setAttribute(\"width\", pos.width/zoom);\n            svgObj.setAttribute(\"height\", pos.height/zoom);\n            for (let item of svgObj.querySelectorAll(\"image\")) {\n                if (item.getAttribute(\"href\") && item.getAttribute(\"href\").length) {\n                    const href = await blobToDataURL(await (await fetch(item.getAttribute(\"href\"))).blob());\n                    item.setAttribute(\"href\",href);\n                }\n            }\n            const div = document.createElement(\"div\");\n            div.appendChild(svgObj);\n            const svgString = div.innerHTML;\n            const img = new Image();\n            const svg = new Blob([svgString],{type:\"image/svg+xml\"});\n            const DOMURL = window.URL || window.webkitURL || window;\n            const url = await blobToDataURL(svg);\n            img.addEventListener(\"load\", () => {\n                const canvas = document.createElement(\"canvas\");\n                img.width = pos.width/zoom;\n                img.height = pos.height/zoom;\n                canvas.width = img.width;\n                canvas.height = img.height;\n                const ctx = canvas.getContext(\"2d\");\n                ctx.drawImage(img,0,0)\n                ctx.scale(width,height);\n                DOMURL.revokeObjectURL(url);\n                const result = canvas.toDataURL(\"image/png\");\n                if (type === PngExportTypes.BLOB) {\n                    resolve(dataURLtoBlob(result));\n                    return\n                }\n                resolve(result)\n            })\n            img.src = url;\n        })\n    }\n\n    /**\n     * @ignore\n     * Method used to change shape zIndex to topmost\n     * @param shape {SmartShape} shape object\n     */\n    this.moveShapeToTop = (shape) => {\n        const zIndex = SmartShapeManager.getMaxZIndex(shape.root);\n        if (shape.options.zIndex === zIndex && SmartShapeManager.findShapesByOptionValue(\"zIndex\",zIndex).length === 1) {\n            return\n        }\n        this.changeShapeZIndex(shape,zIndex+1);\n    }\n\n    /**\n     * @ignore\n     * Method used to change shape zIndex to topmost\n     * @param shape {SmartShape} shape object\n     */\n    this.moveShapeToBottom = (shape) => {\n        const zIndex = SmartShapeManager.getMinZIndex(shape.root);\n        if (shape.options.zIndex === zIndex && SmartShapeManager.findShapesByOptionValue(\"zIndex\",zIndex).length === 1) {\n            return\n        }\n        this.changeShapeZIndex(shape,zIndex-1);\n    }\n\n    /**\n     * @ignore\n     * Method used to change shape zIndex to specified\n     * @param shape {SmartShape} shape object\n     * @param zIndex {number} zIndex value\n     */\n    this.changeShapeZIndex = (shape,zIndex) => {\n        if (zIndex === shape.options.zIndex) {\n            return\n        }\n        const diff = zIndex - shape.options.zIndex;\n        shape.options.prevZIndex = shape.options.zIndex;\n        shape.options.zIndex += diff;\n        this.updateOptions(shape);\n        if (shape.options.groupChildShapes) {\n            shape.getChildren(true).forEach(child => {\n                child.options.prevZIndex = child.options.zIndex;\n                child.options.zIndex += diff;\n                this.updateOptions(child);\n            });\n        }\n    }\n\n    /**\n     * @ignore\n     * Internal method that used to return SVG element to which this shape belongs\n     * If this is a root shape, then just returns svg of current shape object,\n     * if it's a child, then SVG element of the parent\n     * @param shape {SmartShape} Shape to return SVG element for\n     * @returns {HTMLOrSVGElement|null|*}\n     */\n    this.getShapeSvg = (shape) => {\n        const parent = shape.getRootParent(true);\n        if (parent && parent.svg) {\n            return parent.svg\n        }\n        return shape.svg;\n    }\n\n    /**\n     * @ignore\n     * Method used to correct order of items of SVG shape according to Z-Index CSS style\n     * @param shape {SmartShape} Shape to correct\n     */\n    this.setupZIndex = (shape) => {\n        if (!shape.svg) {\n            return\n        }\n        let paths = Array.from(shape.svg.querySelectorAll(\"path\"));\n        paths.sort((p1,p2) => parseInt(p1.style.zIndex)-parseInt(p2.style.zIndex));\n        const defs = shape.svg.querySelector(\"defs\");\n        shape.svg.innerHTML = \"\";\n        shape.svg.appendChild(defs);\n        paths.forEach(path=>shape.svg.appendChild(path));\n    }\n}\n\n/**\n * Enumeration of PNG export types for SmartShape.toPng() function\n * @param dataurl Return PNG as a DataURL string\n * @param blob Return PNG as a BLOB object\n * @enum {string}\n */\nexport const PngExportTypes = {\n    DATAURL: \"dataurl\",\n    BLOB: \"blob\"\n}\n\nexport default new SmartShapeDrawHelper();\n","import {mergeObjects, notNull} from \"../utils/index.js\";\nimport SmartShapeManager from \"./SmartShapeManager.js\";\n\n/**\n * @ignore\n * Method used to import collection of shapes from JSON array in GeoJSON format: https://geojson.org/\n * @param container {HTMLElement} The HTML element to connect loaded shapes\n * @param geoJSON {object} Javascript object in geoJSON format\n * @param options {object} Options to tune the import process:\n * `idField`: the field from \"properties collection of GeoJSON object that used as a shape ID,\n * `nameField`: the field from \"properties\" collection of GeoJSON object that used as a shape name,\n * `width`: the width to which loaded shapes should be scaled (if not specified then calc automatically based on height),\n * `height`: the height to which loaded shapes should be scaled (if not specified then calc automatically based on width),\n * `scale`: scaling factor to which loaded shapes should be scaled (if not specified, width and height used,\n * if nothing specified, then scales to 200px width if natural width is less than this)\n * `options`: shape options [SmartShape.options](#SmartShape+options) to set to each shape after import\n * `fields`: which other fields to import from GeoJSON, in addition to `idField` and `nameField`\n * @param progressCallback {function} Function that executes after loading each shape from file. If specified, it will\n * be executed with three arguments: `currentShapeIndex` - index of current processed shape, `totalShapesLength` - total\n * number of shapes in the collection, shape - SmartShape object of currently processed shape.\n * @returns {array} Array of SmartShape objects\n */\nexport const fromGeoJSON = (container,geoJSON, options={}, progressCallback=null) => {\n    if (!notNull(geoJSON) || typeof(geoJSON) !== \"object\") {\n        return null;\n    }\n    if (!notNull(geoJSON.features)) {\n        geoJSON = {features:[geoJSON]}\n    }\n    if (!geoJSON.features.length) {\n        return null\n    }\n    const result = [];\n    for (let index in geoJSON.features) {\n        const obj = geoJSON.features[index];\n        const shape = createShapeFromGeoJson(obj,index,options,container);\n        if (progressCallback && typeof(progressCallback) === \"function\") {\n            progressCallback(index,geoJSON.features.length,shape);\n        }\n        if (shape) {\n            result.push(shape);\n        }\n    }\n    return result.length === 1 ? result[0] : result;\n}\n\nconst createShapeFromGeoJson = (obj, index, importOptions, container) => {\n    if (!isCorrectJSON(obj)) {\n        return;\n    }\n    let options = loadOptions(obj,index,importOptions);\n    options.visible = false;\n    const polygons = loadPolygons(obj);\n    if (!polygons || !polygons.length) {\n        return\n    }\n    polygons.sort((p1,p2) => p2.dims.width*p2.dims.height - p1.dims.width * p1.dims.height)\n    let shape = null;\n    for (let idx in polygons) {\n        const shapeOpts = mergeObjects({},options);\n        if (idx==0) {\n            if (importOptions.onlyData) {\n                shape = {\n                    points:   polygons[idx].cords,\n                    options:  shapeOpts,\n                    children: [],\n                    ...polygons[idx].dims\n                }\n            } else {\n                shape = SmartShapeManager.createShape(container,shapeOpts,polygons[idx].cords,false)\n                shape.left = polygons[idx].dims.left;\n                shape.top = polygons[idx].dims.top;\n                shape.right = polygons[idx].dims.right;\n                shape.bottom = polygons[idx].dims.bottom;\n                shape.width = polygons[idx].dims.width;\n                shape.height = polygons[idx].dims.height;\n            }\n        } else {\n            shapeOpts.id += \"_\" + idx;\n            shapeOpts.name += \" \" + idx;\n            if (importOptions.onlyData) {\n                shape.children.push({\n                    points: polygons[idx].cords,\n                    options:shapeOpts,\n                    ...polygons[idx].dims\n                })\n            } else {\n                const child = SmartShapeManager.createShape(container,shapeOpts,polygons[idx].cords);\n                child.left = polygons[idx].dims.left;\n                child.top = polygons[idx].dims.top;\n                child.right = polygons[idx].dims.right;\n                child.bottom = polygons[idx].dims.bottom;\n                child.width = polygons[idx].dims.width;\n                child.height = polygons[idx].dims.height;\n                shape.addChild(child, false)\n            }\n        }\n    }\n    if (importOptions.onlyData) {\n        return shape;\n    }\n    if (notNull(importOptions.scale)) {\n        shape.scaleBy(importOptions.scale,importOptions.scale,true);\n    } else if (notNull(importOptions.width) || notNull(importOptions.height)) {\n        shape.scaleTo(importOptions.width,importOptions.height)\n    }\n    return shape;\n}\n\nconst isCorrectJSON = (obj) => {\n    if (!notNull(obj.properties) || typeof(obj.properties) !== \"object\") {\n        return false\n    }\n    const geometry = obj.geometry;\n    if (!notNull(geometry) || typeof(geometry) !== \"object\") {\n        return false;\n    }\n    if ([\"Polygon\",\"MultiPolygon\"].indexOf(geometry.type) === -1) {\n        return false;\n    }\n    if (!notNull(geometry.coordinates) ||\n        typeof(geometry.coordinates) !== \"object\" ||\n        !geometry.coordinates.length) {\n        return false;\n    }\n    return true;\n}\n\nconst loadOptions = (obj,index,importOptions) => {\n    const result = {};\n    result.name = obj.properties[importOptions.nameField] || \"Shape \"+ index;\n    result.id = obj.properties[importOptions.idField] || \"shape_\" + index;\n    if (notNull(importOptions.fields) && typeof(importOptions.fields) === \"object\") {\n        importOptions.fields\n            .filter(fieldName => notNull(obj.properties[fieldName]))\n            .forEach(fieldName => result[fieldName] = obj.properties[fieldName])\n    }\n    if (notNull(importOptions.options) && typeof(importOptions.options) === \"object\") {\n        for (let id in importOptions.options) {\n            result[id] = importOptions.options[id];\n        }\n    }\n    return result;\n}\n\nconst loadPolygons = (obj) => {\n    let polygons = obj.geometry.coordinates;\n    if (obj.geometry.type === \"Polygon\") {\n        polygons = [polygons];\n    }\n    const result = [];\n    for (let _polygon of polygons) {\n        const polygon = _polygon[0];\n        const cords = [];\n        let left=Infinity,right=-Infinity,top=Infinity,bottom=-Infinity;\n        for (let point of polygon) {\n            const [x,y] = [point[0],-point[1]];\n            if (x<left) {\n                left = x;\n            }\n            if (x>right) {\n                right = x;\n            }\n            if (y<top) {\n                top = y;\n            }\n            if (y>bottom) {\n                bottom = y;\n            }\n            cords.push({x,y})\n        }\n        result.push({cords,dims:{left,top,bottom,right,width:right-left,height:bottom-top}});\n    }\n    return result;\n}\n\nconst getDecimalLength = (number) => {\n    let parts = number.toString().split(\".\");\n    if (parts[1]) {\n        return parts[1].length\n    }\n    return 0\n}\n","import EventsManager from \"../events/EventsManager.js\";\nimport {ShapeEvents} from \"../SmartShape/SmartShapeEventListener.js\";\nimport {notNull, readJSON} from \"../utils/index.js\";\nimport SmartShape,{SmartShapeDisplayMode} from \"../SmartShape/SmartShape.js\";\nimport {PointEvents} from \"../SmartPoint/SmartPoint.js\";\nimport SmartShapeDrawHelper from \"../SmartShape/SmartShapeDrawHelper.js\";\nimport {createEvent, getMouseCursorPos} from \"../events/functions.js\";\nimport {fromGeoJSON} from \"./GeoJSONImport.js\";\nimport {ResizeBoxEvents} from \"../ResizeBox/ResizeBoxEventListener.js\";\n\n/**\n * Object that keeps collection of shapes and keep track of\n * their activity. This object is instantiated automatically by\n * when first shape created. Then it listens lifecycle events of shapes\n * to keep their collection, correctly switch activity status and\n * handle other global events related to shapes and their containers\n * @constructor\n */\nfunction SmartShapeManager() {\n\n    /**\n     * Collection of [SmartShape's](#SmartShape) objects.\n     * Each object indexed by GUID\n     * @type {object}\n     */\n    this.shapes = {};\n\n    /** Collection of [SmartShape's](#smartShape) objects\n     * that are visible now. Each object indexed by GUID\n     * @type {object}\n     */\n    this.visibleShapes = {};\n\n    /**\n     * Which shape is currently selected\n     * @type {SmartShape}\n     */\n    this.activeShape = null;\n\n    /**\n     * Which shape user is currently dragging\n     * @type {SmartShape}\n     */\n    this.draggedShape = null;\n\n    /**\n     * The shape under mouse cursor\n     * @type {SmartShape}\n     */\n    this.shapeOnCursor = null;\n\n    /**\n     * List of event listeners, attached to containers of shapes in format\n     * {container: DOM-link to container, name: name of event, listener: handler function}\n     * @type {array}\n     */\n    this.containerEventListeners = [];\n\n    /**\n     * @ignore\n     * Initializes the object.\n     * @returns {SmartShapeManager}\n     */\n    this.init = () => {\n        this.setEventListeners();\n        return this;\n    }\n\n    /**\n     * @ignore\n     * Add listeners to key shapes events, that required to intercept\n     * to correctly maintain the list of shapes and their activities\n     */\n    this.setEventListeners = () => {\n        EventsManager.subscribe(ShapeEvents.SHAPE_CREATE,this.onShapeCreated);\n        EventsManager.subscribe(ShapeEvents.SHAPE_DESTROY,this.onShapeDestroy);\n        EventsManager.subscribe(ShapeEvents.SHAPE_SHOW, this.onShapeShow);\n        EventsManager.subscribe(ShapeEvents.SHAPE_HIDE, this.onShapeHide);\n        EventsManager.subscribe(ShapeEvents.SHAPE_MOVE_START, this.onShapeMoveStart);\n        EventsManager.subscribe(ShapeEvents.SHAPE_MOUSE_ENTER, this.onShapeMouseEnter);\n        EventsManager.subscribe(PointEvents.POINT_DRAG_START, this.onPointDragStart);\n        EventsManager.subscribe(PointEvents.POINT_DRAG_END, this.onPointDragEnd);\n        window.addEventListener(\"resize\", this.onWindowResize);\n    }\n\n    /**\n     * @ignore\n     * Internal method, triggered when browser window resized.\n     * @param _event Window resize event - [UIEvent](https://developer.mozilla.org/en-US/docs/Web/API/UIEvent).\n     */\n    this.onWindowResize = (_event) => {\n        for (let index in this.shapes) {\n            const shape = this.shapes[index];\n            EventsManager.emit(ContainerEvents.CONTAINER_BOUNDS_CHANGED,shape,\n                {bounds:shape.getBounds(),points:shape.points}\n            )\n        }\n    }\n\n    /**\n     * Method used to construct SmartShape object with specified `points` and\n     * with specified `options`.\n     * Then it binds this object to specified `root` HTML node and displays it\n     * @param root {HTMLElement} HTML DOM node af a container element\n     * @param options {object} Options object to construct this shape (See [SmartShape options](#SmartShape+options))\n     * @param points {array} 2D Array of points for shape polygon.\n     * Each element is [x,y] coordinate array\n     * @param show {boolean} Should display the shape by default. Default: true\n     * @returns {object} constructed SmartShape object\n     */\n    this.createShape = (root,options,points,show= true) => {\n        return new SmartShape().init(root, options, points, show)\n    }\n\n\n    /**\n     * @ignore\n     * Executed when new shape is created. Used to add the shape to the list\n     * and setup event listeners for container, to which this shape connected\n     * @param event {ShapeEvents.SHAPE_CREATE} Event object\n     */\n    this.onShapeCreated = (event) => {\n        const shape = event.target;\n        if (notNull(shape.root) && !this.getShape(shape) && typeof(shape.belongsToShape) === \"function\") {\n            this.addShape(shape);\n            if (!this.activeShape) {\n                this.activeShape = shape;\n            }\n        }\n    }\n\n    /**\n     * @ignore\n     * Internal method used to push shape to collection and connect\n     * event listeners to it container\n     * @param shape {SmartShape} Shape object to add\n     */\n    this.addShape = (shape) => {\n        this.shapes[shape.guid] = shape;\n        if (shape.options.visible && this.isNormalShape(shape)) {\n            this.visibleShapes[shape.guid] = shape;\n        }\n        if (this.getShapesByContainer(shape.root).length === 1) {\n            this.addContainerEvents(shape)\n        }\n    }\n\n    /**\n     * @ignore\n     * Executed when shape destroyed. Used to remove the shape from the list\n     * and remove all listeners, attached to the container of this shape\n     * if no other shapes attached to the same container\n     * @param event {ShapeEvents.SHAPE_DESTROY} Event object\n     */\n    this.onShapeDestroy = (event) => {\n        const shape = event.target;\n        delete this.shapes[shape.guid];\n        const root = shape.root;\n        if (!notNull(shape.root)) {\n            return\n        }\n        if (this.getShapesByContainer(root).length === 0) {\n            this.containerEventListeners\n                .filter(item => item.container === root)\n                .forEach(item => {\n                    item.container.removeEventListener(item.name,item.listener);\n                    this.containerEventListeners.splice(this.containerEventListeners.indexOf(item),1);\n                })\n        }\n    }\n\n    /**\n     * @ignore\n     * Shape show event handler\n     * @param event {ShapeEvents.SHAPE_SHOW} Event object with shape in event.target\n     */\n    this.onShapeShow = (event) => {\n        if (this.isNormalShape(event.target)) {\n            this.visibleShapes[event.target.guid] = event.target;\n        }\n    }\n\n    /**\n     * @ignore\n     * Shape show event handler\n     * @param event {ShapeEvents.SHAPE_HIDE} Event object with shape in event.target\n     */\n    this.onShapeHide = (event) => {\n        delete this.visibleShapes[event.target.guid]\n    }\n\n    /**\n     * @ignore\n     * Executed when user starts dragging the shape. Switches active shape to this one\n     * and also set this shape as a shape \"in a process of dragging\"\n     * @param event {ShapeEvents.SHAPE_MOVE_START} Event object\n     */\n    this.onShapeMoveStart = (event) => {\n        if (!this.getShapeByGuid(event.target.guid) || !event.target.options.managed) {\n            return\n        }\n        const parent = event.target.getRootParent(true);\n        if (parent && parent.options.groupChildShapes) {\n            this.activateShape(parent);\n            this.draggedShape = parent;\n        } else {\n            this.activateShape(event.target);\n            this.draggedShape = event.target;\n        }\n    }\n\n    /**\n     * @ignore\n     * Executed when mouse cursor enters the shape\n     * @param event {ShapeEvents.SHAPE_MOUSE_ENTER} Event object\n     */\n    this.onShapeMouseEnter = (event) => {\n        if (!this.draggedShape) {\n            return;\n        }\n        if (event.buttons !== 1) {\n            this.draggedShape.draggedPoint = null;\n        }\n    }\n\n    /**\n     * @ignore\n     * Executed when user starts dragging point of the shape.\n     * Sets the status of this point as a point that is being dragged\n     * @param event {PointEvents.POINT_DRAG_START} Event object\n     */\n    this.onPointDragStart = (event) => {\n        const shape = this.findShapeByPoint(event.target);\n        if (shape) {\n            this.draggedShape = shape;\n            const parent = shape.getRootParent(true);\n            if (parent && parent.options.groupChildShapes) {\n                this.draggedShape = parent;\n            }\n            this.draggedShape.draggedPoint = event.target;\n            EventsManager.emit(ShapeEvents.POINT_DRAG_START,shape,{point:event.target})\n        }\n    }\n\n    /**\n     * @ignore\n     * Executed when user ends dragging point in the shape.\n     * Clears \"dragging\" status of this point\n     * @param _event {PointEvents.POINT_DRAG_END} Event object\n     */\n    this.onPointDragEnd = (_event) => {\n        if (this.draggedShape) {\n            this.draggedShape.draggedPoint = null;\n        }\n        this.draggedShape = null;\n    }\n\n    /**\n     * @ignore\n     * Checks and returns the shape if it exists in the array of shapes\n     * or null.\n     * @param shape {SmartShape} The shape to check\n     * @returns {null|SmartShape}\n     */\n    this.getShape = (shape) => this.getShapeByGuid(shape.guid);\n\n    /**\n     * Method returns a shape to which specified point object belongs\n     * or null\n     * @param point {SmartPoint}\n     * @returns {null|SmartShape}\n     */\n    this.findShapeByPoint = (point) => {\n        for (let index in this.shapes) {\n            const shape = this.shapes[index];\n            if (shape.isShapePoint(point)) {\n                return shape\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Returns shape by GUID\n     * @param guid {string} GUID of shape\n     * @returns {null|SmartShape} The shape object\n     */\n    this.getShapeByGuid = (guid) => {\n        if (notNull(this.shapes[guid])) {\n            return this.shapes[guid]\n        } else {\n            return null\n        }\n    }\n\n    /**\n     * Returns an array of shapes that connected to specified DOM container\n     * @param container {HTMLElement} Link to container\n     * @returns {array} Array of [SmartShape](#SmartShape) objects\n     */\n    this.getShapesByContainer = (container) => {\n        const result = [];\n        for (let index in this.shapes) {\n            const shape = this.shapes[index];\n            if (this.isNormalShape(shape) && shape.root === container) {\n                result.push(shape);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Method returns zIndex of the topmost shape either in specified container or globally\n     * @param container {HTMLElement|null} Container to search in or null if search through all shapes\n     * @returns {number} zIndex of the topmost shape\n     */\n    this.getMaxZIndex = (container=null) => {\n        let shapes;\n        if (container) {\n            shapes = this.getShapesByContainer(container);\n        } else {\n            shapes = this.getShapes();\n        }\n        if (!shapes.length) {\n            return 0;\n        }\n        return parseInt(\n            shapes.map(shape=>shape.options.zIndex || 0).reduce((max,zIndex) => zIndex>max ? zIndex : max,0 )\n        );\n    }\n\n    /**\n     * Method returns zIndex of the bottommost shape either in specified container or globally\n     * @param container {HTMLElement|null} Container to search in or null if search through all shapes\n     * @returns {number} zIndex of the bottommost shape\n     */\n    this.getMinZIndex = (container=null) => {\n        let shapes;\n        if (container) {\n            shapes = this.getShapesByContainer(container);\n        } else {\n            shapes = this.getShapes();\n        }\n        if (!shapes.length) {\n            return 0;\n        }\n        return parseInt(\n            shapes.map(shape=>shape.options.zIndex || 0).reduce((min,zIndex) => zIndex<min ? zIndex : min ,999999)\n        );\n    }\n\n    /**\n     * Method returns an array of all registered shapes (excluding rotate and resize boxes around them)\n     * @returns {array} Array of [SmartShape)(#SmartShape) objects\n     */\n    this.getShapes = () => {\n        const result = [];\n        for (let index in this.shapes) {\n            const shape = this.shapes[index];\n            if (this.isNormalShape(shape)) {\n                result.push(shape)\n            }\n        }\n        return result\n    }\n\n    this.isNormalShape = (shape) => {\n        return shape.options.id.search(\"_resizebox\") === -1 &&\n            shape.options.id.search(\"_rotatebox\") === -1 &&\n            typeof(shape.belongsToShape) === \"function\";\n    }\n\n    /**\n     * Method used to make specified shape active and move it on top according to zIndex\n     * @param shape {SmartShape} Shape to activate\n     * @param displayMode {SmartShapeDisplayMode} In which mode to activate the shape (by default select next mode)\n     */\n    this.activateShape = (shape,displayMode=null) => {\n        if (this.activeShape === shape) {\n            this.activeShape.switchDisplayMode(displayMode);\n            if (shape.options.moveToTop) {\n                shape.moveToTop();\n            }\n            return;\n        }\n        if (typeof(shape.id) !== \"undefined\" &&\n            (shape.id.search(\"_resizebox\") !== -1 || shape.id.search(\"_rotatebox\") !== -1)) {\n            return\n        }\n        if (this.activeShape) {\n            this.deactivateShape(this.activeShape);\n        }\n        if (shape.options.moveToTop) {\n            shape.moveToTop();\n        }\n        this.activeShape = shape;\n        EventsManager.emit(ShapeEvents.SHAPE_ACTIVATED,this.activeShape);\n        this.activeShape.switchDisplayMode(displayMode);\n    }\n\n    /**\n     * @ignore\n     * Method used to deactivate specified shape and return it\n     * to the zIndex position, which it had before activation\n     * @param shape\n     */\n    this.deactivateShape = (shape) => {\n        if (typeof(shape.options.prevZIndex) !== \"undefined\") {\n            SmartShapeDrawHelper.updateOptions(shape);\n        }\n        if (shape.options.displayMode !== SmartShapeDisplayMode.DEFAULT) {\n            shape.switchDisplayMode(SmartShapeDisplayMode.DEFAULT);\n        }\n        if (!shape.options.groupChildShapes) {\n            return\n        }\n        shape.getChildren(true).forEach(child => {\n            if (typeof(child.options.prevZIndex) !== \"undefined\") {\n                SmartShapeDrawHelper.updateOptions(child);\n                if (child.options.displayMode !== SmartShapeDisplayMode.DEFAULT) {\n                    child.switchDisplayMode(SmartShapeDisplayMode.DEFAULT);\n                }\n            }\n        })\n    }\n\n    /**\n     * @ignore\n     * Method used to attach required event listeners to HTML container of specified shape\n     * Should run once for each container.\n     * @param shape {SmartShape} Smart shape object\n     */\n    this.addContainerEvents = (shape) => {\n        this.addContainerEvent(shape.root,\"mousemove\",this.mousemove);\n        this.addContainerEvent(shape.root,\"mouseup\",this.mouseup,shape.options.id)\n        this.addContainerEvent(shape.root,\"dblclick\",this.doubleclick);\n        this.addContainerEvent(shape.root,\"contextmenu\", this.contextmenu);\n        this.addContainerEvent(shape.root,\"mouseleave\", this.mouseleave);\n        EventsManager.emit(SmartShapeManagerEvents.MANAGER_ADD_CONTAINER_EVENT_LISTENERS,shape.root)\n    }\n\n    /**\n     * Method adds event handler of specified event of specified HTML container.\n     * @param container {object} Container\n     * @param eventName {string} Name of event\n     * @param handler {function} Event handling function\n     */\n    this.addContainerEvent = (container,eventName,handler) => {\n        if (this.containerEventListeners.find(event=>event.container === container && event.name === eventName)) {\n            return\n        }\n        container.addEventListener(eventName,handler);\n        this.containerEventListeners.push({id:container.id,container:container,name:eventName,listener:handler})\n    }\n\n    /**\n     * @ignore\n     * OnDblClick event handler, triggered when user double-clicks on shape or on shape container element\n     * @param event {MouseEvent} Event object\n     */\n    this.doubleclick = (event) => {\n        if (this.shapeOnCursor) {\n            this.shapeOnCursor.eventListener.doubleclick(createEvent(event,{target:this.shapeOnCursor}))\n        }\n        try {\n            event.stopPropagation();\n        } catch (err) {}\n        if (!this.activeShape || !this.activeShape.options.canAddPoints ||\n            this.activeShape.draggedPoint ||\n            this.activeShape.points.length>2 ||\n            this.activeShape.points.length === this.activeShape.options.maxPoints\n        ) {\n            return\n        }\n        if (this.activeShape.options.displayMode === SmartShapeDisplayMode.DEFAULT) {\n            this.activeShape.switchDisplayMode(SmartShapeDisplayMode.SELECTED);\n        }\n        const [x,y] = getMouseCursorPos(createEvent(event,{target:this.activeShape}));\n        this.activeShape.addPoint(x,y,{forceDisplay:false});\n    }\n\n    this.contextmenu = (event) => {\n        event.stopPropagation();\n        event.preventDefault();\n        if (this.shapeOnCursor) {\n            const menu = this.shapeOnCursor.shapeMenu\n            if (!menu) {\n                return\n            }\n            menu.contextMenu.origEvent = event;\n            menu.contextMenu.cursorX = event.pageX;\n            menu.contextMenu.cursorY = event.pageY;\n            menu.contextMenu.show();\n        }\n    }\n\n    /**\n     * @ignore\n     * onMouseDown event handler for shape's container. If cursor points on some shape,\n     * forwards this event to this shape.\n     * @param event {MouseEvent} Mouse down event\n     */\n    this.mousedown = (event) => {\n        if (this.shapeOnCursor && event.buttons !== 2) {\n            const parent = this.shapeOnCursor.getRootParent(true);\n            if (parent && parent.options.groupChildShapes) {\n                this.shapeOnCursor = parent;\n            }\n            this.draggedShape = this.shapeOnCursor;\n            this.shapeOnCursor.eventListener.mousedown(createEvent(event,{target:this.shapeOnCursor}));\n        }\n    }\n\n    /**\n     * @ignore\n     * OnMouseUp event handler, triggered when user releases mouse button on shape or on shape container element\n     * @param event {MouseEvent} Event object\n     */\n    this.mouseup = (event) => {\n        if (!this.draggedShape) {\n            return\n        }\n        const dragshape = this.draggedShape;\n        if (event.buttons === 1 &&\n            dragshape.options.canAddPoints &&\n            !dragshape.draggedPoint &&\n            (dragshape.options.maxPoints === -1 || dragshape.points.length < dragshape.options.maxPoints)) {\n            dragshape.addPoint(event.clientX-dragshape.root.offsetLeft,\n                event.clientY-dragshape.root.offsetTop)\n        }\n        if (dragshape.draggedPoint) {\n            EventsManager.emit(ShapeEvents.POINT_DRAG_END,this.draggedShape,{point:dragshape.draggedPoint})\n            dragshape.draggedPoint.mouseup(event);\n            dragshape.draggedPoint = null;\n        } else {\n            EventsManager.emit(ShapeEvents.SHAPE_MOUSE_UP,dragshape,{});\n        }\n        this.draggedShape = null;\n        EventsManager.emit(ShapeEvents.SHAPE_MOVE_END,dragshape,{pos:dragshape.getPosition(true)});\n    }\n\n    /**\n     * @ignore\n     * Mouse move event listener. Runs when user moves mouse cursor in the container\n     * @param event {MouseEvent} Mouse move event object\n     */\n    this.mousemove = (event) => {\n        if (event.buttons !== 1) {\n            if (this.draggedShape) {\n                this.draggedShape.draggedPoint = null;\n            }\n            this.draggedShape = null;\n        }\n        if (!this.draggedShape) {\n            this.processShapesUnderCursor(event);\n            return\n        }\n        if (this.draggedShape) {\n            this.draggedShape.eventListener.mousemove(event);\n        }\n    }\n\n    /**\n     * @ignore\n     * onMouseOver event handler for shape's container. If cursor points on some shape,\n     * forwards this event to this shape.\n     * @param event {MouseEvent} Mouse over event\n     */\n    this.mouseover = (event) => {\n        if (this.shapeOnCursor) {\n            this.shapeOnCursor.eventListener.mouseover(createEvent(event, {target:this.shapeOnCursor}));\n        }\n    }\n\n    /**\n     * @ignore\n     * onMouseEnter event handler for shape's container. If cursor points on some shape,\n     * forwards this event to this shape.\n     * @param event {MouseEvent} Mouse enter event\n     */\n    this.mouseenter = (event) => {\n        if (this.shapeOnCursor) {\n            this.shapeOnCursor.eventListener.mouseenter(createEvent(event, {target:this.shapeOnCursor}));\n        }\n    }\n\n    /**\n     * @ignore\n     * onMouseOut event handler for shape's container. If cursor outs from some shape\n     * forwards this event to this shape.\n     * @param event {MouseEvent} Mouse out event\n     */\n    this.mouseout = (event) => {\n        if (this.shapeOnCursor) {\n            this.shapeOnCursor.eventListener.mouseout(createEvent(event,{target:event.target}));\n        }\n    }\n\n    /**\n     * @ignore\n     * onMouseLeave event handler for shape's container. If cursor leaves some shape area\n     * during resizing the shape in a simple mode, it redraws the shape with new size\n     * @param event {MouseEvent} Mouse leave event\n     */\n    this.mouseleave = (event) => {\n        if (this.draggedShape && this.draggedShape.draggedPoint &&\n            this.draggedShape.options.id.search(\"_resizebox\") !== -1) {\n            const id = this.draggedShape.options.id.replace(\"_resizebox\",\"\");\n            const destShape = this.findShapeById(id);\n            if (destShape && destShape.options.simpleMode) {\n                EventsManager.emit(ResizeBoxEvents.RESIZE_BOX_RESIZE, destShape.resizeBox, createEvent(event, {\n                    buttons: 0,\n                    oldPos: destShape.getPosition(true),\n                    newPos: destShape.resizeBox.getPosition()\n                }))\n            }\n        }\n    }\n\n    /**\n     * @ignore\n     * onClicj event handler for shape's container. If cursor points on some shape,\n     * forwards this event to this shape.\n     * @param event {MouseEvent} Mouse click event\n     */\n    this.click = (event) => {\n        if (this.shapeOnCursor) {\n            this.shapeOnCursor.eventListener.click(createEvent(event,{target:this.shapeOnCursor}));\n        }\n    }\n\n    /**\n     * @ignore\n     * Method that runs all the time when user moves cursor\n     * over the container. Used to set which shape is currently on\n     * cursor, which shape is currently under the mouse cursor\n     * and trigger mouseover/mouseout events for previous shape\n     * and current shape.\n     * @param event {MouseEvent} Mouse movement object\n     */\n    this.processShapesUnderCursor = (event) => {\n        const [clientX,clientY] = [event.clientX,event.clientY];\n        const shapeOnCursor = this.getShapeOnCursor(clientX, clientY);\n        if (this.shapeOnCursor && this.shapeOnCursor !== shapeOnCursor && this.shapeOnCursor.getShapeSvg()) {\n            this.shapeOnCursor.getShapeSvg().style.cursor = \"default\";\n            this.shapeOnCursor.eventListener.mouseout(createEvent(event,{target:this.shapeOnCursor}));\n        }\n        if (shapeOnCursor && shapeOnCursor !== this.shapeOnCursor) {\n            shapeOnCursor.eventListener.mouseover(createEvent(event,{target:shapeOnCursor}))\n        }\n        this.shapeOnCursor = shapeOnCursor;\n        if (this.shapeOnCursor) {\n            EventsManager.emit(ShapeEvents.SHAPE_MOUSE_MOVE,this.shapeOnCursor,createEvent(event));\n            this.shapeOnCursor.getShapeSvg().style.cursor = \"crosshair\";\n        }\n    };\n\n    /**\n     * Internal method used to determine the shape which is under\n     * mouse cursor right now.\n     * @param x {number} X coordinate of mouse cursor\n     * @param y {number} Y coordinate of mouse cursor\n     * @returns {SmartShape|null} Either SmartShape object or null\n     */\n    this.getShapeOnCursor = (x,y) => {\n        const shapes = Object.values(this.visibleShapes);\n        if (!shapes.length) {\n            return null;\n        }\n        const matchedShapes = shapes.filter(shape => shape.belongsToShape(x,y));\n        if (!matchedShapes.length) {\n            return null;\n        }\n        return matchedShapes\n            .reduce((prevShape,shape) => shape.options.zIndex >= prevShape.options.zIndex ? shape : prevShape);\n    }\n\n    /**\n     * Method used to export shapes to JSON.\n     * @param shapes {array} Array of [SmartShape](#SmartShape) objects to export\n     * @param compact {boolean} If this is true, then it will save only coordinates of\n     * points, but not their properties\n     * @returns {string} JSON string with array of SmartShape objects. If not specified, then exports all\n     * shapes, that exists in SmartShapeManager.\n     */\n    this.toJSON = (shapes=null,compact=false) => {\n        if (!shapes) {\n            shapes = this.getShapes();\n        }\n        shapes = shapes.filter(shape => (!shape.getParent()));\n        return JSON.stringify(shapes.map(shape => shape.getJSON(true,compact)))\n    }\n\n    /**\n     * Method loads shapes from JSON string, previously serialized by `toJSON` method\n     * @param root {HTMLElement} Container element to bind shapes to\n     * @param json {string|object} JSON data with shapes as an object or as a string with array of shape definitions\n     * @param progressCallback {function} Callback function that triggered after loading each shape in collection\n     * with ratio of processed items between 0 and 1\n     * @returns {array|null} array of loaded [SmartShape](#SmartShape) objects or null in case\n     * of JSON reading error\n     */\n    this.fromJSON = (root,json,progressCallback=null,emitCreateEvent=true) => {\n        let jsonObj = json;\n        if (typeof(jsonObj) === \"string\") {\n            jsonObj = readJSON(json);\n        }\n        if (!jsonObj || !jsonObj.length) {\n            return null;\n        }\n        const result = [];\n        for (let index in jsonObj) {\n            const obj = jsonObj[index];\n            if (obj.options.id && this.findShapeById(obj.options.id)) {\n                continue\n            }\n            result.push(new SmartShape().fromJSON(root,obj,true,emitCreateEvent));\n            if (progressCallback && typeof(progressCallback) === \"function\") {\n                progressCallback(index/jsonObj.length);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Method returns all shapes which have option with specified `name` and specified `value`\n     * @param name {string} Name of option to check\n     * @param value {any} Value of option to check\n     * @returns {array} Array of [SmartShape](#SmartShape) objects that match condition\n     */\n    this.findShapesByOptionValue = (name,value) => (\n        this.getShapes().filter(shape => shape.options[name] === value)\n    )\n\n    /**\n     * Method returns shape by specified ID\n     * @param id {string} ID to check\n     * @returns {SmartShape|null} SmartShape object or null if no shape with specified ID found\n     */\n    this.findShapeById = (id) => {\n        const result = this.findShapesByOptionValue(\"id\",id);\n        if (result && result.length) {\n            return result[0]\n        }\n        return null;\n    }\n\n    /**\n     * Method returns shape by specified name\n     * @param name {string} Name to check\n     * @returns {SmartShape|null} SmartShape object or null if no shape with specified name found\n     */\n    this.findShapeByName = (name) => {\n        const result = this.findShapesByOptionValue(\"name\",name);\n        if (result && result.length) {\n            return result[0]\n        }\n        return null;\n    }\n\n    /**\n     * @ignore\n     * Method used to clean manager object. Removes all shapes from list and\n     * attached containers event listeners\n     */\n    this.clear  = () => {\n        this.containerEventListeners.forEach(({container,name,listener}) => {\n            try {\n                container.removeEventListener(name,listener)\n            } catch (err) {\n                console.error(err);\n            }\n        })\n        this.containerEventListeners = [];\n        while (Object.values(this.shapes).length) {\n            Object.values(this.shapes)[0].destroy();\n        }\n    }\n\n    /**\n     * Method used to import collection of shapes from JSON array in GeoJSON format: https://geojson.org/\n     * @param container {HTMLElement} The HTML element to connect loaded shapes\n     * @param geoJSON {object} Javascript object in geoJSON format\n     * @param options {object} Options to tune the import process:\n     * `idField`: the field from \"properties collection of GeoJSON object that used as a shape ID,\n     * `nameField`: the field from \"properties\" collection of GeoJSON object that used as a shape name,\n     * `width`: the width to which loaded shapes should be scaled (if not specified then calc automatically based on height),\n     * `height`: the height to which loaded shapes should be scaled (if not specified then calc automatically based on width),\n     * `options`: shape options [SmartShape.options](#SmartShape+options) to set to each shape after import\n     * `scale`: scaling factor to which loaded shapes should be scaled (if not specified, width and height used,\n     * if nothing specified, then scales to 200px width if natural width is less than this)\n     * `fields`: which other fields to import from GeoJSON, in addition to `idField` and `nameField`\n     * @param progressCallback {function} Function that executes after loading each shape from file. If specified, it will\n     * be executed with three arguments: `currentShapeIndex` - index of current processed shape, `totalShapesLength` - total\n     * number of shapes in the collection, shape - SmartShape object of currently processed shape.\n     * @returns {array} Array of SmartShape objects\n     */\n    this.fromGeoJson = (container,geoJSON,options={},progessCallback=null) => {\n        return fromGeoJSON(container,geoJSON, options, progessCallback);\n    }\n\n    /**\n     * Method returns total count of shapes, managed by this manager\n     * @returns {number}\n     */\n    this.length = () => {\n        return Object.values(this.shapes).length;\n    }\n}\n\n/**\n * Events that SmartShapeManager can emit.\n * @param MANAGER_ADD_CONTAINER_LISTENERS Emits each time when add SmartShape event listeners to container for shapes\n * (usually after first shape added to it)\n * @param MANAGER_REMOVE_CONTAINER_LISTENERS Emits each time when remove SmartShape event listeners from container\n * for shapes (usually after last shape removed from container)\n * @enum {string}\n */\nexport const SmartShapeManagerEvents = {\n    MANAGER_ADD_CONTAINER_EVENT_LISTENERS: \"manager_add_container_event_listeners\",\n    MANAGER_REMOVE_CONTAINER_EVENT_LISTENERS: \"manager_remove_container_event_listeners\"\n}\n\n/**\n * Enumeration of event names, that can be emitted by [SmartShape](#SmartShape) object.\n @param CONTAINER_BOUNDS_CHANGED Emitted by shape when dimensions of container changed, e.g. browser\n window resized. Sends the event with the following fields: `bounds` -an object with the following fields:\n left:number,top:number,right:number,bottom:number, `points` - array of points ([SmartPoint](#SmartPoint) objects)\n with array of all points of this shape, which could be affected by this bounds change.\n @enum {string}\n */\nexport const ContainerEvents = {\n    CONTAINER_BOUNDS_CHANGED: \"CONTAINER_BOUNDS_CHANGED\"\n}\n\nexport default new SmartShapeManager().init();\n","import SmartShapeManager from \"../SmartShapeManager/SmartShapeManager.js\";\nimport {EventsManager, ShapeEvents} from \"../index.js\";\n/**\n * Class used as an extension to [SmartShape](#SmartShape) class to add\n * shape groups functionality. The feature works the following way:\n *\n * Each shape can have a children shapes. If shape has children, then\n * all actions, that user do with the shape propagated to all children:\n * when user drags the shape, all children draged with it, if user resizes the shape,\n * then all children resized with it. If user rotates the shape, then all shapes\n * rotates with it.\n *\n * You should not use this class directly. SmartShape class instantiates it.\n * When init, this class extends provided SmartShape object by adding all it's methods to it\n * and then you can use them right from your [SmartShape](#SmartShape) instance.\n * For example, methods `addChild` and `removeChild` declared here can be used\n * right from SmartShape object, e.g. `shape.addChild(child)`, `shape.removeChild(child)`\n * and all other methods, declared here.\n * @param shape {SmartShape} SmartShape object to extend\n * @constructor\n */\nfunction SmartShapeGroupHelper(shape) {\n\n    /**\n     * SmartShape object to extend\n     * @type {SmartShape}\n     */\n    this.shape = shape;\n\n    /**\n     * @ignore\n     * Method used to add specified shape as a child of current shape\n     * @param child {SmartShape} Shape to add\n     */\n    this.addChild = (child,emitEvent=true) => {\n        if (!this.shouldAddChild(child)) {\n            return\n        }\n        if (this.shape.options.displayMode !== child.options.displayMode) {\n            if (child.svg) {\n                child.switchDisplayMode(this.shape.options.displayMode);\n            } else {\n                child.options.displayMode = shape.options.displayMode;\n            }\n        }\n        this.shape.children.push(child);\n        if (emitEvent) {\n            EventsManager.emit(ShapeEvents.SHAPE_ADD_CHILD, this.shape, {child});\n        }\n    }\n\n    /**\n     * @ignore\n     * Method used to add specified children to current shape\n     * @param children {array} Array of [SmartShape][#SmartShape) objects\n     */\n    this.addChildren = (children=[]) => {\n        children.forEach(child => {\n            this.addChild(child,false)\n        })\n        EventsManager.emit(ShapeEvents.SHAPE_ADD_CHILD, this.shape, {children});\n    }\n\n    /**\n     * @ignore\n     * Method used to remove specified shape from children list of current shape\n     * @param child {SmartShape} SmartShape object to add\n     */\n    this.removeChild = (child) => {\n        this.shape.children.splice(this.shape.children.indexOf(child),1);\n        EventsManager.emit(ShapeEvents.SHAPE_REMOVE_CHILD,this.shape,{child});\n    }\n\n    /**\n     * @ignore\n     * Method removes all children of current shape\n     * @param all {boolean} If true, then it removes all children hierarchically\n     */\n    this.removeAllChildren = (all=false) => {\n        while (this.getChildren(all).length) {\n            this.removeChild(this.getChildren(all)[0])\n        }\n    }\n\n    /**\n     * @ignore\n     * Method returns array of children of current shape\n     * @param all {boolean} If true, then it returns deep list, including all children of each children of this shape\n     * @returns {array} Array of [SmartShape](#SmartShape) objects\n     */\n    this.getChildren = (all=false) => {\n        if (!all) {\n            return this.shape.children;\n        }\n        const result = []\n        result.push(...this.shape.children)\n        for (let child of result) {\n            result.push(...child.getChildren())\n        }\n        return result;\n    }\n\n    /**\n     * @ignore\n     * Method returns if specified shape is child of current shape\n     * @param child {SmartShape} Shape to check\n     * @param all {boolean} Should check include subchildren\n     */\n    this.hasChild = (child,all=false) => {\n        return child.guid !== this.guid && !!this.getChildren(all).find(item => item.guid === child.guid)\n    }\n\n    /**\n     * @ignore\n     * Internal method used to determine is it possible to add specified child\n     * to current shape\n     * @param child {SmartShape} Checked SmartShape object\n     * @returns {boolean} True if possible or false otherwise\n     */\n    this.shouldAddChild = (child) => {\n        if (!child || typeof(child) !== \"object\" || typeof(child.getChildren) === \"undefined\") {\n            return false;\n        }\n        if (this.shape.children.indexOf(child) !== -1) {\n            return false;\n        }\n        if (child === this.shape) {\n            return false;\n        }\n        if (child.getChildren().indexOf(this.shape) !== -1) {\n            return false;\n        }\n        if (child.getParent()) {\n            return false;\n        }\n        const parents = this.getParentsList();\n        return parents.indexOf(child) === -1;\n    }\n\n    /**\n     * @ignore\n     * Method returns parent of current shape or null\n     * @returns {SmartShape|null}\n     */\n    this.getParent = () => {\n        const shapes = SmartShapeManager.getShapes();\n        for (let item of shapes) {\n            if (item.getChildren().indexOf(this.shape) !== -1) {\n                return item\n            }\n        }\n        return null;\n    }\n\n    /**\n     * @ignore\n     * Method returns top parent of current shape\n     * @returns {SmartShape|null} Parent shape or null\n     */\n    this.getRootParent = (groupChildShapes= null) => {\n        let parents = this.getParentsList();\n        if (!parents.length) {\n            return null;\n        }\n        if (groupChildShapes !== null) {\n            parents = parents.filter(parent => parent.options.groupChildShapes === groupChildShapes)\n        }\n        return parents[parents.length-1];\n    }\n\n    /**\n     * @ignore\n     * Method returns a list of parents of current shape ordered from nearest to root\n     * @param plist {array} Temporary list of parents from previous recursive call\n     * @returns {array} Array of [SmartShape](#SmartShape) objects\n     */\n    this.getParentsList = (plist=[]) => {\n        const parent = this.getParent();\n        if (parent == null) {\n            return plist;\n        }\n        plist.push(parent);\n        return parent.getParentsList(plist)\n    }\n\n    /**\n     * @ignore\n     * Method overrides SmartShape's getPosition method to return position\n     * of all group if forGroup parameter is set\n     * @returns {object} Position object {left,top,right,bottom,width,height}\n     */\n    this.getPosition = () => {\n        let children = this.getChildren(true);\n        children.push(this.shape);\n        children = children.filter(child=>child.points.length);\n        if (!children.length) {\n            return {left:0,right:0,top:0,bottom:0,width:0,height:0};\n        }\n        const pos = {\n            left: children.map(item => item.left).reduce((minLeft,left) => left < minLeft ? left : minLeft),\n            top: children.map(item => item.top).reduce((minTop,top) => top < minTop ? top : minTop),\n            right: children.map(item => item.right).reduce((maxRight,right) => right > maxRight ? right : maxRight),\n            bottom: children.map(item => item.bottom).reduce((maxBottom,bottom) => bottom > maxBottom ? bottom : maxBottom)\n        }\n        pos.width = Math.abs(pos.right-pos.left) || 1;\n        pos.height = Math.abs(pos.bottom-pos.top) || 1;\n        return pos;\n    }\n}\n\nexport default SmartShapeGroupHelper;\n","import SmartShape from \"../SmartShape/SmartShape.js\";\nimport RotateBoxEventListener from \"./RotateBoxEventListener.js\";\nimport EventsManager from \"../events/EventsManager.js\";\nimport {ShapeEvents} from \"../SmartShape/SmartShapeEventListener.js\";\nimport {rotate_tl,rotate_tr,rotate_br,rotate_bl} from \"../../assets/graphics.js\";\nimport {mergeObjects, uuid} from \"../utils\";\n/**\n * Class represents a special type of shape, that shows the rectangle with markers on\n * it corners, used to rotate it. [See demo](https://code.germanov.dev/smart_shape/tests/prod/rotate_box.html).\n * Mostly used to rotate [SmartShape](#SmartShape) object, but also can be used as an independent shape\n * for tasks like rotating objects on a web page or select rectangular regions.\n * @constructor\n */\nfunction RotateBox() {\n\n    /**\n     * Left corner of rotate box\n     * @type {number}\n     */\n    this.left = 0;\n\n    /**\n     * Top corner of rotate box\n     * @type {number}\n     */\n    this.top = 0;\n\n    /**\n     * Right corner of rotate box\n     * @type {number}\n     */\n    this.right = 0;\n\n    /**\n     * Bottom corner of rotate box\n     * @type {number}\n     */\n    this.bottom = 0;\n\n    /**\n     * Width of rotate box\n     * @type {number}\n     */\n    this.width = 0;\n\n    /**\n     * Height of rotate box\n     * @type {number}\n     */\n    this.height = 0;\n\n    /**\n     * Underlying shape, that used to service this rotate box\n     * (draw, point event handling and so on)\n     * @type {SmartShape}\n     */\n    this.shape = null;\n\n    /**\n     * Global unique identifier of this object.\n     * Generated automatically\n     * @type {string}\n     */\n    this.guid = uuid()\n\n    /**\n     * Options of rotate box\n     * @param id {string} Unique ID or rotate box. If instantiated by [SmartShape](#SmartShape), then setup\n     * automatically\n     * @param shapeOptions {object} Options of underlying shape, that used to draw and manage this RotateBox. See\n     * [SmartShape.options](#SmartShape+options)\n     * @param zIndex {number} Order of element in a stack of HTML elements\n     * (https://www.w3schools.com/cssref/pr_pos_z-index.asp). Elements if higher z-index value placed on top.\n     * @type {object}\n     */\n    this.options = {\n        id: \"\",\n        shapeOptions: {\n            id: \"\",\n            canAddPoints: false,\n            canDeletePoints: false,\n            pointOptions: {\n                style: {\n                    borderWidth: \"0px\",\n                    cursor:\"pointer\",\n                    backgroundColor:'rgba(0,0,0,0)'\n                },\n                width:13,\n                height:13,\n                forceDisplay:true\n            },\n            style: {\n                \"stroke-width\":\"2px\",\n                \"stroke\":\"#aaaaaa\",\n                \"stroke-dasharray\": \"10\",\n                fill:\"none\",\n            }\n        },\n        zIndex: 1000\n    }\n\n    /**\n     * Event listener that handles event listening logic for this rotate box.\n     * Instance of [ResizeBoxEventListener](#ResizeBoxEventListener) class.\n     * @type {RotateBoxEventListener}\n     */\n    this.eventListener = null;\n\n    /**\n     * Left top marker point\n     * @type {SmartPoint}\n     */\n    this.left_top = null;\n\n    /**\n     * Left bottom marker point\n     * @type {SmartPoint}\n     */\n    this.left_bottom = null;\n\n    /**\n     * Right top marker point\n     * @type {SmartPoint}\n     */\n    this.right_top = null;\n\n    /**\n     * Right bottom marker point\n     * @type {SmartPoint}\n     */\n    this.right_bottom = null;\n\n    /**\n     * Method used to construct RotateBox object with specified coordinates and\n     * size, with specified `options`. Then it binds this object to specified `root`\n     * HTML node and displays it\n     * @param root {HTMLElement} HTML element that used as a container for this RotateBox\n     * @param left {number} Left corner of shape relative to container top left\n     * @param top {number} Top corner of shape relative to container top left\n     * @param width {number} Width of shape\n     * @param height {number} Height of shape\n     * @param options {object} Options used to setup RotateBox. See [here](#RotateBox+options).\n     * @returns {RotateBox} constucted RotateBox object\n     */\n    this.init = (root,left,top,width,height,options={}) => {\n        this.left = parseInt(left);\n        this.top = parseInt(top);\n        this.width = parseInt(width);\n        this.height = parseInt(height);\n        this.right = this.left + this.width;\n        this.bottom = this.top + this.height;\n        this.setOptions(options);\n        this.options.shapeOptions.id = this.options.id;\n        this.options.shapeOptions.canRotate = false;\n        this.options.shapeOptions.canScale = false;\n        this.shape = new SmartShape().init(root,mergeObjects({},this.options.shapeOptions),[]);\n        EventsManager.emit(ShapeEvents.SHAPE_CREATE, this.shape, {});\n        this.options.shapeOptions.pointOptions.bounds = this.shape.getBounds();\n        this.addPoints();\n        this.eventListener = new RotateBoxEventListener(this).run();\n        return this;\n    }\n\n    /**\n     * Method used to change options of RotateBox.\n     * @param options {object} Options object. See [here](#RotateBox+options).\n     */\n    this.setOptions = (options = {}) => {\n        if (!options || typeof(options) !== \"object\") {\n            return\n        }\n        this.options = mergeObjects(this.options,options);\n        this.options.shapeOptions.zIndex = this.options.zIndex || this.options.zIndex;\n        this.options.shapeOptions.id = this.options.id ? this.options.id : this.options.id;\n        if (this.shape) {\n            this.shape.setOptions(this.options.shapeOptions);\n        }\n    }\n\n    /**\n     * @ignore\n     * Method used to add marker points to RotateBox, that lately used to rotate the box\n     */\n    this.addPoints = () => {\n        this.left_top = this.shape.addPoint(this.left,this.top,{id:this.shape.guid+\"_left_top\",style:{backgroundImage: \"url('\"+rotate_tl+\"')\"}});\n        this.right_top = this.shape.addPoint(this.right,this.top,{id:this.shape.guid+\"_right_top\",style:{backgroundImage: \"url('\"+rotate_tr+\"')\"}});\n        this.right_bottom = this.shape.addPoint(this.right,this.bottom,{id:this.shape.guid+\"_right_bottom\",style:{backgroundImage: \"url('\"+rotate_br+\"')\"}});\n        this.left_bottom = this.shape.addPoint(this.left,this.bottom,{id:this.shape.guid+\"_left_bottom\",style:{backgroundImage: \"url('\"+rotate_bl+\"')\"}});\n    }\n\n    /**\n     * @ignore\n     * Method used to recalculate coordinates of marker points\n     * according to current RotateBox coordinates and dimensions.\n     */\n    this.adjustCoordinates = () => {\n        this.right = this.left + this.width;\n        this.bottom = this.top + this.height;\n        this.left_top.x = this.left;\n        this.left_top.y = this.top;\n        this.right_top.x = this.right;\n        this.right_top.y = this.top;\n        this.left_bottom.x = this.left;\n        this.left_bottom.y = this.bottom;\n        this.right_bottom.x = this.right;\n        this.right_bottom.y = this.bottom;\n    }\n\n    /**\n     * @ignore\n     * Internal method that used to calculate rotate box dimensions, based on point coordinates.\n     * Set left,top,right,bottom,width and height of rotate box.\n     */\n    this.calcPosition = () => {\n        this.shape.calcPosition();\n        this.left = this.shape.left;\n        this.top = this.shape.top;\n        this.bottom = this.shape.bottom;\n        this.right = this.shape.right;\n        this.width = this.shape.width;\n        this.height = this.shape.height;\n    }\n\n    /**\n     * Method used to get current position of Rotate Box\n     * @returns {object} Position with fields:\n     * `top`,`left`,`right`,`bottom`,`width`,`height`\n     */\n    this.getPosition = () => (\n        {top:this.top, left: this.left, bottom: this.bottom, right: this.right, width: this.width, height:this.height}\n    )\n\n    /**\n     * Method used to redraw rotate box\n     */\n    this.redraw = () => {\n        this.adjustCoordinates();\n        this.shape.setOptions(this.options.shapeOptions);\n        this.shape.redraw();\n    }\n\n    /**\n     * Method used to show Rotate Box if it has hidden\n     */\n    this.show = () => {\n        this.options.shapeOptions.visible = true;\n        this.shape.show();\n    }\n\n    /**\n     * Method used to hide Rotate Box\n     */\n    this.hide = () => {\n        this.options.shapeOptions.visible = false;\n        this.shape.hide();\n    }\n\n    /**\n     * Destroys the RotateBox. Destroys all points, removes event listeners and removes the shape from screen.\n     * But variable continue existing. To completely remove the shape,\n     * set the variable to 'null' after calling this method.\n     */\n    this.destroy = () => {\n        EventsManager.emit(ShapeEvents.SHAPE_DESTROY,this,{});\n        this.eventListener.destroy();\n        this.shape.destroy();\n    }\n\n    /**\n     * Uniform method that used to add event handler of specified type to this object.\n     * RotateBox can emit events, defined in [RotateBoxEvents](#RotateBoxEvents) enumeration. So, you can\n     * listen any of these events.\n     * @param eventName {string} - Name of event. Use one of name, defined in [RotateBoxEvents](#RotateBoxEvents)\n     * @param handler {function} - Function that used as an event handler\n     * @returns {function} - Pointer to added event handler. Should be used to remove event listener later.\n     */\n    this.addEventListener = (eventName,handler) => {\n        return this.eventListener.addEventListener(eventName,handler);\n    }\n\n    /**\n     * Uniform method that used to remove event handler, that previously added\n     * to this object.\n     * @param eventName {RotateBoxEvents|string} Name of event to remove listener from\n     * @param listener {function} Pointer to event listener, that added previously.\n     * It was returned from [addEventListener](#RotateBox+addEventListener) method.\n     */\n    this.removeEventListener = (eventName,listener) => {\n        this.eventListener.removeEventListener(eventName,listener);\n    }\n}\n\n\n\nexport default RotateBox;\n","import {Menus} from \"../../context_menu/src/index.js\";\nimport {getMousePos} from \"../events/functions.js\";\nimport {add,del,save,svg,png,copy,group,ungroup,move_to_top,move_to_bottom,horizontal,vertical,to_path,to_shapes,\n    base64_export,zoom_in,zoom_out,reset_zoom} from \"../../assets/graphics.js\";\nimport {SmartShapeDisplayMode} from \"./SmartShape.js\";\nimport {PngExportTypes} from \"./SmartShapeDrawHelper.js\";\n\n/**\n * Helper class that used to manage SmartShape context menu\n * that appear on right mouse click\n * Should not be instantiated directly. SmartShape automatically calls it\n * when needed\n * @param shape {SmartShape} The shape object to manage menu for\n * @constructor\n */\nexport default function SmartShapeContextMenu(shape) {\n\n    /**\n     * @ignore\n     * The shape object to manage menu for\n     * @type {SmartShape}\n     */\n    this.shape = shape;\n\n    /**\n     * @ignore\n     * Context menu object instance\n     * @type {object}\n     */\n    this.contextMenu = null;\n\n    /**\n     * @ignore\n     * Method executed to check if context menu should be initialized\n     * or destroyed depending on options of the shape\n     */\n    this.updateContextMenu = () => {\n        if (this.shape.options.hasContextMenu && !this.contextMenu) {\n            this.init();\n        } else if (!this.shape.options.hasContextMenu) {\n            this.contextMenu = null;\n        }\n        this.shape.contextMenu = this.contextMenu;\n        if (this.contextMenu) {\n            const itemsToAdd = this.getMenuItems();\n            for (let itemToAdd of itemsToAdd) {\n                if (!this.contextMenu.items.find(item => item.id === itemToAdd.id)) {\n                    this.contextMenu.addItem(itemToAdd.id,itemToAdd.title,itemToAdd.image);\n                }\n            }\n        }\n    }\n\n    /**\n     * @ignore\n     * Initializes context menu. Creates context menu and binds event\n     * listeners to it\n     */\n    this.init = () => {\n        if (shape.svg) {\n            this.contextMenu = Menus.create([], shape.svg,\"contextmenu\", {customHandler:()=> {return }});\n            if (shape.options.canAddPoints) {\n                this.contextMenu.addItem(\"i\"+shape.guid+\"_add_point\", \"Add Point\", add);\n            }\n            this.displayGroupItems();\n            this.setEventListeners();\n        }\n    }\n\n    this.getMenuItems = () => {\n        const items = [\n            {id: \"i\" + shape.guid + \"_move_to_top\", title: \"Move to Top\", image: move_to_top },\n            {id: \"i\" + shape.guid + \"_move_to_bottom\", title: \"Move to Bottom\", image: move_to_bottom },\n            {id: \"i\" + shape.guid + \"_flip_horizontal\", title: \"Flip Horizontal\", image: horizontal },\n            {id: \"i\" + shape.guid + \"_flip_vertical\", title: \"Flip Vertical\", image: vertical },\n            {id: \"i\" + shape.guid + \"_clone\", title: \"Clone\", image: copy},\n            {id: \"i\" + shape.guid + \"_export_json\", title: \"Export to JSON\", image: save},\n            {id: \"i\" + shape.guid + \"_export_svg\", title: \"Export to SVG\", image: svg},\n            {id: \"i\" + shape.guid + \"_export_png\", title: \"Export to PNG\", image: png},\n            {id: \"i\" + shape.guid + \"_get_base64\", title: \"Copy Base64 to clipboard\", image: base64_export},\n            {id: \"i\" + shape.guid + \"_destroy\", title: \"Destroy\", image: del}\n        ];\n        if (shape.options.canAddPoints) {\n            items.push({id:\"i\"+shape.guid+\"_add_point\", title:\"Add Point\", image:add});\n        }\n        if (shape.options.zoomable) {\n            items.push({id:\"i\"+shape.guid+\"_zoom_in\", title:\"Zoom in\", image:zoom_in});\n            items.push({id:\"i\"+shape.guid+\"_zoom_out\", title:\"Zoom out\", image:zoom_out});\n            items.push({id:\"i\"+shape.guid+\"_reset_zoom\", title:\"Reset zoom\", image:reset_zoom});\n        }\n        return items;\n    }\n\n    /**\n     * @ignore\n     * Method used to set up handler functions for context menu items\n     */\n    this.setEventListeners = () => {\n        this.setOnItemClickListener();\n        this.contextMenu.on(\"show\", () => {\n            this.displayGroupItems();\n        })\n    }\n\n    /**\n     * @ignore\n     * Method used to react on user click events on menu items\n     */\n    this.setOnItemClickListener = () => {\n        let destShape,parent\n        this.contextMenu.on(\"click\",(event) => {\n            switch (event.itemId) {\n                case \"i\"+this.shape.guid+\"_destroy\":\n                    this.onDestroyClick(event);\n                    break\n                case \"i\"+this.shape.guid+\"_add_point\":\n                    this.onAddPointClick(event);\n                    break;\n                case \"i\"+this.shape.guid+\"_clone\":\n                    this.onCloneClick(event);\n                    break;\n                case \"i\"+this.shape.guid+\"_export_json\":\n                    this.onExportJsonClick(event);\n                    break;\n                case \"i\"+this.shape.guid+\"_export_svg\":\n                    this.onExportSvgClick(event);\n                    break;\n                case \"i\"+this.shape.guid+\"_export_png\":\n                    this.onExportPngClick(event);\n                    break;\n                case \"i\"+this.shape.guid+\"_get_base64\":\n                    this.onGetBase64ToClipboardClick(event);\n                    break;\n                case \"i\"+this.shape.guid+\"_group\":\n                    parent = this.shape.getRootParent();\n                    destShape =  parent || this.shape;\n                    destShape.setOptions({groupChildShapes:true});\n                    destShape.switchDisplayMode(SmartShapeDisplayMode.DEFAULT);\n                    break;\n                case \"i\"+this.shape.guid+\"_ungroup\":\n                    parent = this.shape.getRootParent();\n                    destShape = parent || this.shape;\n                    destShape.setOptions({groupChildShapes:false,displayAsPath:false});\n                    destShape.switchDisplayMode(SmartShapeDisplayMode.DEFAULT);\n                    destShape.getChildren().forEach(child=> child.switchDisplayMode(SmartShapeDisplayMode.DEFAULT))\n                    break;\n                case \"i\"+this.shape.guid+\"_topath\":\n                    parent = this.shape.getRootParent();\n                    destShape =  parent || this.shape;\n                    destShape.setOptions({groupChildShapes:true,displayAsPath:true});\n                    destShape.switchDisplayMode(SmartShapeDisplayMode.SELECTED);\n                    destShape.getChildren().forEach(child=>child.switchDisplayMode(SmartShapeDisplayMode.DEFAULT))\n                    break;\n                case \"i\"+this.shape.guid+\"_toshapes\":\n                    parent = this.shape.getRootParent();\n                    destShape = parent || this.shape;\n                    destShape.setOptions({displayAsPath:false});\n                    destShape.switchDisplayMode(SmartShapeDisplayMode.SELECTED);\n                    destShape.getChildren().forEach(child=>child.switchDisplayMode(SmartShapeDisplayMode.DEFAULT))\n                    break;\n                case \"i\"+this.shape.guid+\"_move_to_top\":\n                    this.onMoveToTopClick(event)\n                    break;\n                case \"i\"+this.shape.guid+\"_move_to_bottom\":\n                    this.onMoveToBottomClick(event)\n                    break;\n                case \"i\"+this.shape.guid+\"_flip_horizontal\":\n                    this.onFlipHorizontalClick(event)\n                    break;\n                case \"i\"+this.shape.guid+\"_flip_vertical\":\n                    this.onFlipVerticalClick(event)\n                    break;\n                case \"i\"+this.shape.guid+\"_zoom_in\":\n                    this.onZoomInClick(event)\n                    break;\n                case \"i\"+this.shape.guid+\"_zoom_out\":\n                    this.onZoomOutClick(event)\n                    break;\n                case \"i\"+this.shape.guid+\"_reset_zoom\":\n                    this.onResetZoomClick(event)\n                    break;\n            }\n        })\n    }\n\n    /**\n     * @ignore\n     * Method used to display Group/Ungroup menu item\n     * depending on number of children of current shape\n     * and depending on status of `groupChildShapes` option\n     */\n    this.displayGroupItems = () => {\n        let destShape = this.shape.getRootParent() ? this.shape.getRootParent() : this.shape;\n\n        if (!destShape.getChildren().length) {\n            this.contextMenu.removeItem(\"i\"+this.shape.guid+\"_group\");\n            this.contextMenu.removeItem(\"i\"+this.shape.guid+\"_ungroup\");\n            this.contextMenu.removeItem(\"i\"+this.shape.guid+\"_topath\");\n            this.contextMenu.removeItem(\"i\"+this.shape.guid+\"_toshapes\");\n            return\n        }\n        if (destShape.options.groupChildShapes) {\n            if (!this.contextMenu.items.find(item => item.id === \"i\"+this.shape.guid+\"_ungroup\")) {\n                this.contextMenu.addItem(\"i\" + this.shape.guid + \"_ungroup\", \"Ungroup\", ungroup);\n                this.contextMenu.removeItem(\"i\"+this.shape.guid+\"_group\");\n            }\n        } else {\n            if (!this.contextMenu.items.find(item => item.id === \"i\"+this.shape.guid+\"_group\")) {\n                this.contextMenu.removeItem(\"i\"+this.shape.guid+\"_ungroup\");\n                this.contextMenu.addItem(\"i\" + this.shape.guid + \"_group\", \"Group\", group);\n            }\n        }\n        if (destShape.options.displayAsPath) {\n            if (!this.contextMenu.items.find(item => item.id === \"i\"+this.shape.guid+\"_toshapes\")) {\n                this.contextMenu.addItem(\"i\" + this.shape.guid + \"_toshapes\", \"Convert to shapes\", to_shapes);\n                this.contextMenu.removeItem(\"i\"+this.shape.guid+\"_topath\");\n            }\n        } else {\n            if (!this.contextMenu.items.find(item => item.id === \"i\"+this.shape.guid+\"_topath\")) {\n                this.contextMenu.addItem(\"i\" + this.shape.guid + \"_topath\", \"Convert to path\", to_path);\n                this.contextMenu.removeItem(\"i\"+this.shape.guid+\"_toshapes\");\n            }\n        }\n    }\n\n    /**\n     * @ignore\n     * Runs when click on \"Add Point\" menu option\n     * @param event {MouseEvent} Event object\n     */\n    this.onAddPointClick = (event) => {\n        if (this.shape.options.maxPoints !== -1 && this.shape.points.length >= this.shape.options.maxPoints) {\n            return\n        }\n        const [x,y] = getMousePos(this.shape.root,event.cursorX,event.cursorY);\n        if (this.shape.points.length < 2) {\n            this.shape.addPoint(x, y);\n        } else {\n            const [point1,point2] = this.shape.getClosestLine(x,y);\n            if (this.shape.getPointIndex(point2) === 0) {\n                this.shape.addPoint(x,y)\n            } else {\n                let point = point1;\n                if (this.shape.getPointIndex(point2) > this.shape.getPointIndex(point1)) {\n                    point = point2;\n                }\n                this.shape.insertPoint(x, y, point)\n            }\n        }\n        if (this.shape.options.displayMode === SmartShapeDisplayMode.DEFAULT) {\n            this.shape.switchDisplayMode(SmartShapeDisplayMode.SELECTED);\n        }\n    }\n\n    /**\n     * @ignore\n     * Runs when click on \"Clone\" menu option\n     * @param _event {MouseEvent} Event object\n     */\n    this.onCloneClick = (_event) => {\n        let destShape = this.shape;\n        const parent = destShape.getRootParent();\n        if (parent && parent.options.groupChildShapes) {\n            destShape = parent;\n        }\n        const clone = destShape.clone({},destShape.options.groupChildShapes);\n        const pos = clone.getPosition(true);\n        clone.moveTo(pos.left+5,pos.top+5);\n        SmartShapeManager.activateShape(clone);\n    }\n\n    /**\n     * @ignore\n     * Runs when click on \"Export to JSON\" menu option\n     * @param _event {MouseEvent} Event object\n     */\n    this.onExportJsonClick = (_event) => {\n        let destShape = this.shape;\n        const parent = destShape.getRootParent();\n        if (parent && parent.options.groupChildShapes) {\n            destShape = parent;\n        }\n        const jsonString = destShape.toJSON(destShape.options.groupChildShapes);\n        const blob = new Blob([jsonString]);\n        this.saveToFile(blob,this.getExportFileName(\"json\"))\n    }\n\n    /**\n     * @ignore\n     * Runs when click on \"Export to SVG\" menu option\n     * @param _event {MouseEvent} Event object\n     */\n    this.onExportSvgClick = (_event) => {\n        let destShape = this.shape;\n        const parent = destShape.getRootParent();\n        if (parent && parent.options.groupChildShapes) {\n            destShape = parent;\n        }\n        const svgString = destShape.toSvg();\n        const blob = new Blob([svgString]);\n        this.saveToFile(blob,this.getExportFileName(\"svg\"))\n    }\n\n    /**\n     * @ignore\n     * Runs when click on \"Export to PNG\" menu option\n     * @param _event {MouseEvent} Event object\n     */\n    this.onExportPngClick = async(_event) => {\n        let destShape = this.shape;\n        const parent = destShape.getRootParent();\n        if (parent && parent.options.groupChildShapes) {\n            destShape = parent;\n        }\n        const blob = await destShape.toPng(PngExportTypes.BLOB);\n        this.saveToFile(blob,this.getExportFileName(\"png\"));\n    }\n\n    /**\n     * @ignore\n     * Runs when click on \"Copy Base64 to clipboard\" menu option\n     * @param _event {MouseEvent} Event object\n     */\n    this.onGetBase64ToClipboardClick = async(_event) => {\n        let destShape = this.shape;\n        const parent = destShape.getRootParent();\n        if (parent && parent.options.groupChildShapes) {\n            destShape = parent;\n        }\n        await window.navigator.clipboard.writeText(await destShape.toPng(PngExportTypes.DATAURL));\n    }\n\n    /**\n     * @ignore\n     * Runs when click on \"Destroy\" menu option\n     * @param _event {MouseEvent} Event object\n     */\n    this.onDestroyClick = (_event) => {\n        const parent = this.shape.getParent();\n        if (parent && parent.options.groupChildShapes) {\n            parent.destroy();\n        } else {\n            this.shape.destroy();\n        }\n    }\n\n    /**\n     * @ignore\n     * Runs when click on \"Move to top\" menu option\n     * @param _event {MouseEvent} Event object\n     */\n    this.onMoveToTopClick = (_event) => {\n        const parent = this.shape.getParent();\n        if (parent && parent.options.groupChildShapes) {\n            parent.moveToTop();\n        } else {\n            this.shape.moveToTop();\n        }\n    }\n\n    /**\n     * @ignore\n     * Runs when click on \"Move to bottom\" menu option\n     * @param _event {MouseEvent} Event object\n     */\n    this.onMoveToBottomClick = (_event) => {\n        const parent = this.shape.getParent();\n        if (parent && parent.options.groupChildShapes) {\n            parent.moveToBottom();\n        } else {\n            this.shape.moveToBottom();\n        }\n    }\n\n    /**\n     * @ignore\n     * Runs when click on \"Flip Horizontal\" menu option\n     * @param _event {MouseEvent} Event object\n     */\n    this.onFlipHorizontalClick = (_event) => {\n        const parent = this.shape.getParent();\n        if (parent && parent.options.groupChildShapes) {\n            parent.flip(true,false);\n        } else {\n            this.shape.flip(true,false);\n            this.shape.redraw();\n        }\n    }\n\n    /**\n     * @ignore\n     * Runs when click on \"Flip Vertical\" menu option\n     * @param _event {MouseEvent} Event object\n     */\n    this.onFlipVerticalClick = (_event) => {\n        const parent = this.shape.getParent();\n        if (parent && parent.options.groupChildShapes) {\n            parent.flip(false,true);\n            parent.redraw();\n            parent.redraw();\n        } else {\n            this.shape.flip(false,true);\n            this.shape.redraw();\n        }\n    }\n\n    /**\n     * @ignore\n     * Runs when click on \"Zoom In\" menu option\n     * @param _event {MouseEvent} Event object\n     */\n    this.onZoomInClick = (_event) => {\n        const destShape = this.shape.getRootParent() || this.shape;\n        destShape.zoomBy(1+destShape.options.zoomStep);\n        destShape.redraw();\n    }\n\n    /**\n     * @ignore\n     * Runs when click on \"Zoom out\" menu option\n     * @param _event {MouseEvent} Event object\n     */\n    this.onZoomOutClick = (_event) => {\n        const destShape = this.shape.getRootParent() || this.shape;\n        destShape.zoomBy(1-destShape.options.zoomStep);\n        destShape.redraw();\n    }\n\n    /**\n     * @ignore\n     * Runs when click on \"Reset zoom\" menu option\n     * @param _event {MouseEvent} Event object\n     */\n    this.onResetZoomClick = (_event) => {\n        const destShape = this.shape.getRootParent() || this.shape;\n        destShape.scaleBy(1/destShape.options.zoomLevel,1/destShape.options.zoomLevel);\n        destShape.options.zoomLevel = 1;\n        destShape.redraw();\n    }\n\n    /**\n     * @ignore\n     * Method used to show \"Save file\" dialog\n     * that saves specified `blob` as a file with name `filename`\n     * @param blob {object} BLOB object with file data\n     * @param filename {string} Name of file to save to\n     */\n    this.saveToFile = (blob,filename) => {\n        const url = window.URL.createObjectURL(blob);\n        const a = document.createElement(\"a\");\n        a.download = filename;\n        a.href = url;\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n        window.URL.revokeObjectURL(url);\n\n    }\n\n    /**\n     * @ignore\n     * Method used to generate filename based on shape ID and specified file extension\n     * @param extension {string} Extension of file\n     * @returns {string} Generated file name\n     */\n    this.getExportFileName = (extension) => {\n        const parent = this.shape.getRootParent();\n        const destShape = parent || this.shape;\n        return (destShape.options.id ? destShape.options.id : \"shape\")+\".\"+extension;\n    }\n\n    /**\n     * @ignore\n     * Method used to remove all event listeners, added to this object\n     */\n    this.removeMenuEventListeners = () => {\n        this.contextMenu.removeEventListener(\"show\", this.onShowListener);\n    }\n\n    /**\n     * @ignore\n     * Method used to destroy context menu and all dependent functions\n     */\n    this.destroyContextMenu = () => {\n        this.removeMenuEventListeners();\n        this.contextMenu.destroy();\n    }\n}\n","import SmartShapeManager from \"../SmartShapeManager/SmartShapeManager.js\";\nimport SmartPoint from \"../SmartPoint/SmartPoint.js\";\nimport SmartShapeDrawHelper, {PngExportTypes} from \"./SmartShapeDrawHelper.js\";\nimport SmartShapeGroupHelper from \"./SmartShapeGroupHelper.js\";\nimport SmartShapeEventListener, {ShapeEvents} from \"./SmartShapeEventListener.js\";\nimport ResizeBox from \"../ResizeBox/ResizeBox.js\";\nimport RotateBox from \"../RotateBox/RotateBox.js\";\nimport {\n    getRotatedCoords,\n    mergeObjects,\n    notNull,\n    uuid,\n    isPointInsidePolygon,\n    getOffset,\n    readJSON, abs\n} from \"../utils\";\nimport EventsManager from \"../events/EventsManager.js\";\nimport {\n    applyAspectRatio,\n    distance,\n    distanceFromLine,\n    flipPoint,\n    mapPointCords,\n    PointMapTypes\n} from \"../utils/geometry.js\";\nimport SmartShapeContextMenu from \"./SmartShapeContextMenu.js\";\n/**\n * SmartShape class. Used to construct shapes.\n * @constructor\n * @return SmartShape object that should be initialised using `init` method.\n */\nfunction SmartShape() {\n\n    /**\n     * The HTML container element to which the shape will be injected. This can be any block element,\n     * that can have children (div,span etc.)\n     * @type {HTMLElement}\n     */\n    this.root = null\n\n    /**\n     * Array of points of shape polygon. Each item of array is [SmartPoint](#SmartPoint) object.\n     * @type {array}\n     */\n    this.points = [];\n\n    /**\n     * [SVG element](https://developer.mozilla.org/en-US/docs/Web/SVG/Element), which used as a backend for shape.\n     * SmartShape constructs SVG element based on provided point coordinates and options.\n     * @type {HTMLOrSVGElement}\n     */\n    this.svg = null;\n\n    /**\n     * [SVG element](https://developer.mozilla.org/en-US/docs/Web/SVG/Element), which used as a backend for shape.\n     * SVG Polygon element that defines a shape inside <SVG> element\n     * @type {HTMLOrSVGElement}\n     */\n    this.polygon = null;\n\n    /**\n     * Helper object that used to manage children shapes of this shape\n     * @type {SmartShapeGroupHelper}\n     */\n    this.groupHelper = null;\n\n    this.eventListener = null;\n\n    /**\n     * Options of shape as an object. Can have the following parameters.\n     * @param id {string} Unique ID of shape's SVG HTML element. By default, empty.\n     * @param name {string} Name of shape. By default, `Unnamed shape`\n     * @param maxPoints {number} Number of points, which possible to add to the shape interactively. By default `-1`,\n     * which means Unlimited\n     * @param style {object} CSS styles, that will be applied to underlying polygon SVG element. Using CSS styles and\n     * classes is an alternative way to specify options of SVG elements:\n     * https://jenkov.com/tutorials/svg/svg-and-css.html,\n     * https://css-tricks.com/svg-properties-and-css/\n     * @param fillGradient {object} Defines gradient object, that should be used to fill the shape. This could be either\n     * linear gradient or radial gradient. To make it work, it's required to set 'fill:#gradient' inside style.\n     * See demo [here](https://github.com/AndreyGermanov/smart_shape/blob/main/tests/dev/gradient.html).\n     * @param fillImage {object} Defines image fill object to fill the shape with image. Should contain following fields:\n     * `href` - URL to image, `width` - width of image, `height` - height of image\n     * To make image fill work, it's required to set 'fill:#image' inside style\n     * See demo [here](https://github.com/AndreyGermanov/smart_shape/blob/main/tests/dev/fillimage.html).\n     * @param filters {object} Object, that defines a set of SVG filters, that will be applied to this shape.\n     * Keys are names of filters, for example `feDropShadow` for drop-shadow filter. Values are objects with attributes\n     * for each filter. All attributes, that supported by each particular SVG filter are supported. See more about SVG\n     * filters [here](#https://developer.mozilla.org/en-US/docs/Web/SVG/Element/filter).\n     * The demo of applying feDropShadow filter see\n     * [here](https://github.com/AndreyGermanov/smart_shape/blob/main/tests/dev/svgfilters.html)\n     * @param classes {string} CSS class names, that will be applied to underlying polygon SVG element.\n     * @param canDragShape {boolean} Is it allowed to drag shape. Default `true`.\n     * @param canAddPoints {boolean} Is it allowed to add points to the shape interactively,\n     * by mouse double-click on the screen. Default `false`.\n     * @param canScale {boolean} Is it allowed to scale this shape. If true, then [ResizeBox](#ResizeBox) appears\n     * around shape and user can drag it to resize shape in different directions\n     * @param canRotate {boolean} Is it allowed to rotate this shape. If true, then [RotateBox](#RotateBox) appears\n     * around shape and user can drag it to rotate shape in different directions\n     * @param pointOptions {object} Default options for created points. See  [options](#SmartPoint+options)\n     * property of `SmartPoint` object.\n     * @param zIndex {number} Order of element in a stack of HTML elements\n     * (https://www.w3schools.com/cssref/pr_pos_z-index.asp). Elements if higher z-index value placed on top.\n     * @param bounds {object} Bounds for shape movement and points dragging. This is an object with `left`, `top`, `right`\n     * and `bottom` values. By default, all values are equal -1, which means that bounds not specified. If bounds not\n     * specified, then left, top, right and bottom of container element will be used for this\n     * @param visible {boolean} Shape is visible or not. By default, `true`.\n     * @param displayMode {SmartShapeDisplayMode} In which mode the shape is displayed: default mode or with resize\n     * or rotate box around it. See [SmartShapeDisplayMode](#SmartShapeDisplayMode)\n     * @param managed {boolean} Should this shape be managed by [SmartShapeManager](#SmartShapeManager). Default: true\n     * @param minWidth {number} Minimum width of shape. By default `-1` - unlimited\n     * @param minHeight {number} Minimum height of shape. By default `-1` - unlimited\n     * @param maxWidth {number} Maximum width of shape. By default `-1` - unlimited\n     * @param maxHeight {number} Maximum width of shape. By default `-1` - unlimited\n     * @param hasContextMenu {boolean} Should the shape have context menu. False by default\n     * @param minPoints {number} Minimum number of points in the shape. Default: 3.\n     * @param groupChildShapes {boolean} Should child shapes be grouped and move/resize/rotate/destroy together.\n     * True by default\n     * @param moveToTop {boolean} Should shape go to top based on \"zIndex\" when user clicks on it. True by default\n     * @param compactExport {boolean} If this is true, then it will save only coordinates of\n     * points, but not their properties during export to JSON using .toJSON() method\n     * @param forceCreateEvent {boolean} Internal parameter used by JSON import.\n     * By default, if shape does not have point when create, it does not emit SHAPE_CREATE event on init() method.\n     * If this option set to true, then init() methods emits SHAPE_CREATE event event for empty shapes.\n     * @param initialPoints {array} 2D array of initial coordinates of points in format [ [x,y], [x,y] ...]\n     * If this shape loaded from external resource and then modified, this array is a way to return back to initial\n     * coordinates\n     * @param zoomLevel {number} Current zoom level of shape. By default it is 1, which means that shape is not zoomed.\n     * If less than 1, than shape decreased, if greater than 1, then shape increased.\n     * to the bottom. Helps to move entire figure without need to change coordinates of each point. Default: `0`\n     * @param zoomable {boolean} Determines if shape can be zoomed in or out using context menu or mouse wheel.\n     * True by default\n     * @parap zoomStep {number} Defines to which extend the shape will be increased/decreased when apply Zoom in/Zoom out\n     * command from menu or drag mouse wheel. By default 0.1 .\n     to the bottom. Helps to move entire figure without need to change coordinates of each point. Default: `0`\n     * @param offsetX {number} Offset on X axis that shape moved from initial position when initially loaded from external source.\n     * @param offsetY {number} Offset on Y axis that shape moved from initial position when initially loaded.\n     * @param displayAsPath {boolean} Should display all children of shape as a single SVG path. Default - false.\n     * @param simpleMode {boolean} Simple load mode (do not create point objects)\n     * @param scaleFactorX {number} Scaling factor that shows to which extent the shape was scaled in current moment\n     * after create by X axis. By default 1 (not scaled)\n     * @param scaleFactorY {number} Scaling factor that shows to which extent the shape was scaled in current moment\n     * after create by Y axis. By default 1 (not scaled)\n     * @param flippedX {boolean}  Shows that the shape was flipped by X axis after create. By default false.\n     * @param flippedY {boolean}  Shows that the shape was flipped by Y axis after create. By default false.\n     * @param rotateAngle {number} Shows the angle to which the shape was rotated after create. By default 0.\n     * @type {object}\n     */\n    this.options = {\n        id: \"\",\n        name: \"Unnamed shape\",\n        maxPoints: -1,\n        fillGradient: null,\n        fillImage: null,\n        filters:{},\n        canDragShape: true,\n        canAddPoints: false,\n        canScale: false,\n        canRotate: false,\n        offsetX: 0,\n        offsetY: 0,\n        classes: \"\",\n        style: {\n            fill:\"none\",\n            \"fill-opacity\":1,\n            \"stroke\":\"black\",\n            \"stroke-width\":2,\n            \"stroke-opacity\":1,\n            \"stroke-dasharray\":0,\n            \"stroke-linecap\":\"square\"\n        },\n        pointOptions:{canDrag:true},\n        zIndex: 1000,\n        bounds: {left:-1,top:-1,right:-1,bottom:-1},\n        visible:true,\n        displayMode: SmartShapeDisplayMode.DEFAULT,\n        managed: true,\n        minWidth: -1,\n        minHeight : -1,\n        maxWidth: -1,\n        maxHeight: -1,\n        hasContextMenu:true,\n        minPoints: 3,\n        groupChildShapes: true,\n        moveToTop: true,\n        compactExport: false,\n        forceCreateEvent: false,\n        zoomLevel:1,\n        zoomable: true,\n        zoomStep: 0.1,\n        initialPoints: [],\n        displayAsPath: false,\n        simpleMode: false,\n        scaleFactorX: 1,\n        scaleFactorY: 1,\n        rotateAngle: 0,\n        flippedX: false,\n        flippedY: false,\n    };\n\n    /**\n     * Left position of the shape relative to container top left.\n     * (Read-only, calculated automatically based on points coordinates)\n     * @type {number}\n     */\n    this.left = 0;\n\n    /**\n     * Top position of the shape relative to container top left.\n     * (Read-only, calculated automatically based on points coordinates)\n     * @type {number}\n     */\n    this.top = 0;\n\n    /**\n     * Right position of the shape relative to container top left.\n     * (Read-only, calculated automatically based on points coordinates)\n     * @type {number}\n     */\n    this.right = 0;\n\n    /**\n     * Bottom position of the shape relative to container top left.\n     * (Read-only, calculated automatically based on points coordinates)\n     * @type {number}\n     */\n    this.bottom = 0;\n\n    /**\n     * Width of shape\n     * (Read-only, calculated automatically based on points coordinates)\n     * @type {number}\n     */\n    this.width = 0;\n\n    /**\n     * Height of shape\n     * (Read-only, calculated automatically based on points coordinates)\n     * @type {number}\n     */\n    this.height = 0;\n\n    /**\n     * Internal global unique identifier of shape. Generated automatically.\n     * @type {string}\n     */\n    this.guid = uuid();\n\n    /**\n     * Array of children of current shape\n     * @type {array}\n     */\n    this.children = [];\n\n    /**\n     * [ResizeBox](#ResizeBox) component, used to scale shape if\n     * `canScale` option enabled\n     * @type {ResizeBox}\n     */\n    this.resizeBox = null;\n\n    /**\n     * [RotateBox](#RotateBox) component, used to rotate shape if\n     * `canRotate` option enabled\n     * @type {RotateBox}\n     */\n    this.rotateBox = null;\n\n    /**\n     * Initial center of shape, when user started rotating the shape\n     * using Rotate Box\n     * @type {array} Coordinates as an array [x,y]\n     */\n    this.initCenter = null;\n\n    /**\n     * Context menu of shape that appear on right mouse click\n     * if `hasContextMenu` option is true\n     * @type {SmartShapeContextMenu}\n     */\n    this.shapeMenu = null;\n\n    /**\n     * Method used to construct SmartShape object with specified `points` and\n     * with specified `options`.\n     * Then it binds this object to specified `root` HTML node and displays it\n     * @param root {HTMLElement} HTML DOM node af a container element\n     * @param options {object} Options object to construct this shape ([see above](#SmartShape+options))\n     * @param points {array} 2D Array of points for shape polygon.\n     * Each element is [x,y] coordinate array\n     * @param show {boolean} Should display the shape by default. Default: true\n     * @returns {object} constructed SmartShape object\n     */\n    this.init = (root,options= null,points= null,show= true) => {\n        if (!root) {\n            console.error(\"Root HTML node not specified. Could not create shape.\")\n            return\n        }\n        if (SmartShapeManager.getShape(this)) {\n            console.error(\"This shape already initialized\");\n            return\n        }\n        this.root = root;\n        this.root.style.position = \"relative\";\n        if (this.options.hasContextMenu && (typeof(options.hasContextMenu)===\"undefined\" || options.hasContextMenu)) {\n            this.shapeMenu = new SmartShapeContextMenu(this)\n        }\n        this.eventListener = new SmartShapeEventListener(this);\n        this.setOptions(options);\n        this.groupHelper = new SmartShapeGroupHelper(this);\n        if (points && points.length) {\n            this.setupPoints(points, mergeObjects({}, this.options.pointOptions));\n            this.redraw();\n        }\n        this.eventListener.run();\n        if (this.shapeMenu && typeof(this.shapeMenu) === \"object\") {\n            this.shapeMenu.updateContextMenu();\n        }\n        if (show) {\n            this.applyDisplayMode();\n        }\n        if (points && points.length || this.options.forceCreateEvent) {\n            EventsManager.emit(ShapeEvents.SHAPE_CREATE, this, {});\n        }\n        return this;\n    }\n\n    /**\n     * Set specified options to the shape. You may not set all options, that exist, but only what you want to change.\n     * Options that you set by this method will be merged with already active options.\n     * @param options {object} Options object, [described above](#SmartShape+options)\n     */\n    this.setOptions = (options) => {\n        if (!options || typeof(options) !== \"object\") {\n            return\n        }\n        if (notNull(options.visible) && options.visible !== this.options.visible) {\n            if (!this.options.simpleMode) {\n                this.points.filter(point => typeof (point.setOptions) === \"function\")\n                    .forEach(point => point.options.visible = options.visible);\n            }\n            this.resizeBox && this.resizeBox.setOptions({shapeOptions:{visible:options.visible}});\n            this.rotateBox && this.rotateBox.setOptions({shapeOptions:{visible:options.visible}});\n        }\n        if (notNull(options.fillGradient)) {\n            this.options.fillGradient = {};\n        }\n        if (notNull(options.fillImage)) {\n            this.options.fillImage = {};\n        }\n        this.options = mergeObjects(this.options,options);\n        if (!this.options.simpleMode) {\n            this.points.filter(point => typeof (point.setOptions) === \"function\").forEach(point => {\n                point.setOptions(mergeObjects({}, this.options.pointOptions))\n                point.options.bounds = this.getBounds();\n                if (point.options.zIndex <= this.options.zIndex) {\n                    point.options.zIndex = this.options.zIndex + 1;\n                }\n                point.redraw();\n            })\n        }\n        if (this.shapeMenu && typeof(this.shapeMenu) === \"object\") {\n            this.shapeMenu.updateContextMenu();\n        }\n    }\n\n    /**\n     * @ignore\n     * Internal function that set points of figure\n     * @param points {array} 2D array of points to add. Each point is array of [x,y] coordinates\n     * @param pointOptions {object} Array of points options. Described in  [SmartPoint.options](#SmartPoint+options).\n     * Can be empty, in this case default `SmartShape.options.pointOptions` will be used,\n     * or default options of SmartPoint class itself.\n     */\n    this.setupPoints = (points,pointOptions={}) => {\n        this.points = [];\n        this.isNewObject = true;\n        this.addPoints(points,mergeObjects({},pointOptions));\n        this.isNewObject = false;\n        this.calcPosition();\n    }\n\n    /**\n     * Add point to shape.\n     * @param x {number} X coordinate relative to container left corner\n     * @param y {number} Y coordinate relative to container top corner\n     * @param pointOptions {object} Array of point options. Described in\n     * [SmartPoint.options](#SmartPoint+options). Can be empty,\n     * in this case default `SmartShape.options.pointOptions` will be used,\n     * or default options of SmartPoint class itself.\n     * @returns {object} [SmartPoint](#SmartPoint) object of added point\n     */\n    this.addPoint = (x,y,pointOptions= {}) => {\n        let point = this.putPoint(x, y,mergeObjects({},this.options.pointOptions, pointOptions));\n        if (!point) {\n            return null;\n        }\n        if (this.options.displayMode !== SmartShapeDisplayMode.DEFAULT) {\n            pointOptions.createDOMElement = true;\n        }\n        point = point.init(x, y, pointOptions);\n        if (point.element) {\n            try {\n                this.root.appendChild(point.element);\n            } catch (err) {}\n            point.updateContextMenu();\n        }\n        this.redraw();\n        if (this.options.hasContextMenu && !this.shapeMenu.contextMenu) {\n            this.shapeMenu.updateContextMenu();\n        }\n        return point;\n    }\n\n    /**\n     * Insert point to shape before specified point\n     * @param x {number} X coordinate relative to container left corner\n     * @param y {number} Y coordinate relative to container top corner\n     * @param beforePoint {array|SmartPoint} Coordinates of point as [x,y] array or as a SmartPoint object,\n     * before which point should be inserted\n     * @param pointOptions {object} Array of point options. Described in\n     * [SmartPoint.options](#SmartPoint+options). Can be empty,\n     * in this case default `SmartShape.options.pointOptions` will be used,\n     * or default options of SmartPoint class itself.\n     * @returns {object} [SmartPoint](#SmartPoint) object of added point\n     */\n    this.insertPoint = (x,y,beforePoint,pointOptions= {}) => {\n        let point = this.putPoint(x, y,mergeObjects({}, this.options.pointOptions, pointOptions),beforePoint);\n        if (!point) {\n            return null;\n        }\n        if (this.options.displayMode !== SmartShapeDisplayMode.DEFAULT) {\n            pointOptions.createDOMElement = true;\n        }\n        point = point.init(x, y, pointOptions);\n        try {\n            this.root.appendChild(point.element);\n        } catch (err) {};\n        point.updateContextMenu();\n        this.redraw();\n        if (this.options.hasContextMenu && !this.shapeMenu.contextMenu) {\n            this.shapeMenu.updateContextMenu();\n        }\n        return point;\n    }\n\n    /**\n     * Adds specified points to shape.\n     * @param points {array} 2D array of points to add. Each point is array of [x,y] coordinates\n     * @param pointOptions {object} Points options. Described in\n     * [SmartPoint.options](#SmartPoint+options). Can be empty,\n     * in this case default `SmartShape.options.pointOptions` will be used,\n     * or default options of SmartPoint class itself.\n     * */\n    this.addPoints = (points,pointOptions= {}) => {\n        if (!points || typeof(points) !== \"object\") {\n            return\n        }\n        if (this.options.simpleMode) {\n            if (typeof(points[0].x) !== \"undefined\") {\n                this.points = mergeObjects({},points);\n            } else {\n                this.points = points.map(point => ({x: point[0], y: point[1]}))\n            }\n        } else {\n            for (let point of points) {\n                const x = typeof(point.x) !== \"undefined\" ? point.x : point[0];\n                const y = typeof(point.y) !== \"undefined\" ? point.y : point[1];\n                if (this.options.displayMode !== SmartShapeDisplayMode.DEFAULT) {\n                    pointOptions.createDOMElement = true;\n                }\n                const p = this.putPoint(x, y,\n                    mergeObjects({}, this.options.pointOptions,pointOptions)\n                )\n                if (p) {\n                    p.init(p.x, p.y, pointOptions)\n                    if (p.element) {\n                        try {\n                            this.root.appendChild(p.element);\n                            p.redraw();\n                        } catch (err) {}\n                    }\n                }\n            }\n        }\n\n        if (this.options.hasContextMenu && !this.shapeMenu.contextMenu) {\n            this.shapeMenu.updateContextMenu();\n        }\n    }\n\n    /**\n     * @ignore\n     * Internal method that used to add point to the shape\n     * @param x {number} X coordinate relative to container left corner\n     * @param y {number} Y coordinate relative to container top corner\n     * @param pointOptions - Points options. Described in\n     * [SmartPoint.options](#SmartPoint+options). Can be empty,\n     * in this case default `SmartShape.options.pointOptions` will be used,\n     * or default options of SmartPoint class itself.\n     * @param beforePoint {array|SmartPoint} Coordinates of point as [x,y] array or as a SmartPoint object,\n     * before which point should be inserted\n     * @returns {object} [SmartPoint](#SmartPoint) object of added point\n     */\n    this.putPoint = (x,y,pointOptions= {}, beforePoint=null) => {\n        let beforeIndex = this.getPointIndex(beforePoint);\n        if (beforePoint && beforeIndex === -1) {\n            return null;\n        }\n        if (!this.isNewObject && this.findPoint(x,y)) {\n            return null;\n        }\n        pointOptions.bounds = this.getBounds();\n        pointOptions.zIndex = this.options.zIndex+1;\n        const point = new SmartPoint();\n        point.x = x;\n        point.y = y;\n        if (this.options.displayMode !== SmartShapeDisplayMode.DEFAULT) {\n            pointOptions.createDOMElement = true;\n        }\n        point.setOptions(pointOptions);\n        if (beforePoint && beforeIndex !== -1) {\n            this.points.splice(beforeIndex ,0,point)\n        } else {\n            this.points.push(point);\n        }\n        return point;\n    }\n\n    /**\n     * Method returns the closest point from specified array of points or all points of this shape\n     * to specified x,y coordinates.\n     * @param x {number} X coordinate\n     * @param y {number} Y coordinate\n     * @param points {array} Array of coordinates of points to. Each coordinate is [x,y] array. If not specified\n     * then all points of this shapes used.\n     * @returns {null|Object|*}\n     */\n    this.getClosestPoint = (x,y,points=null) => {\n        if (!points) {\n            points = this.getPointsArray();\n        }\n        if (!points || !points.length) {\n            return null;\n        }\n        points = points.filter(([x1,y1]) => !isNaN(parseFloat(x1)) && !isNaN(parseFloat(y1)));\n        if (points.length === 1) {\n            return this.points[0];\n        }\n        if (!points || !points.length) {\n            return null;\n        }\n        const cords = points\n            .map(([x1,y1]) => ({x:x1,y:y1,d:distance(x,y,x1,y1)}))\n            .reduce((s1,s2) => s1.d < s2.d ? s1 : s2);\n        return this.findPoint(cords.x,cords.y);\n    }\n\n    /**\n     * @ignore\n     * This method returns the line which is closest to specified (x,y) point.\n     * @param x X coordinate\n     * @param y Y coordinate\n     * @returns {object} Object with fields `point1` - Start point of line,\n     * `point2` - end point of line, `d` - distance from this line to point (x,y)\n     */\n    this.getClosestLine = (x,y) => {\n        return this.points\n            .map((point1,index) => {\n                let point2 = null;\n                if (index < this.points.length-1) {\n                    point2 = this.points[index+1];\n                } else {\n                    point2 = this.points[0];\n                }\n                return [point1,point2,distanceFromLine(x,y,point1.x,point1.y,point2.x,point2.y)]\n            })\n            .filter(l => l[2]>=0)\n            .reduce((l1,l2) => l1[2] < l2[2] ? l1 : l2)\n    }\n\n    /**\n     * Method returns and index of specified point in points array\n     * @param point {array|SmartPoint} Point to find index for. Can be specified either as\n     * coordinates array [x,y] or as a SmartPoint object\n     * @returns {number} Index of point or -1 if not found\n     */\n    this.getPointIndex = (point) => {\n        if (point && point.length) {\n            if (point.length !== 2) {\n                return -1\n            }\n            point = this.findPoint(...point);\n        }\n        if (!point || !this.isShapePoint(point)) {\n            return -1;\n        }\n        return this.points.indexOf(point);\n    }\n\n    /**\n     * Method used to delete all points from shape\n     */\n    this.deleteAllPoints = () => {\n        if (this.options.simpleMode) {\n            this.points = [];\n        } else {\n            while (this.points.length) {\n                this.points[0].destroy();\n            }\n        }\n    }\n\n    /**\n     * Method used to delete point with specified coordinates.\n     * If point with specified coordinates not found then just\n     * do nothing\n     * @param x {number} X coordinate of point\n     * @param y {number} Y coordinate of point\n     */\n    this.deletePoint = (x,y) => {\n        if (this.points.length-1 < this.options.minPoints) {\n            return\n        }\n        const point = this.findPoint(x,y);\n        if (point && typeof(point.destroy) === \"function\") {\n            point.destroy();\n        } else {\n            this.points.splice(this.points.indexOf(point),1);\n        }\n    }\n\n    /**\n     * Method returns SmartPoint object of point with specified coordinates or null, if point not found\n     * @param x {number} X coordinate of point\n     * @param y {number} Y coordinate of point\n     * @returns {null|object}  [SmartPoint](#SmartPoint) object instance of point,\n     * or null if point does not exist\n     */\n    this.findPoint = (x,y) => {\n        const point = this.points.find(item => item.x === x && item.y === y)\n        if (typeof(point) === \"undefined\" || !point) {\n            return null;\n        }\n        return point\n    }\n\n    /**\n     * Method returns SmartPoint object for point with specified ID or null, if point not found\n     * @param id {string} ID of point, provided to it as an options\n     * @returns {null|object} [SmartPoint](#SmartPoint) object instance of point,\n     * or null if point does not exist\n     */\n    this.findPointById = (id) => {\n        const point = this.points.find(item => item.options && item.options.id === id)\n        if (typeof(point) === \"undefined\" || !point) {\n            return null;\n        }\n        return point\n    }\n\n    /**\n     * Returns 2D array of points coordinates in format [ [x,y], [x,y], [x,y] ... ].\n     * @returns {array} 2D array of points in format [ [x,y], [x,y], [x,y] ... ]\n     */\n    this.getPointsArray = () => {\n        let result = [];\n        if (this.points && typeof(this.points) === \"object\" && this.points.length) {\n            result = this.points.map(point => [point.x,point.y])\n        }\n        return result;\n    }\n\n    /**\n     * Moves shape to specific position. It only changes coordinates of points, but do not\n     * redraw the shape on new position. So, you need to call `redraw` yourself after move.\n     * @param x {number} new X coordinate\n     * @param y {number} new Y coordinate\n     * @param redraw {boolean} should the function redraw the shape after move. True by default\n     * @param fast {boolean} if true, then only change shape dimensions without recalculate points\n     */\n    this.moveTo = (x,y,redraw= true,respectBounds=true,fast=false) => {\n        const bounds = this.getBounds();\n        const pos = this.getPosition(this.options.groupChildShapes);\n        let newX = x;\n        let newY = y;\n        if (respectBounds) {\n            newX = x + pos.width > bounds.right ? bounds.right - pos.width : x;\n            newY = y + pos.height > bounds.bottom ? bounds.bottom - pos.height : y;\n        }\n        this.moveBy(newX-pos.left,newY-pos.top, redraw, fast);\n        this.calcPosition();\n    }\n\n    /**\n     * Moves shape by specified number of pixels by X and Y.\n     * @param stepX {number} number of pixels to move horizontally\n     * @param stepY {number} number of pixes to move vertically\n     * @param redraw {boolean} should the function redraw the shape after move. True by default\n     * @param fast {boolean} if true, then only change shape dimensions without recalculate points\n     */\n    this.moveBy = (stepX, stepY,redraw=true,fast=false) => {\n        for (let index in this.points) {\n            this.points[index].x += stepX;\n            this.points[index].y += stepY;\n            if (!this.options.simpleMode && redraw && typeof (this.points[index].redraw) === \"function\") {\n                this.points[index].redraw();\n            }\n        }\n        this.options.offsetX += stepX;\n        this.options.offsetY += stepY;\n        this.left += stepX;\n        this.top += stepY;\n        this.right += stepX;\n        this.bottom += stepY;\n        const children = this.getChildren(true)\n        if (redraw) {\n            if (!fast) {\n                this.redraw();\n            } else {\n                if (this.svg) {\n                    this.svg.style.left = this.left + \"px\";\n                    this.svg.style.top = this.top + \"px\";\n                }\n            }\n        }\n        if (children.length && this.options.groupChildShapes) {\n            children.forEach(child => {\n                for (let point of child.points) {\n                    point.x += stepX;\n                    point.y += stepY;\n                    if (!this.options.simpleMode && redraw && typeof (point.redraw) === \"function\") {\n                        point.redraw();\n                    }\n                }\n                child.left += stepX;\n                child.top += stepY;\n                child.right += stepX;\n                child.bottom += stepY;\n                child.options.offsetX += stepX;\n                child.options.offsetY += stepY;\n                if (fast && child.svg) {\n                    child.svg.style.left = child.left + \"px\";\n                    child.svg.style.top = child.top + \"px\";\n                }\n            });\n        }\n        if (fast) {\n            SmartShapeDrawHelper.redrawResizeBox(this);\n            SmartShapeDrawHelper.redrawRotateBox(this);\n        }\n    }\n\n    /**\n     * Scales image to fit specified `width` and `height`. It only changes coordinates of points, but do not\n     * redraws the shape on new position. So, you need to call `redraw` yourself after scale.\n     * @param width {number|null} new width. If not specified, then will be calculated automatically based on height to\n     * preserve aspect ratio\n     * @param height {number|null} new height. If not specifie, then will be calculated automatically based on width\n     * to preserve aspect ratio\n     */\n    this.scaleTo = (width=null,height= null,includeChildren=null) => {\n        const bounds = this.getBounds();\n        this.calcPosition();\n        if (!width && !height) {\n            return null;\n        }\n        const pos = this.getPosition(includeChildren || this.options.groupChildShapes);\n        if (pos.width === width && pos.height === height) {\n            return\n        }\n        [width,height] = this.applyScaleRestriction(...applyAspectRatio(width,height,pos.width,pos.height));\n        if (pos.width>=10 && width<10) {\n            width = 10;\n        }\n        if (pos.height>=10 && height<10) {\n            height = 10;\n        }\n        let newWidth = abs(pos.left) + width > bounds.right && bounds.right !== -1 ? bounds.right - abs(pos.left) : width;\n        let newHeight = abs(pos.top) + height > bounds.bottom && bounds.bottom !== -1 ? bounds.bottom - abs(pos.top) : height;\n        let scaleX = abs(newWidth/pos.width);\n        let scaleY = abs(newHeight/pos.height);\n        this.scaleBy(scaleX,scaleY,includeChildren);\n    }\n\n    /**\n     * Method used to scale the shape by specified ratio by X and Y\n     * @param scaleX {number} Horizontal scale ratio\n     * @param scaleY {number} Vertical scale ratio\n     */\n    this.scaleBy = (scaleX=null,scaleY= null,includeChildren=null) => {\n        if (scaleX === 1 && scaleY === 1) {\n            return\n        }\n        const pos = this.getPosition(includeChildren || this.options.groupChildShapes);\n        this.points.forEach(point => {\n            point.x = (point.x-pos.left)*scaleX+pos.left;\n            point.y = (point.y-pos.top)*scaleY+pos.top}\n        );\n        this.width *= scaleX;\n        this.height *= scaleY;\n        this.options.scaleFactorX *= scaleX;\n        this.options.scaleFactorY *= scaleY;\n        if (this.options.groupChildShapes || includeChildren) {\n            this.getChildren(true).forEach(child => {\n                child.points.forEach(point => {\n                        point.x = (point.x - pos.left) * scaleX + pos.left;\n                        point.y = (point.y - pos.top) * scaleY + pos.top\n                    }\n                );\n                child.width *= scaleX;\n                child.height *= scaleY;\n                child.options.scaleFactorX *= scaleX;\n                child.options.scaleFactorY *= scaleY;\n                child.calcPosition();\n            })\n            if (!this.options.simpleMode && this.options.visible) {\n                this.getChildren().forEach(child => child.redraw());\n            }\n        }\n        this.calcPosition();\n    }\n\n    /**\n     * Method used to zoom shape by specified level\n     * @param level {number} Zoom level. Can be any positive number. If number is greater than 1,\n     * then it increases the size of shape, if it between 0 and 1, then it decreases the shape.\n     */\n    this.zoomBy = (level) => {\n        this.options.zoomLevel *= level;\n        this.scaleBy(level,level);\n        if (this.options.groupChildShapes) {\n            this.getChildren(true).forEach(child => child.options.zoomLevel *= level);\n        }\n    }\n\n    /**\n     * @ignore\n     * Method returns width and height of shape after applying\n     * `minWidth`, `minHeight`, `maxWidth` and `maxHeight` restrictions\n     * to it\n     * @param width {number} Original width\n     * @param height {number} Original height\n     * @returns {array} Returns array in a format [width,height] which is not\n     * less than minWidth and minHeight and not greater than maxWidth and maxHeight\n     */\n    this.applyScaleRestriction = (width,height) => {\n        if (this.options.minWidth !== -1 && width < this.options.minWidth) {\n            width = this.options.minWidth;\n        }\n        if (this.options.minWidth !== -1 && height < this.options.minHeight) {\n            height = this.options.minHeight;\n        }\n        if (this.options.minWidth !== -1 && width > this.options.maxWidth) {\n            width = this.options.maxWidth;\n        }\n        if (this.options.minWidth !== -1 && height > this.options.maxHeight) {\n            height = this.options.maxHeight;\n        }\n        return [width,height];\n    }\n\n    /**\n     * Method used to rotate this shape by specified angle around it's center.\n     * @param angle {number} Angle in degrees. Positive - clockwise, Negative - counterclock-wise\n     * @param centerX {number} X coordinate of center around which to rotate the shape. By default it's a center\n     * of the shape\n     * @param centerY {number} Y coordinate of center around which to rotate the shape. By default it's a center\n     * of the shape\n     * @param checkBounds {boolean} Should the function check that shape won't go beyond defined bounds or\n     * container bounds after rotation. By default false.\n     */\n    this.rotateBy = (angle,centerX=null,centerY=null,checkBounds=false) => {\n        this.calcPosition();\n        const pos = this.getPosition(this.options.groupChildShapes);\n        let [shapeCenterX,shapeCenterY] = this.getCenter(this.options.groupChildShapes)\n        const parent = this.getRootParent(true);\n        if (parent && parent.options.groupChildShapes) {\n            [shapeCenterX,shapeCenterY] = parent.getCenter(parent.options.groupChildShapes);\n        }\n        if (!centerX) {\n            centerX = shapeCenterX;\n        }\n        if (!centerY) {\n            centerY = shapeCenterY\n        }\n        if (this.initCenter) {\n            [centerX,centerY] = this.initCenter;\n        }\n        if (checkBounds && (!this.isInBounds(...getRotatedCoords(angle,pos.left,pos.top,centerX,centerY)) ||\n            !this.isInBounds(...getRotatedCoords(angle,pos.right,pos.top,centerX,centerY)) ||\n            !this.isInBounds(...getRotatedCoords(angle,pos.left,pos.bottom,centerX,centerY)) ||\n            !this.isInBounds(...getRotatedCoords(angle,pos.right,pos.bottom,centerX,centerY)))) {\n            return\n        }\n        this.points.forEach(point => {\n            if (typeof(point.rotateBy) === \"function\") {\n                point.rotateBy(angle, centerX, centerY)\n            } else {\n                [point.x,point.y] = getRotatedCoords(angle, point.x,point.y, centerX,centerY)\n            }\n        });\n        this.options.rotateAngle += angle;\n        if (this.options.groupChildShapes) {\n            this.getChildren(true).forEach(child => {\n                child.points.forEach(point => {\n                    if (typeof(point.rotateBy) === \"function\") {\n                        point.rotateBy(angle, centerX, centerY)\n                    } else {\n                        [point.x,point.y] = getRotatedCoords(angle, point.x,point.y, centerX,centerY)\n                    }\n                });\n                child.options.rotateAngle += angle;\n                child.redraw();\n            })\n        }\n    }\n\n    /**\n     * Method used to flip shape and its children vertically or horizontally\n     * @param byX {boolean} Flip horizontally\n     * @param byY {boolean} Flip vertically\n     * @param includeChildren {boolean} Flip includes children shapes\n     */\n    this.flip = (byX,byY,includeChildren) => {\n        if (!byX && !byY) {\n            return\n        }\n        includeChildren = includeChildren || this.options.groupChildShapes;\n        this.calcPosition()\n        let children = includeChildren ? this.getChildren(true) : null;\n        children && children.forEach(child => child.calcPosition());\n        const pos = this.getPosition(includeChildren);\n        this.points.forEach(point=>this.flipPoint(point,byX,byY,pos));\n        if (byX) {\n            this.options.flippedX = !this.options.flippedX;\n        }\n        if (byY) {\n            this.options.flippedY = !this.options.flippedY;\n        }\n        if (!children) {\n            return\n        }\n        children.forEach(child=>{\n            if (byX) {\n                child.options.flippedX = !child.options.flippedX;\n                child.options.flippedY = !child.options.flippedY;\n            }\n            child.points.forEach(point => child.flipPoint(point,byX,byY,pos))\n        })\n    }\n\n    /**\n     * @ignore\n     * Internal method to flip specified point over X or/and Y axis\n     * according to specified dimensions of shape\n     * @param point {SmartPoint} Point object (or any object with x and y fields)\n     * @param byX {boolean} Flip horizontally\n     * @param byY {boolean} Flip vertically\n     * @param pos {object} Shape dimensions, object with fields: `top`,`left`,`bottom`,`right`,`width`,`height`\n     * @returns {SmartPoint} point object with flipped coordinates\n     */\n    this.flipPoint = (point, byX, byY, pos) => {\n        [point.x,point.y] = flipPoint(point.x,point.y,byX,byY,pos);\n        return point\n    }\n\n    /**\n     * Method used to change shape z-index to topmost\n     */\n    this.moveToTop = () => {\n        SmartShapeDrawHelper.moveShapeToTop(this);\n    }\n\n    /**\n     * Method used to change shape z-index to bottommost\n     */\n    this.moveToBottom = () => {\n        SmartShapeDrawHelper.moveShapeToBottom(this);\n    }\n\n    /**\n     * Method used to change shape z-index to specified number\n     * @param zIndex {number} z-index value\n     */\n    this.changeZIndex = (zIndex) => {\n        SmartShapeDrawHelper.changeShapeZIndex(this,zIndex)\n    }\n\n    /**\n     * @ignore\n     * Method used to check is specified coordinate not goes beyond bounds\n     * @param x {number} X coordinate\n     * @param y {number} Y coordinate\n     * @returns true if it does not go beyond or false otherwise.\n     */\n    this.isInBounds = (x,y) => {\n        const [width,height] = this.getMaxPointSize();\n        const bounds = this.getBounds();\n        return (x >= bounds.left + width /2) &&\n            (x <= bounds.right - width/2) &&\n            (y >= bounds.top + height/2) &&\n            (y <= bounds.bottom - height/2)\n    }\n\n    /**\n     * Method used to redraw shape polygon. Runs automatically when add/remove points or change their properties.\n     */\n    this.redraw = () => {\n        this.applyDisplayMode();\n        SmartShapeDrawHelper.draw(this);\n        if (this.options.groupChildShapes && !this.options.displayAsPath) {\n            this.getChildren().forEach(child=>child.redraw());\n        }\n    }\n\n    /**\n     * @ignore\n     * Method used to setup shape drawing depending on current `options.displayMode`.\n     * Depending on this it shows either ResizeBox around it, or RotateBox, or nothing.\n     */\n    this.applyDisplayMode = () => {\n        this.points.filter(point=>typeof(point.setOptions) === \"function\").forEach(point => {\n            const options = {zIndex: this.options.zIndex + 15}\n            if (this.options.displayMode === SmartShapeDisplayMode.DEFAULT) {\n                options.createDOMElement = false;\n            } else {\n                options.createDOMElement = true;\n            }\n            point.setOptions(options);\n            if (point.element) {\n                point.element.style.zIndex = point.options.zIndex;\n                if (this.options.displayMode === SmartShapeDisplayMode.DEFAULT && !point.options.forceDisplay) {\n                    point.element.style.display = 'none';\n                }\n            }\n        })\n        if (this.options.groupChildShapes) {\n            this.getChildren(true).forEach(child => {\n                child.points.filter(point=>typeof(point.setOptions) === \"function\").forEach(point => {\n                    if (this.options.displayMode === SmartShapeDisplayMode.DEFAULT) {\n                        point.setOptions({createDOMElement:false});\n                    } else {\n                        point.setOptions({createDOMElement:true});\n                    }\n                    if (point.options.visible && !point.options.hidden && point.options.canDrag) {\n                        if (point.element) {\n                            point.element.style.display = '';\n                        }\n                    }\n                })\n                child.options.displayMode = this.options.displayMode;\n            })\n        }\n    }\n\n    /**\n     * Method used to switch display mode of SmartShape from Default to Resize to Rotate.\n     * @param mode {SmartShapeDisplayMode} Display mode to switch to. One of values of\n     * [SmartShapeDisplayMode](#SmartShapeDisplayMode). If not specified, then automatically\n     * switches to next mode in the following loop sequence: DEFAULT -> SCALE -> ROTATE -> DEFAULT\n     */\n    this.switchDisplayMode = (mode=null) => {\n        if (!mode) {\n            mode = this.getNextDisplayMode();\n        }\n        if ((mode === SmartShapeDisplayMode.SCALE && !this.options.canScale) ||\n            (mode === SmartShapeDisplayMode.ROTATE && !this.options.canRotate) ||\n            (mode === SmartShapeDisplayMode.SELECTED && (this.points.length && !this.options.pointOptions.canDrag))) {\n            mode = SmartShapeDisplayMode.DEFAULT;\n        }\n        this.options.displayMode = mode;\n        if (this.options.simpleMode) {\n            this.applyDisplayMode();\n        } else {\n            this.redraw();\n        }\n        if (mode === SmartShapeDisplayMode.DEFAULT && this.options.groupChildShapes) {\n            setTimeout(() => {\n                this.getChildren(true).forEach(child => {\n                    child.switchDisplayMode(mode)\n                    if (this.options.simpleMode) {\n                        child.applyDisplayMode();\n                    } else {\n                        child.redraw();\n                    }\n                });\n            },10)\n        }\n    }\n\n    /**\n     * @ignore\n     * Method returns next display mode after current one\n     * in the following sequence DEFAULT -> SCALE -> ROTATE\n     * taking in account `canScale` and `canRotate` options\n     * @returns {SmartShapeDisplayMode|string|*}\n     */\n    this.getNextDisplayMode = () => {\n        let mode;\n        if (this.options.displayMode === SmartShapeDisplayMode.DEFAULT) {\n            mode = SmartShapeDisplayMode.SELECTED;\n        } else if (this.options.displayMode === SmartShapeDisplayMode.SELECTED) {\n            mode = SmartShapeDisplayMode.SCALE;\n        } else if (this.options.displayMode === SmartShapeDisplayMode.SCALE) {\n            mode = SmartShapeDisplayMode.ROTATE;\n        } else {\n            mode = SmartShapeDisplayMode.DEFAULT;\n        }\n        if (mode === SmartShapeDisplayMode.SELECTED && !this.options.pointOptions.canDrag) {\n            mode = SmartShapeDisplayMode.SCALE\n        }\n        if (mode === SmartShapeDisplayMode.SCALE && !this.options.canScale) {\n            mode = SmartShapeDisplayMode.ROTATE\n        }\n        if (mode === SmartShapeDisplayMode.ROTATE && !this.options.canRotate) {\n            mode = SmartShapeDisplayMode.DEFAULT;\n        }\n        return mode\n    }\n\n    /**\n     * @ignore\n     * Internal method that used to calculate shape dimensions, based on point coordinates.\n     * Set left,top,right,bottom,width and height of shape.\n     */\n    this.calcPosition = () => {\n        if (!this.points.length) {\n            return;\n        }\n        Object.assign(this,this.calcPositionFromPointsArray(this.getPointsArray()))\n    }\n\n    /**\n     * @ignore\n     * Service method that used to update shape dimensions based on\n     * changed point coordinates (or if point removed)\n     * @param x {number} X coordinate\n     * @param y {number} Y coordinate\n     * @param removed {boolean} Indicates that point with specified (x,y) removed\n     */\n    this.updatePosition = (x,y,removed) => {\n        if (x<this.left) {\n            if (removed) {\n                this.left = this.oldLeft;\n            } else {\n                this.oldLeft = this.left;\n                this.left = x;\n            }\n        }\n        if (x>this.right) {\n            if (removed) {\n                this.right = this.oldRight\n            } else {\n                this.oldRight = this.right;\n                this.right = x\n            }\n        }\n        if (y<this.top) {\n            if (removed) {\n                this.top = this.oldTop;\n            } else {\n                this.oldTop = this.top;\n                this.top = y;\n            }\n        }\n        if (y>this.bottom) {\n            if (removed) {\n                this.bottom = this.oldBottom;\n            } else {\n                this.oldBottom = this.bottom;\n                this.bottom = y;\n            }\n        }\n        this.width = this.right - this.left || 1\n        this.height = this.bottom - this.top || 1\n    }\n\n    /**\n     * @ignore\n     * Function calculates shape dimensions based on provided points array.\n     * @param points {array} 2D array of points in format [ [x,y], [x,y] [x,y] ...]\n     * @returns {object} Object with fields: `left`,`top`,`right`,`bottom`,`width`,`height`\n     */\n    this.calcPositionFromPointsArray = (points) => {\n        const result = {};\n        result.left = points.map(point => point[0]).reduce((minx,x) => x < minx ? x : minx);\n        result.top = points.map(point => point[1]).reduce((miny,y) => y < miny ? y : miny);\n        result.right = points.map(point => point[0]).reduce((maxx,x) => x > maxx ? x : maxx);\n        result.bottom = points.map(point => point[1]).reduce((maxy,y) => y > maxy ? y : maxy);\n        result.width = abs(result.right-result.left) || 1;\n        result.height = abs(result.bottom-result.top) || 1;\n        return result;\n    }\n\n    /**\n     * Method used to get current position of shape\n     * @param forGroup {boolean} If true, then it calculates left, top, right and bottom of this shape\n     * and all its children\n     * @returns {object} Position with fields:\n     * `top`,`left`,`right`,`bottom`,`width`,`height`\n     */\n    this.getPosition = (forGroup=false) => {\n        if (forGroup) {\n            return this.groupHelper.getPosition();\n        }\n        return {\n            top: this.top,\n            left: this.left,\n            bottom: this.bottom,\n            right: this.right,\n            width: parseFloat(this.width),\n            height: parseFloat(this.height)\n        }\n    }\n\n    /**\n     * Method returns the bounds of this shape, e.g. inside which square it's allowed to drag it.\n     * By default, if [options.bounds](#SmartShape+options) not specified, the bounds of shape are equal to\n     * the bounds of shape's container element (clientLeft, clientTop, clientLeft+clientWidth, clientTop+clientHeight)\n     * @returns {object} Object with `left`, `top`, `right` and `bottom` fields.\n     */\n    this.getBounds = () => {\n        return {\n            left: this.options.bounds.left !== -1 ? this.options.bounds.left : this.root.style.display === 'none' ? -1 : this.root.clientLeft,\n            top: this.options.bounds.top !== -1 ? this.options.bounds.top : this.root.style.display === 'none' ? -1 : this.root.clientTop,\n            right: this.options.bounds.right !== -1 ? this.options.bounds.right : this.root.style.display === 'none' ? -1 : this.root.clientLeft + this.root.clientWidth,\n            bottom: this.options.bounds.bottom !== -1 ? this.options.bounds.bottom : this.root.style.display === 'none' ? -1 : this.root.clientTop + this.root.clientHeight\n        }\n    };\n\n    /**\n     * Method returns true if specified point exists in the array of this shape or false if not.\n     * @param point [SmartPoint](#SmartPoint) object of point to search\n     * @returns {boolean} True if this point exists and false if not\n     */\n    this.isShapePoint = (point) => {\n        return !!this.points.find(item => item === point);\n    }\n\n    /**\n     * Method returns true if point with specified coordinates lays\n     * inside shape or false otherwise.\n     * @param x {number} X coodrinate\n     * @param y {number} Y coordinate\n     * @returns {boolean} True if (x,y) belongs to shape and false otherwise\n     */\n    this.belongsToShape = (x,y,applyOffset=true) => {\n        if (!this.isInShapePolygon(x,y)) {\n            return false;\n        }\n        const off = getOffset(this.root)\n        if (this.findPoint(x-off.left,y-off.top)) {\n            return true;\n        }\n        let points = this.getPointsArray();\n        if (applyOffset) {\n            points = points.map(point => ([point[0]+off.left,point[1]+off.top]));\n        }\n        return isPointInsidePolygon(points,[x,y]);\n    }\n\n    this.isInShapePolygon = (x,y) => {\n        const off = getOffset(this.root)\n        return x>=this.left+off.left && x<=this.right+off.left && y>=this.top+off.top && y <= this.bottom+off.top;\n    }\n\n    /**\n     * Uniform method that used to add event handler of specified type to this object.\n     * SmartShape can emit events, defined in [ShapeEvents](#ShapeEvents) enumeration. So, you can\n     * listen any of these events.\n     * @param eventName {string} - Name of event. Use one of names, defined for [ShapeEvents](#ShapeEvents).\n     * @param handler {function} - Function that used as an event handler\n     * @returns {function} - Pointer to added event handler. Should be used to remove event listener later.\n     */\n    this.addEventListener = (eventName,handler) => {\n        return this.eventListener.addEventListener(eventName,handler)\n    }\n\n    /**\n     * Uniform method that used to remove event handler, that previously added\n     * to this object.\n     * @param eventName {string} Name of event to remove listener from\n     * @param listener {function} Pointer to event listener, that added previously.\n     * It was returned from [addEventListener](#ResizeBox+addEventListener) method.\n     */\n    this.removeEventListener = (eventName,listener) => {\n        this.eventListener.removeEventListener(eventName,listener);\n    }\n\n    /**\n     * Method used to show shape if it has hidden\n     */\n    this.show = () => {\n        this.setOptions({visible:true});\n        this.getChildren().forEach(child => {\n            child.options.visible = true;\n        });\n        this.redraw();\n    }\n\n    /**\n     * Method used to hide the shape\n     */\n    this.hide = () => {\n        this.setOptions({visible:false});\n        this.getChildren().forEach(child => {\n            child.options.visible = false;\n        });\n        this.redraw();\n    }\n\n    /**\n     * Destroys the shape. Destroys all points, removes event listeners and removes the shape from screen.\n     * But variable continue existing. To completely remove the shape,\n     * set the variable to 'null' after calling this method.\n     */\n    this.destroy = () => {\n        EventsManager.emit(ShapeEvents.SHAPE_DESTROY,this,{});\n        if (this.eventListener) {\n            this.eventListener.destroy();\n        }\n        if (this.resizeBox) {\n            this.resizeBox.destroy();\n        }\n        if (this.rotateBox) {\n            this.rotateBox.destroy();\n        }\n        if (this.root) {\n            try {\n                if (this.svg) {\n                    this.root.removeChild(this.svg);\n                }\n                this.points.filter(point => point.element).forEach(point => this.root.removeChild(point.element))\n            } catch (err) {}\n        }\n        if (this.options.groupChildShapes) {\n            this.getChildren(true).forEach(child => {\n                child.destroy()\n            });\n        }\n        if (this.shapeMenu && this.shapeMenu.contextMenu) {\n            this.shapeMenu.destroyContextMenu();\n        }\n        const parent = this.getParent();\n        if (parent) {\n            parent.removeChild(this);\n        }\n        this.points.filter(point=>typeof(point.destroy) === \"function\").forEach(point => point.destroy());\n        this.points = [];\n    }\n\n    /**\n     * @ignore\n     * Used to setup [ResizeBox](#ResizeBox) around shape if shape scaling is enabled\n     */\n    this.setupResizeBox = () => {\n        if (!this.points.length) {\n            return null;\n        }\n        const bounds = this.getResizeBoxBounds();\n        this.resizeBox = new ResizeBox().init(this.root,bounds.left,bounds.top,bounds.width,bounds.height,{\n            zIndex: this.options.zIndex+1,\n            id: this.options.id+\"_resizebox\",\n            shapeOptions:{\n                canDragShape: false,\n                visible: this.options.visible,\n                managed: false,\n                hasContextMenu:false\n            }\n        })\n        this.resizeBox.redraw();\n        this.eventListener.addResizeEventListener();\n    }\n\n    /**\n     * @ignore\n     * Used to setup [Rotate](#RotateBox) around shape if shape rotation is enabled\n     */\n    this.setupRotateBox = () => {\n        if (!this.points.length) {\n            return null;\n        }\n        const bounds = this.getResizeBoxBounds();\n        this.rotateBox = new RotateBox().init(this.root,bounds.left,bounds.top,bounds.width,bounds.height,{\n            zIndex: this.options.zIndex+1,\n            id: this.options.id+\"_rotatebox\",\n            shapeOptions:{\n                canDragShape: false,\n                visible: this.options.visible,\n                managed: false,\n                hasContextMenu: false\n            }\n        })\n        this.rotateBox.redraw();\n        this.eventListener.addRotateEventListener();\n    }\n\n    /**\n     * @ignore\n     * Returns dimensions of resize box around shape according to shape dimensions\n     * @returns {{top: number, left: number, bottom: *, width: *, right: *, height: *}}\n     */\n    this.getResizeBoxBounds = () => {\n        let pos = this.getPosition(this.options.groupChildShapes);\n        const parent = this.getRootParent(true);\n        if (parent && parent.options.groupChildShapes) {\n            if (parent.options.displayAsPath) {\n                pos = parent.getPosition(parent.options.groupChildShapes);\n            } else {\n                pos = this.getPosition(this.options.groupChildShapes);\n            }\n        }\n        const [pointWidth,pointHeight] = this.getMaxPointSize();\n        const result = {\n            left: pos.left - pointWidth,\n            right: pos.right + pointWidth,\n            top: pos.top - pointHeight,\n            bottom: pos.bottom + pointHeight,\n            width: pos.width + (pointWidth)*2,\n            height: pos.height + (pointHeight)*2,\n        }\n        return result;\n    }\n\n    /**\n     * @ignore\n     * Method finds and return the size of the biggest point in this shape\n     * @returns {array} [width,height]\n     */\n    this.getMaxPointSize = () => {\n        if (!this.points.length) {\n            return [0,0];\n        }\n        const pointWidth = this.points.map(point=>point.options ? point.options.width : 0).reduce((w1,w2) => Math.max(w1,w2));\n        const pointHeight = this.points.map(point=>point.options? point.options.height : 0).reduce((h1,h2) => Math.max(h1,h2));\n        return [pointWidth,pointHeight];\n    }\n\n    /**\n     * Method returns coordinates of the center of the shape.\n     * @param forGroup {boolean} Should get center of all shapes in the group. Default: false\n     * @returns {array} Center of a shape as an array [x,y]\n     */\n    this.getCenter = (forGroup=false) => {\n        const pos = this.getPosition(forGroup)\n        return [pos.left+pos.width/2, pos.top+pos.height/2]\n    };\n\n    /**\n     * @ignore\n     * Internal method that used to return SVG element to which this shape belongs\n     * If this is a root shape, then just returns svg of current shape object,\n     * if it's a child, then SVG element of the parent\n     * @param shape {SmartShape} Shape to return SVG element for\n     * @returns {HTMLOrSVGElement|null|*}\n     */\n    this.getShapeSvg = () => {\n        return SmartShapeDrawHelper.getShapeSvg(this);\n    }\n\n    /**\n     * Method exports shape and all its children to SVG document.\n     * @param includeChildren {boolean} Should include children of this shape to output.\n     * 'null' by default. In this case value of shape.options.groupChildShapes will be used*\n     * @returns {string} Body of SVG document as a string\n     */\n    this.toSvg = (includeChildren=null) => {\n        return SmartShapeDrawHelper.toSvg(this,includeChildren);\n    }\n\n    /**\n     * Method exports shape and all its children as a PNG image\n     * @param {PngExportTypes} type Format of returned result - `dataurl` or `blob`. By default `dataurl`\n     * @param {number|null} width Width of image. If not specified, then calculate based on height or current\n     * width of shape\n     * @param {number|null} height Height of image. If not specified, then calculate based on width or current\n     * height of shape\n     * @param includeChildren {boolean} Should include children of this shape to output.\n     * 'null' by default. In this case value of shape.options.groupChildShapes will be used*\n     * @return {Promise} Promise that resolves either to DataURL string or to BLOB object, depending on value of\n     * `type` argument\n     */\n    this.toPng = (type= PngExportTypes.DATAURL,width=null,height=null,includeChildren=null) => {\n        return SmartShapeDrawHelper.toPng(this,type,width,height,includeChildren);\n    }\n\n    /**\n     * Method used to save shape to JSON string.\n     * Returns string with JSON object or JSON array, depending on should it save children too\n     * @param includeChildren {boolean} If true, then it appends JSONs\n     * of all children to `children` property of resulting JSON.\n     * @param compact {boolean} If this is true, then it will save only coordinates of\n     * points, but not their properties\n     * @returns {string} Serialized JSON as string.\n     */\n    this.toJSON = (includeChildren=true,compact=false) => {\n        return JSON.stringify(this.getJSON(includeChildren,compact))\n    }\n\n    /**\n     * Method creates complete copy of current shape\n     * @param options {object} Array of shape options to override on cloned object.\n     * @param includeChildren {boolean} If true, then clones all children of this shape as well\n     * Any [SmartShape options](#SmartShape+options) can be in this object.\n     * @returns {SmartShape|null} Created shape object or null in case of errors\n     */\n    this.clone = (options={},includeChildren=true) => {\n        const json = mergeObjects({},this.getJSON(includeChildren));\n        json.parent_guid = this.guid;\n        json.options = mergeObjects(json.options,options);\n        const result = new SmartShape().fromJSON(this.root,json,includeChildren);\n        if (!result) {\n            return null\n        }\n        result.getChildren(true).forEach(child => {\n            child.options.id += \"_\" + SmartShapeManager.length();\n            child.options.name += \" \" + SmartShapeManager.length();\n        });\n        return result;\n    }\n\n    /**\n     * @ignore\n     * Method used to save shape to Javascript object\n     * Returns JSON object or JSON array, depending on should it save children too\n     * @param includeChildren {boolean} If true, then it appends JSONs\n     * of all children to `children` property of resulting JSON\n     * @param compact {boolean} If this is true, then it will save only coordinates of\n     * points, but not their properties\n     * @returns {object} Javascript object with shape and it's children, if `includeChildren` is true.\n     */\n    this.getJSON = (includeChildren = true, compact = false) => {\n        const result = {\n            options: mergeObjects({},this.options)\n        }\n        result.options.displayMode = SmartShapeDisplayMode.DEFAULT;\n        if (compact || this.options.compactExport) {\n            result.points = this.points.map(point => [point.x,point.y]);\n        } else {\n            result.points = this.points.filter(point => typeof(point.getJSON) === \"function\").map(point => point.getJSON());\n        }\n        if (includeChildren) {\n            let children = this.getChildren();\n            if (children.length) {\n                result.children = children.map(\n                    child => child.getJSON(includeChildren,compact || this.options.compactExport)\n                );\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Method used to load shape data from specified JSON string, that previously serialized by `toJSON` method\n     * @param root {HTMLElement} HTML container to insert loaded shape\n     * @param json {string|object} JSON-Serialized shape data as an object or as a string\n     * @param includeChildren {boolean} Should load children of this shape if existed. True by default.\n     * @returns {SmartShape|null} Loaded SmartShape object or null in case of JSON reading errors\n     */\n    this.fromJSON = (root,json,includeChildren = true,emitCreateEvent = true) => {\n        let jsonObj = typeof(json) === \"string\" ? readJSON(json) : json;\n        if (!jsonObj) {\n            return null;\n        }\n        this.root = root;\n        if (SmartShapeManager.findShapeById(jsonObj.options.id)) {\n            jsonObj.options.id += \"_\"+SmartShapeManager.length();\n            jsonObj.options.name += \" \"+SmartShapeManager.length();\n        }\n        if (!this.svg) {\n            jsonObj.options.forceCreateEvent = false;\n            this.init(root,jsonObj.options,null,false);\n        } else {\n            this.setOptions(jsonObj.options);\n        }\n        jsonObj.points.forEach(point => {\n            let p\n            if (point.length) {\n                p = this.putPoint(point[0],point[1]);\n                p.setOptions(jsonObj.options.pointOptions || {})\n            } else {\n                p = this.putPoint(point.x, point.y, point.options || jsonObj.options.pointOptions);\n            }\n            p && p.updateContextMenu();\n        })\n        const parent = SmartShapeManager.getShapeByGuid(jsonObj.parent_guid);\n        SmartShapeManager.addShape(this);\n        if (includeChildren && typeof(jsonObj.children) !== \"undefined\" && jsonObj.children) {\n            this.getChildren(true).forEach(child=>child.destroy());\n            jsonObj.children.forEach(child => {\n                child.parent_guid = this.guid;\n                this.addChild(new SmartShape().fromJSON(root,child));\n            })\n        }\n        if (emitCreateEvent) {\n            EventsManager.emit(ShapeEvents.SHAPE_CREATE, this, {parent});\n        }\n        return this;\n    }\n\n    /**\n     * GroupHelper methods\n     */\n\n    /**\n     * Method used to add specified shape as a child of current shape\n     * @param child {SmartShape} Shape to add\n     * @param emitEvent {boolean} Should this method emit ADD_CHILD event. True by default\n     */\n    this.addChild = (child,emitEvent) => this.groupHelper.addChild(child,emitEvent);\n\n    /**\n     * Method used to add specified children to current shape\n     * @param children {array} Array of [SmartShape][#SmartShape) objects\n     */\n    this.addChildren = (children=[]) => this.groupHelper.addChildren(children);\n\n    /**\n     * Method used to remove specified shape from children list of current shape\n     * @param child {SmartShape} SmartShape object to add\n     */\n    this.removeChild = (child) => this.groupHelper.removeChild(child);\n\n    /**\n     * Method removes all children of current shape\n     * @param all {boolean} If true, then it removes all children hierarchically\n     */\n    this.removeAllChildren = (all=false) => this.groupHelper.removeAllChildren(all);\n\n    /**\n     * Method returns array of children of current shape\n     * @param all {boolean} If true, then it returns deep list, including all children of each children of this shape\n     * @returns {array} Array of [SmartShape](#SmartShape) objects\n     */\n    this.getChildren = (all=false) => this.groupHelper.getChildren(all);\n\n    /**\n     * Method returns if specified shape is child of current shape\n     * @param child {SmartShape} Shape to check\n     * @param all {boolean} Should check include subchildren\n     */\n    this.hasChild = (child,all=false) => this.groupHelper.hasChild(child,all);\n\n    /**\n     * Method returns parent of current shape or null\n     * @returns {SmartShape|null}\n     */\n    this.getParent = () => this.groupHelper.getParent();\n\n    /**\n     * Method returns top parent of current shape\n     * @returns {SmartShape|null} Parent shape or null\n     */\n    this.getRootParent = (groupChildShapes= null) => this.groupHelper.getRootParent(groupChildShapes);\n\n    /**\n     * Method returns a list of parents of current shape ordered from nearest to root\n     * @param plist {array} Temporary list of parents from previous recursive call\n     * @returns {array} Array of [SmartShape](#SmartShape) objects\n     */\n    this.getParentsList = (plist=[]) => this.groupHelper.getParentsList(plist);\n\n    /**\n     * Method used to transform coordinates of point on current shape\n     * to coordinate of points of original shape, before all transformations done\n     * on it (move,scale or flip)\n     * @param x X coordinate\n     * @param y Y coordinate\n     * @returns {array} Array of new coordinates [x,y]\n     */\n    this.mapCurrentPointToOriginal = (x,y) =>\n        mapPointCords(x, y, PointMapTypes.CURRENT_TO_ORIGINAL, {\n            ...this.options,\n            ...this.getPosition(this.options.groupChildShapes),\n        }\n    );\n\n    /**\n     * Method used to transform coordinates of point of orignal shape\n     * to coordinate of points of current shape, after all transformations done\n     * on it (move,scale or flip)\n     * @param x X coordinate\n     * @param y Y coordinate\n     * @returns {array} Array of new coordinates [x,y]\n     */\n    this.mapOriginalPointToCurrent = (x,y) =>\n        mapPointCords(x, y, PointMapTypes.ORIGINAL_TO_CURRENT, {\n            ...this.options,\n            ...this.getPosition(this.options.groupChildShapes),\n        }\n    );\n}\n\n/**\n * Enumeration of SmartShape display modes\n * @param default basic display mode without resize or rotate boxes and points are hidden\n * @param selected In this mode the points displayed on shape, but resize and rotate boxes are hidden\n * @param scale In this mode the shape displayed with resize box around it\n * @param rotate In this mode the shape displayed with rotate box around it\n * @enum {string}\n */\nexport const SmartShapeDisplayMode = {\n    DEFAULT: \"default\",\n    SELECTED: \"selected\",\n    SCALE: \"scale\",\n    ROTATE: \"rotate\"\n}\n\nexport default SmartShape;\n","import SmartShape from \"../SmartShape/SmartShape.js\";\nimport {PointMoveDirections} from \"../SmartPoint/SmartPoint.js\";\nimport ResizeBoxEventListener from \"./ResizeBoxEventListener.js\";\nimport EventsManager from \"../events/EventsManager.js\";\nimport {ShapeEvents} from \"../SmartShape/SmartShapeEventListener.js\";\nimport {resize_lb,resize_cb,resize_ct,resize_lc,resize_lt,resize_rb,resize_rc,resize_rt} from \"../../assets/graphics.js\";\nimport {mergeObjects, uuid} from \"../utils\";\n/**\n * Class represents a special type of shape, that shows the rectangle with markers on\n * it corners, used to resize it. [See demo](https://code.germanov.dev/smart_shape/tests/prod/resize_box.html).\n * Mostly used to resize [SmartShape](#SmartShape) object, but also can be used as an independent shape\n * for tasks like resizing objects on a web page or select rectangular regions.\n * @constructor\n */\nfunction ResizeBox() {\n\n    /**\n     * Left corner of resize box\n     * @type {number}\n     */\n    this.left = 0;\n\n    /**\n     * Top corner of resize box\n     * @type {number}\n     */\n    this.top = 0;\n\n    /**\n     * Right corner of resize box\n     * @type {number}\n     */\n    this.right = 0;\n\n    /**\n     * Bottom corner of resize box\n     * @type {number}\n     */\n    this.bottom = 0;\n\n    /**\n     * Width of resize box\n     * @type {number}\n     */\n    this.width = 0;\n\n    /**\n     * Height of resize box\n     * @type {number}\n     */\n    this.height = 0;\n\n    /**\n     * Underlying shape, that used to service this resize box\n     * (draw, point event handling and so on)\n     * @type {SmartShape}\n     */\n    this.shape = null;\n\n    /**\n     * Global unique identifier of this object.\n     * Generated automatically\n     * @type {string}\n     */\n    this.guid = uuid()\n\n    /**\n     * Options of resize box\n     * @param id {string} Unique ID or resize box. If instantiated by [SmartShape](#SmartShape), then setup\n     * automatically\n     * @param shapeOptions {object} Options of underlying shape, that used to draw and manage this ResizeBox. See\n     * [SmartShape.options](#SmartShape+options)\n     * @param zIndex {number} Order of element in a stack of HTML elements\n     * (https://www.w3schools.com/cssref/pr_pos_z-index.asp). Elements if higher z-index value placed on top.\n     * @param onlyMove {boolean} If enabled, then resizeBox displayed as hidden. It's possible to drag it, but\n     * but not resize\n     * @type {object}\n     */\n    this.options = {\n        id: \"\",\n        shapeOptions: {\n            id: \"\",\n            canAddPoints: false,\n            canDeletePoints: false,\n            pointOptions: {\n                style: {\n                    \"border-width\": \"0px\",\n                    \"border-radius\": \"0px\",\n                    backgroundColor: \"rgba(0,0,0,0)\",\n                    cursor:\"pointer\",\n                },\n                forceDisplay:true,\n                width:13,\n                height:13,\n            },\n            style: {\n                \"stroke-width\":\"2px\",\n                \"stroke\":\"#aaaaaa\",\n                \"stroke-dasharray\": \"10\",\n                fill:\"none\",\n            }\n        },\n        zIndex: 1000,\n        onlyMove: false\n    }\n\n    /**\n     * Event listener that handles event listening logic for this resize box.\n     * Instance of [ResizeBoxEventListener](#ResizeBoxEventListener) class.\n     * @type {ResizeBoxEventListener}\n     */\n    this.eventListener = null;\n\n    /**\n     * Left top marker point\n     * @type {SmartPoint}\n     */\n    this.left_top = null;\n\n    /**\n     * Left center marker point\n     * @type {SmartPoint}\n     */\n    this.left_center = null;\n\n    /**\n     * Left bottom marker point\n     * @type {SmartPoint}\n     */\n    this.left_bottom = null;\n\n    /**\n     * Center top marker point\n     * @type {SmartPoint}\n     */\n    this.center_top = null;\n\n    /**\n     * Center bottom marker point\n     * @type {SmartPoint}\n     */\n    this.center_bottom = null;\n\n    /**\n     * Right top marker point\n     * @type {SmartPoint}\n     */\n    this.right_top = null;\n\n    /**\n     * Right center marker point\n     * @type {SmartPoint}\n     */\n    this.right_center = null;\n\n    /**\n     * Right bottom marker point\n     * @type {SmartPoint}\n     */\n    this.right_bottom = null;\n\n    /**\n     * Method used to construct ResizeBox object with specified coordinates and\n     * size, with specified `options`. Then it binds this object to specified `root`\n     * HTML node and displays it\n     * @param root {HTMLElement} HTML element that used as a container for this ResizeBox\n     * @param left {number} Left corner of shape relative to container top left\n     * @param top {number} Top corner of shape relative to container top left\n     * @param width {number} Width of shape\n     * @param height {number} Height of shape\n     * @param options {object} Options used to setup ResizeBox. See [here](#ResizeBox+options).\n     * @returns {ResizeBox} constucted ResizeBox object\n     */\n    this.init = (root,left,top,width,height,options={}) => {\n        this.left = parseInt(left);\n        this.top = parseInt(top);\n        this.width = parseInt(width);\n        this.height = parseInt(height);\n        this.right = this.left + this.width;\n        this.bottom = this.top + this.height;\n        this.setOptions(options);\n        this.options.shapeOptions.id = this.options.id;\n        this.options.shapeOptions.canRotate = false;\n        this.options.shapeOptions.canScale = false;\n        this.shape = new SmartShape().init(root,mergeObjects({},this.options.shapeOptions),[]);\n        EventsManager.emit(ShapeEvents.SHAPE_CREATE, this.shape, {});\n        this.options.shapeOptions.pointOptions.bounds = this.shape.getBounds();\n        this.addPoints();\n        this.eventListener = new ResizeBoxEventListener(this).run();\n        return this;\n    }\n\n    /**\n     * Method used to change options of ResizeBox.\n     * @param options {object} Options object. See [here](#ResizeBox+options).\n     */\n    this.setOptions = (options = {}) => {\n        if (!options || typeof(options) !== \"object\") {\n            return\n        }\n        this.options = mergeObjects(this.options,options);\n        this.options.shapeOptions.zIndex = this.options.zIndex || 1000;\n        this.options.shapeOptions.id = this.options.id || \"\";\n        if (this.shape) {\n            this.shape.setOptions(this.options.shapeOptions);\n        }\n    }\n\n    /**\n     * @ignore\n     * Method used to add marker points to ResizeBox, that lately used to resize the box\n     */\n    this.addPoints = () => {\n        this.left_top = this.shape.putPoint(this.left,this.top,{id:this.shape.guid+\"_left_top\",style:{backgroundImage: \"url('\"+resize_lt+\"')\"}});\n        this.center_top = this.shape.putPoint(this.left+this.width/2,this.top,{id:this.shape.guid+\"_center_top\",style:{backgroundImage: \"url('\"+resize_ct+\"')\"}});\n        this.right_top = this.shape.putPoint(this.right,this.top,{id:this.shape.guid+\"_right_top\",style:{backgroundImage: \"url('\"+resize_rt+\"')\"}});\n        this.right_center = this.shape.putPoint(this.right,this.top+this.height/2,{id:this.shape.guid+\"_right_center\",style:{backgroundImage: \"url('\"+resize_rc+\"')\"}});\n        this.right_bottom = this.shape.putPoint(this.right,this.bottom,{id:this.shape.guid+\"_right_bottom\",style:{backgroundImage: \"url('\"+resize_rb+\"')\"}});\n        this.center_bottom = this.shape.putPoint(this.left+this.width/2,this.bottom,{id:this.shape.guid+\"_center_bottom\",style:{backgroundImage: \"url('\"+resize_cb+\"')\"}});\n        this.left_bottom = this.shape.putPoint(this.left,this.bottom,{id:this.shape.guid+\"_left_bottom\",style:{backgroundImage: \"url('\"+resize_lb+\"')\"}});\n        this.left_center = this.shape.putPoint(this.left,this.top+this.height/2,{id:this.shape.guid+\"_left_center\",style:{backgroundImage: \"url('\"+resize_lc+\"')\"}});\n        this.setPointsOptions();\n    }\n\n    /**\n     * @ignore\n     * Method used to setup marker points of ResizeBox\n     */\n    this.setPointsOptions = () => {\n        this.setPointsMoveDirections();\n        this.setPointsMoveBounds();\n    }\n\n    /**\n     * @ignore\n     * Method used to setup to which directions allowed to move marker points.\n     * For example, some of them possible to move only horizontally, others, only vertically.\n     * See [SmartShape.options.moveDirections](#SmartShape+options) to learn more.\n     */\n    this.setPointsMoveDirections = () => {\n        this.center_top.setOptions({moveDirections:[PointMoveDirections.TOP,PointMoveDirections.BOTTOM]});\n        this.center_bottom.setOptions({moveDirections:[PointMoveDirections.TOP,PointMoveDirections.BOTTOM]});\n        this.left_center.setOptions({moveDirections:[PointMoveDirections.LEFT,PointMoveDirections.RIGHT]});\n        this.right_center.setOptions({moveDirections:[PointMoveDirections.LEFT,PointMoveDirections.RIGHT]});\n    }\n\n    /**\n     * @ignore\n     * Method used to set bounds, to which possible to move each marker point of ResizeBox\n     * For example, it's impossible to drag right corner beyond left corner, top corner beyond bottom corner.\n     */\n    this.setPointsMoveBounds = () => {\n        this.left_top.options.bounds.bottom = this.left_bottom.y-this.left_bottom.options.height-this.left_center.options.height;\n        this.left_top.options.bounds.right = this.right_top.x-this.right_top.options.width-this.center_top.options.width;\n        this.center_top.options.bounds.bottom = this.left_bottom.y-this.left_bottom.options.height-this.left_center.options.height;\n        this.right_top.options.bounds.bottom = this.left_bottom.y-this.left_bottom.options.height-this.left_center.options.height;\n        this.right_top.options.bounds.left = this.left_top.x+this.right_top.options.width+this.center_top.options.width;\n        this.right_center.options.bounds.left = this.left_top.x+this.right_center.options.width+this.center_top.options.width;\n        this.right_bottom.options.bounds.left = this.left_top.x+this.right_bottom.options.width+this.center_bottom.options.width;\n        this.right_bottom.options.bounds.top = this.right_top.y+this.right_top.options.height+this.right_center.options.height;\n        this.center_bottom.options.bounds.top =this.center_top.y+this.center_top.options.height+this.right_center.options.height;\n        this.left_bottom.options.bounds.right = this.right_bottom.x-this.right_bottom.options.width-this.center_bottom.options.width;\n        this.left_bottom.options.bounds.top = this.left_top.y+this.left_top.options.height+this.left_center.options.height;\n        this.left_center.options.bounds.right = this.right_center.x-this.right_center.options.width-this.center_top.options.width;\n    }\n\n    /**\n     * @ignore\n     * Method used to recalculate coordinates of marker points\n     * according to current ResizeBox coordinates and dimensions.\n     */\n    this.adjustCoordinates = () => {\n        this.right = this.left + this.width;\n        this.bottom = this.top + this.height;\n        this.left_top.x = this.left;\n        this.left_top.y = this.top;\n        this.right_top.x = this.right;\n        this.right_top.y = this.top;\n        this.left_bottom.x = this.left;\n        this.left_bottom.y = this.bottom;\n        this.right_bottom.x = this.right;\n        this.right_bottom.y = this.bottom;\n        this.center_top.y = this.top;\n        this.center_bottom.y = this.bottom;\n        this.left_center.x = this.left;\n        this.right_center.x = this.right;\n        this.adjustCenters();\n    }\n\n    /**\n     * @ignore\n     * Method used to recalculate coordinates of point markers, located on the centers of rectangle,\n     * after user dragged corner markers.\n     */\n    this.adjustCenters = () => {\n        this.center_top.x = parseInt(this.left_top.x+(this.right_top.x-this.left_top.x)/2);\n        this.center_bottom.x = parseInt(this.left_top.x+(this.right_top.x-this.left_top.x)/2);\n        this.left_center.y = parseInt(this.left_top.y+(this.left_bottom.y-this.left_top.y)/2);\n        this.right_center.y = parseInt(this.right_top.y+(this.right_bottom.y-this.right_top.y)/2);\n    }\n\n    /**\n     * @ignore\n     * Internal method that used to calculate resize box dimensions, based on point coordinates.\n     * Set left,top,right,bottom,width and height of resize box.\n     */\n    this.calcPosition = () => {\n        this.shape.calcPosition();\n        this.left = this.shape.left;\n        this.top = this.shape.top;\n        this.bottom = this.shape.bottom;\n        this.right = this.shape.right;\n        this.width = this.shape.width;\n        this.height = this.shape.height;\n    }\n\n    /**\n     * Method used to get current position of Resize Box\n     * @returns {object} Position with fields:\n     * `top`,`left`,`right`,`bottom`,`width`,`height`\n     */\n    this.getPosition = () => {\n        return  {top:this.top, left: this.left, bottom: this.bottom, right: this.right, width: this.width, height:this.height}\n    }\n\n\n    /**\n     * Method used to redraw resize box\n     */\n    this.redraw = () => {\n        this.adjustCoordinates();\n        this.shape.setOptions(this.options.shapeOptions);\n        this.setPointsMoveBounds();\n        this.shape.redraw();\n        this.applyOnlyMove();\n    }\n\n    /**\n     * Method used to show Resize Box if it has hidden\n     */\n    this.show = () => {\n        this.options.shapeOptions.visible = true;\n        this.shape.show();\n    }\n\n    /**\n     * Method used to hide Resize Box\n     */\n    this.hide = () => {\n        this.options.shapeOptions.visible = false;\n        this.shape.hide();\n    }\n\n    /**\n     * Destroys the ResizeBox. Destroys all points, removes event listeners and removes the shape from screen.\n     * But variable continue existing. To completely remove the shape,\n     * set the variable to 'null' after calling this method.\n     */\n    this.destroy = () => {\n        EventsManager.emit(ShapeEvents.SHAPE_DESTROY,this,{});\n        this.eventListener.destroy();\n        this.shape.destroy();\n    }\n\n    /**\n     * Uniform method that used to add event handler of specified type to this object.\n     * ResizeBox can emit events, defined in [ResizeBoxEvents](#ResizeBoxEvents) enumeration. So, you can\n     * listen any of these events.\n     * @param eventName {string} - Name of event. Use one of names, defined in [ResizeBoxEvents](#ResizeBoxEvents)\n     * @param handler {function} - Function that used as an event handler\n     * @returns {function} - Pointer to added event handler. Should be used to remove event listener later.\n     */\n    this.addEventListener = (eventName,handler) => {\n        return this.eventListener.addEventListener(eventName,handler);\n    }\n\n    /**\n     * Uniform method that used to remove event handler, that previously added\n     * to this object.\n     * @param eventName {ResizeBoxEvents|string} Name of event to remove listener from\n     * @param listener {function} Pointer to event listener, that added previously.\n     * It was returned from [addEventListener](#ResizeBox+addEventListener) method.\n     */\n    this.removeEventListener = (eventName,listener) => {\n        this.eventListener.removeEventListener(eventName,listener);\n    }\n\n    this.applyOnlyMove = () => {\n        if (this.options.onlyMove) {\n            this.shape.svg.style.opacity = 0;\n            this.shape.points.forEach((point) => {\n               point.options.visible = false;\n               if (point.element) {\n                   point.redraw();\n               }\n            })\n        } else {\n            this.shape.svg.style.opacity = 1;\n            this.shape.points.forEach((point) => {\n                point.options.visible = this.shape.options.visible;\n                if (point.element) {\n                    point.redraw();\n                }\n            })\n        }\n    }\n}\n\nexport default ResizeBox;\n","import ResizeBox from \"./ResizeBox/ResizeBox.js\";\nimport RotateBox from \"./RotateBox/RotateBox.js\";\nimport SmartShape, {SmartShapeDisplayMode} from \"./SmartShape/SmartShape.js\";\nimport SmartShapeManager from \"./SmartShapeManager/SmartShapeManager.js\";\nimport EventsManager from \"./events/EventsManager.js\";\nimport SmartShapeEventListener,{ShapeEvents} from \"./SmartShape/SmartShapeEventListener.js\";\nimport SmartShapeGroupHelper from \"./SmartShape/SmartShapeGroupHelper.js\";\nimport {createEvent,getMousePos,getMouseCursorPos} from \"./events/functions.js\";\n\ntry {\n    window.ResizeBox = ResizeBox;\n    window.SmartShape = SmartShape;\n    window.RotateBox = RotateBox;\n    window.SmartShapeManager = SmartShapeManager;\n    window.SmartShapeGroupHelper = SmartShapeGroupHelper;\n    window.SmartShapeDisplayMode = SmartShapeDisplayMode;\n    window.ShapeEvents = ShapeEvents;\n    window.createEvent = createEvent;\n    window.getMousePos = getMousePos;\n    window.getMouseCursorPos = getMouseCursorPos\n} catch (err) {}\n\nexport {\n    SmartShape,ResizeBox,RotateBox,SmartShapeManager,EventsManager,ShapeEvents,\n    SmartShapeDisplayMode,SmartShapeGroupHelper,SmartShapeEventListener,\n    createEvent, getMousePos, getMouseCursorPos\n};\n"],"names":["EventsManager","events","handler","event","eventName","h","target","params","result","index","EventsManager$3","degrees_to_radians","degrees","radians_to_degrees","radians","getRotatedCoords","angle","x","y","centerX","centerY","resultX","resultY","distance","x1","y1","x2","y2","distanceFromLine","x0","y0","t","d","isPointInsidePolygon","polygon","point","onSegment","q","r","orientation","val","doIntersect","p1","q1","p2","q2","o1","o2","o3","o4","extreme","count","i","next","applyAspectRatio","width","height","origWidth","origHeight","mapPointCords","type","scaleX","scaleY","offsetX","offsetY","flippedX","flippedY","PointMapTypes","flipPoint","byX","byY","pos","abs","defaultIsMergeableObject","value","isNonNullObject","isSpecial","stringValue","isReactElement","canUseSymbol","REACT_ELEMENT_TYPE","emptyTarget","cloneUnlessOtherwiseSpecified","options","deepmerge","defaultArrayMerge","source","element","getMergeFunction","key","customMerge","getEnumerableOwnPropertySymbols","symbol","getKeys","propertyIsOnObject","object","property","propertyIsUnsafe","mergeObject","destination","sourceIsArray","targetIsArray","array","prev","getOffset","elem","deep","uuid","c","pauseEvent","e","notNull","mergeObjects","objects","dataURLtoBlob","dataURI","byteString","mimeString","ab","ia","blobToDataURL","blob","resolve","reader","readJSON","jsonString","CSStoJsStyleName","cssName","timeout","ms","createEvent","origEvent","getMouseCursorPos","getMousePos","offset","EventsManager$1","MenuStylesHelper","menu","item","itemDiv","ItemParts","span","img","className","id","classType","Menu","items","container","eventType","StylesHelper","MenuEvents","div","imgItems","name","listener","maxSize","left","top","title","image","Menus","Menus$1","rotate_tl","rotate_tr","rotate_br","rotate_bl","resize_cb","resize_ct","resize_lb","resize_lc","resize_lt","resize_rb","resize_rc","resize_rt","add","del","save","svg","png","copy","group","ungroup","move_to_top","move_to_bottom","horizontal","vertical","to_path","to_shapes","base64_export","zoom_in","zoom_out","reset_zoom","SmartPointContextMenu","PointEvents","_event","PointMoveDirections","SmartPoint","ContainerEvents","SmartShapeManager","oldX","oldY","newX","newY","json","jsonObj","isNew","RotateBoxEventListener","rotateBox","ShapeEvents","clientX","clientY","angleDiff","RotateBoxEvents","hypotenuse","cathetus","startAngle","ResizeBoxEventListener","resizeBox","oldPos","newPos","ResizeBoxEvents","SmartShapeEventListener","shape","parent","diffX","diffY","pointWidth","pointHeight","stepX","stepY","bounds","SmartShapeDrawHelper","defs","child","SmartShapeDisplayMode","path","size","fill","gradientOptions","gradient","gradientTag","foundSteps","step","stepNode","imageFillOptions","pattern","filters","filterName","filter","filterOptions","attribute","includeChildren","groupChanged","paths","zoom","viewBox","parts","w1","w2","PngExportTypes","svgObj","href","svgString","DOMURL","url","canvas","ctx","zIndex","diff","SmartShapeDrawHelper$1","fromGeoJSON","geoJSON","progressCallback","obj","createShapeFromGeoJson","importOptions","isCorrectJSON","loadOptions","polygons","loadPolygons","idx","shapeOpts","geometry","fieldName","_polygon","cords","right","bottom","root","points","show","SmartShape","guid","shapes","max","min","displayMode","SmartShapeManagerEvents","dragshape","destShape","shapeOnCursor","matchedShapes","prevShape","compact","emitCreateEvent","err","progessCallback","SmartShapeManager$2","SmartShapeGroupHelper","emitEvent","children","all","groupChildShapes","parents","plist","minLeft","minTop","maxRight","maxBottom","RotateBox","SmartShapeContextMenu","itemsToAdd","itemToAdd","point1","point2","clone","filename","a","extension","pointOptions","beforePoint","p","beforeIndex","s1","s2","l","l1","l2","redraw","respectBounds","fast","newWidth","newHeight","level","checkBounds","shapeCenterX","shapeCenterY","mode","removed","minx","miny","maxx","maxy","forGroup","applyOffset","off","ResizeBox","h1","h2"],"mappings":"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"}